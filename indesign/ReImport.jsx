// ex: set et sw=2:

// TODO: Status indication
// TODO: Pairwise kerning
// TODO: Check for the double frame thing at beginning/end.
// TODO: Border tricks at end/beginning of frames
// TODO: Some kind of "only this" button
// TODO: Configurable (and savable) Title matcher (r'Title|Frame Top')
// TODO: Split (and unsplit!) frames on specific styles
// TODO: Maybe do the start-of-line negative kerning trick?
// TODO: Change "old load" checkbox to radio
// TODO: Offer the precooked searches!
// TODO: Indexing stuff

AUTOGENERATED_GROUP_NAME = "(autogenerated)";

function ri_main() {
  ri = {
    doc: app.activeDocument,
    reflow_changed: false,
    messages: []
  };
  ri_run(ri);
}

function ri_run(ri) {
  ri_analyze(ri);

  if (!ri_get_options(ri))
    return;

  if (ri.uig_import.checkedState)
    if (!ri_get_importee(ri))
      return;

  ri_start_counter(ri);
  ri_disable_grep(ri);
  ri_disable_reflow(ri);
  if (ri.uig_pre.checkedState) {
    ri_start_subcounter(ri);
    ri_pre_clear(ri);
    ri_stop_subcounter(ri, "Pre-Clear");
    ri_start_subcounter(ri);
    ri_pre_remaster(ri);
    ri_stop_subcounter(ri, "Pre-Master");
  }
  if (ri.uig_import.checkedState) {
    ri_start_subcounter(ri);
    ri_do_import(ri);
    ri_do_images(ri);
    ri_stop_subcounter(ri, "Import");
  }
  if (ri.uig_post.checkedState) {
    ri_start_subcounter(ri);
    ri_post_clear_overrides(ri);
    ri_reset_searches(ri);
    ri_post_fix_spaces(ri);
    ri_post_fix_specific_fonts(ri);
    ri_post_fix_dashes(ri);
    ri_post_remove_footnote_whitespace(ri);
    ri_post_convert_post_its(ri);
    ri_reset_searches(ri);
    ri_stop_subcounter(ri, "Post-Import");
  }
  ri_restore_reflow(ri);
  if (ri.uig_groom.checkedState) {
    ri_start_subcounter(ri);
    ri_groom_fully_justify(ri);
    ri_restore_reflow(ri);
    ri_groom_resize_tables(ri);
    ri_groom_fix_masters(ri);
    ri_groom_update_toc(ri);
    ri_stop_subcounter(ri, "Grooming");
  }
  ri_stop_counter(ri);
}

function ri_start_counter(ri) {
  ri.start_ms = new Date().valueOf();
}

function ri_stop_counter(ri) {
  end_ms = new Date().valueOf();
  elapsed = (end_ms - ri.start_ms) / 1000.0;

  ri.messages.unshift("Done in " + String(elapsed) + " Sec.");
  alert(ri.messages.join('\n'));
}

function ri_start_subcounter(ri) {
  ri.substart_ms = new Date().valueOf();
}

function ri_stop_subcounter(ri, name) {
  end_ms = new Date().valueOf();
  elapsed = (end_ms - ri.substart_ms) / 1000.0;

  ri.messages.push(name + ": took " + String(elapsed) + " Sec.");
}

function ri_analyze(ri) {
  var vars = ri.doc.textVariables;
  ri.var_settings = null;
  ri.saved_settings = {}

  for (var i = 0; i < vars.length; ++ i) {
    var cur = vars[i]
    if (cur.variableType != VariableTypes.CUSTOM_TEXT_TYPE)
      continue;

    var name = cur.name;
    var value = cur.variableOptions.contents;
    if (name == "Imported From") {
      cur.name = "ReImport Settings";
      ri.var_settings = cur;
      ri.saved_settings = {importee: value};
    } else if (name == "ReImport Settings") {
      ri.var_settings = cur;
      try {
        var obj = eval(value);
        if (obj != null) {
           ri.saved_settings = obj;
        }
      } catch (e) {
        ri.messages.push('Could not read settings: ' + e);
      }
    }
  }

  ri.last_importee = ri.saved_settings.importee;

  var stories = ri.doc.stories;
  ri.have_toc = false;
  if (ri.doc.tocStyles.length > 1) {
    ri.toc_styles = ri.doc.tocStyles.everyItem().name;
    ri.toc_styles.shift();
    for (var i = 0; i < stories.length && !ri.have_toc; ++ i) {
      ri.have_toc = (stories[i].storyType == StoryTypes.TOC_STORY);
    }
  }
}

function ri_get_options(ri) {
  var dlg = app.dialogs.add({name: "ReImport Options"});
  with (dlg) {
    with (dialogColumns.add()) {
      with (ri.uig_pre = enablingGroups.add({staticLabel: "Pre-Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_pre_remaster =
            checkboxControls.add({
              staticLabel: "Reset all parent pages",
              checkedState: !ri.saved_settings.not_pre_remaster,
            });
          ri.ui_pre_clear =
            checkboxControls.add({
              staticLabel: "Remove all text",
              checkedState: !ri.saved_settings.not_pre_clear,
            });
        }
      }

      with (ri.uig_import = enablingGroups.add({staticLabel: "Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          if (!ri.last_importee) {
            // staticTexts.add({staticLabel: "No previous import."});
          } else if (!File(ri.last_importee).exists) {
            staticTexts.add({staticLabel: "Cannot reload " + ri.last_importee});
          } else {
            ri.ui_same_importee = checkboxControls.add({
              staticLabel: "Reload " + String(ri.last_importee),
              checkedState: true,
            });
          }
          ri.ui_import_rerun = checkboxControls.add({
            staticLabel: "(If Tagged Taged) Try to reconvert",
            checkedState: true,
          });
          ri.ui_import_options = checkboxControls.add({
            staticLabel: "Show import options",
            checkedState: !ri.saved_settings.hide_import_options,
          });
          ri.ui_import_images = checkboxControls.add({
            staticLabel: "Import images",
            checkedState: !ri.saved_settings.dont_import_images,
          });
        }
      }

      with (ri.uig_post = enablingGroups.add({staticLabel: "Post-Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_post_clear_overrides =
            checkboxControls.add({
              staticLabel: "Clear all imported style overrides",
              checkedState: true,
            });
          ri.ui_post_fix_spaces =
            checkboxControls.add({
              staticLabel: "Eliminate multiple spaces",
              checkedState: true,
            });
          ri.ui_post_fix_specific_fonts =
            checkboxControls.add({
              staticLabel: "Fixes for specific Hebrew fonts",
              checkedState: !ri.saved_settings.unfix_specific_fonts,
            });
          ri.ui_post_fix_dashes =
            checkboxControls.add({
              staticLabel: "Fix spacing around dashes",
              checkedState: true,
            });
          ri.ui_post_remove_footnote_whitespace =
            checkboxControls.add({
              staticLabel: "Remove leading whitespace in footnotes",
              checkedState: !ri.saved_settings.unremove_footnote_whitespace,
            });
          ri.ui_post_convert_post_its =
            checkboxControls.add({
              staticLabel: "(If Tagged Text) Convert comments",
              checkedState: !ri.saved_settings.unconvert_post_its,
            });
        }
      }

      with (ri.uig_groom = enablingGroups.add({staticLabel: "Grooming", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_groom_resize_tables = checkboxControls.add({
            staticLabel: "Resize tables to frame width",
            checkedState: !ri.saved_settings.dont_shrink_tables,
          });
          ri.ui_groom_fully_justify =
            checkboxControls.add({
              staticLabel: "Fix to full justification",
              checkedState: !ri.saved_settings.unfix_justification,
            });
          ri.ui_groom_fix_masters =
            checkboxControls.add({
              staticLabel: "Fix parent pages",
              checkedState: !ri.saved_settings.unfix_masters,
            });
          ri.ui_groom_keep_masters =
            checkboxControls.add({
              staticLabel: "Keep correct parents",
              checkedState: !ri.saved_settings.unkeep_masters,
            });
          if (ri.have_toc) {
            ri.ui_groom_update_toc =
              checkboxControls.add({
                staticLabel: "Update TOC",
                checkedState: !ri.saved_settings.unupdate_toc,
              });
            ri.ui_groom_toc_style = dropdowns.add({
              stringList: ri.toc_styles,
              selectedIndex: 0
            });
          }
        }
      }

      with (borderPanels.add()) {
        with (dialogColumns.add() ) {
          staticTexts.add({staticLabel: "Default Parent:"});
          staticTexts.add({staticLabel: "Headless Parent:"});
          staticTexts.add({staticLabel: "First Parent:"});
        }
        with (dialogColumns.add()) {
          var masters = ri.doc.masterSpreads.everyItem().name;
          ri.ui_a_master = dropdowns.add({stringList: masters, selectedIndex: 0});
          ri.ui_b_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          ri.ui_c_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          if (ri.saved_settings.a_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.a_master)).isValid)
              ri.ui_a_master.selectedIndex = m.index;
          if (ri.saved_settings.b_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.b_master)).isValid)
              ri.ui_c_master.selectedIndex = ri.ui_b_master.selectedIndex = m.index;
          if (ri.saved_settings.c_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.c_master)).isValid)
              ri.ui_c_master.selectedIndex = m.index;
        }
      }

      with (checkboxControls) {
        with (dialogColumns.add()) {
          ri.ui_disable_grep = add({
            staticLabel: "Disable GREP styles while working",
            checkedState: !ri.saved_settings.keep_grep,
          });
          ri.ui_disable_reflow = add({
            staticLabel: "Disable smart reflow when applicable",
            checkedState: !ri.saved_settings.keep_reflow,
          });
        }
      }
    }
  }
  if (!dlg.show()) {
    dlg.destroy();
    return false;
  }

  ri.a_master_name = masters[ri.ui_a_master.selectedIndex];
  ri.a_master = ri.doc.masterSpreads.itemByName(ri.a_master_name);
  ri.b_master_name = masters[ri.ui_b_master.selectedIndex];
  ri.b_master = ri.doc.masterSpreads.itemByName(ri.b_master_name);
  ri.c_master_name = masters[ri.ui_c_master.selectedIndex];
  ri.c_master = ri.doc.masterSpreads.itemByName(ri.c_master_name);
  return true;
}

function ri_get_importee(ri) {
  if (ri.last_importee && ri.ui_same_importee && ri.ui_same_importee.checkedState)
    ri.importee = File(ri.last_importee);
  else
    ri.importee = File.openDialog("Choose your importee", ri.filter_files)
  return ri.importee;
}

function ri_filter_files(ri, file) {
  if (file.constructor.name == "Folder") {
    return true;
  }
  if (file.name.match(/\.(docx?|txt|idtt)$/)) {
    return true;
  }
  return false;
}

function ri_pre_remaster(ri) {
  if (!ri.ui_pre_remaster.checkedState)
    return;
  ri_reset_all_masters(ri);
}

function ri_reset_all_masters(ri) {
  var pages = ri.doc.pages;
  ri_maybe_set_master(ri, pages[0], ri.c_master);
  for (var i = 1; i < pages.length; ++ i)
    ri_maybe_set_master(ri, pages[i], ri.a_master);
}

function ri_pre_clear(ri) {
  if (!ri.ui_pre_clear.checkedState)
    return;
  var page = ri.doc.pages[0];
  try {
    var frame = ri_main_frame(ri, page)
    var story = frame.parentStory;
    story.contents = "";
  } catch (e) {
  }
  //ri_override_all_master_page_items(ri, page);
}

function ri_override_all_master_page_items(ri, page) {
  for (var i = 0; i < page.masterPageItems.length; ++ i) {
    mpi = page.masterPageItems[i];
    try {
      if (mpi.allowOverrides) {
        mpi.override(page);
      }
    } catch (e) {
    }
  }
}

function ri_do_import(ri) {
  var page = ri.doc.pages[0];
  var frame = ri_main_frame(ri, page);

  if (ri.ui_import_rerun.checkedState) {
    try {
      rerunner = ri.importee + '.rerun';
      mtime = File(rerunner).modified;
      if (mtime) {
        cmd = 'do shell script "' + rerunner + '"';
        ri.messages.push(cmd);
        app.doScript(cmd, ScriptLanguage.APPLESCRIPT_LANGUAGE);
        for (var n = 0; n < 50 && File(rerunner).modified.getTime() == mtime.getTime(); ++ n)
          $.sleep(100);
      }
      ri.messages.pop();
    } catch (e) {
      ri.messages.push('Could not rerun: ' + e);
    }
  }

  try {
    frame.place(ri.importee, ri.ui_import_options.checkedState);
  } catch (e) {
    ri.messages.push('Could not import document: ' + e);
  }

  if (!ri.var_settings)
    ri.var_settings = ri.doc.textVariables.add({
      name: "ReImport Settings",
      variableType: VariableTypes.CUSTOM_TEXT_TYPE
    });

  obj = {importee: ri.importee.fsName};

  obj["a_master"] = ri.a_master_name;
  obj["b_master"] = ri.b_master_name;
  obj["c_master"] = ri.c_master_name;
  obj["dont_import_images"] = !ri.ui_import_images.checkedState;
  obj["dont_shrink_tables"] = !ri.ui_groom_resize_tables.checkedState;
  obj["hide_import_options"] = !ri.ui_import_options.checkedState;
  obj["keep_grep"] = !ri.ui_disable_grep.checkedState;
  obj["keep_reflow"] = !ri.ui_disable_reflow.checkedState;
  obj["not_pre_clear"] = !ri.ui_pre_clear.checkedState;
  obj["not_pre_remaster"] = !ri.ui_pre_remaster.checkedState;
  obj["unconvert_post_its"] = !ri.ui_post_convert_post_its.checkedState;
  obj["unfix_justification"] = !ri.ui_groom_fully_justify.checkedState;
  obj["unfix_masters"] = !ri.ui_groom_fix_masters.checkedState;
  obj["unfix_specific_fonts"] = !ri.ui_post_fix_specific_fonts.checkedState;
  obj["unkeep_masters"] = !ri.ui_groom_keep_masters.checkedState;
  obj["unremove_footnote_whitespace"] = !ri.ui_post_remove_footnote_whitespace;
  if (ri.have_toc) {
    obj["unupdate_toc"] = !ri.ui_groom_update_toc.checkedState;
  }
  ri.var_settings.variableOptions.contents = uneval(obj);
}

function ri_do_images(ri) {
  if (!ri.ui_import_images.checkedState)
    return;

  try {
    var image_ref_style = ri.doc
      .characterStyleGroups.item(AUTOGENERATED_GROUP_NAME)
      .characterStyles.item("(Image)");
    if (!image_ref_style.isValid)
      return;
  } catch (e) {
    return;
  }

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "\\S+";
  app.findGrepPreferences.appliedCharacterStyle = image_ref_style;

  var where = app;
  try {
    var page = ri.doc.pages[0];
    var frame = ri_main_frame(ri, page)
    where = frame.parentStory;
  } catch (e) {
  }

  var refs = where.findGrep();
  for (var i = 0; i < refs.length; ++ i) {
    var ref = refs[i];
    var path = File(ri.doc.filePath + "/" + ref.contents);
    ref.select();
    try {
      ri.doc.place(path);
    } catch(e) {
      ri.messages.push('Could not import image ' + path + ': ' + e);
    }
  }

  app.findGrepPreferences = NothingEnum.nothing;

  var links = ri.doc.links;
  for (var i = 0; i < links.length; ++ i) {
    links[i].unlink();
  }
}

function ri_post_clear_overrides(ri) {
  if (!ri.ui_post_clear_overrides.checkedState)
    return;
  ri.doc.stories.everyItem().clearOverrides();
  try {
    ri.doc.stories.everyItem().footnotes.everyItem().texts.everyItem().clearOverrides();
  }
  catch (e) {
  }
}

function ri_post_fix_spaces(ri) {
  if (!ri.ui_post_fix_spaces.checkedState)
    return;

  // Multiple Space to Single Space (ships with InDesign)
  //ri_change_grep(ri, "[~m~>~f~|~S~s~<~/~.~3~4~% ]{2,}", " ");

  // Multiple Return to Single Return (ships with InDesign)
  //ri_change_grep(ri, "~b~b+", "\\r");

  // Only care about space-space, and combine the two searches
  ri_change_grep(ri, "([ ~b])\\1+", "$1");
}

function ri_post_fix_dashes(ri) {
  if (!ri.ui_post_fix_dashes.checkedState)
    return;

  ri_change_grep(ri, "[~m~>~f~|~s~<~/~.~3~4~% ~k]+([-+~=~_/]+)", "~S$1");
  ri_change_grep(ri, "([-+~=~_/]+)[~m~>~f~|~S~s~<~/~.~3~4~% ~k]+", "$1 ");
}

function ri_post_fix_specific_fonts(ri) {
  if (!ri.ui_post_fix_specific_fonts.checkedState)
    return;

  // VAV WITH HOLAM in Hadassah Friedlaender
  ri_fix_vav_in_font(ri, "Hadassah Friedlaender");
  ri_change_grep(ri, "([^~m~>~f~|~S~s~<~/~.~3~4~% ~k])(\\x{FB4B})", "$1~j$2");
  ri_change_grep(ri, "(\\x{FB4B})([^~m~>~f~|~S~s~<~/~.~3~4~% ~k])", "$1~j$2");

  // Em-dash in MF_FrankRuhl (but Hebrew kav mafrid is officialy en-dash :(
  // ri_en_to_em_dash_in_font(ri, "MF_FrankRuhl")
}

function ri_fix_vav_in_font(ri, fontname) {
  app.findGrepPreferences.appliedFont = fontname;
  ri_change_grep(ri, "\\x{05D5}\\x{05B9}", "\\x{FB4B}");
  ri_change_grep(ri, "[~m~>~f~|~S~s~<~/~.~3~4~% ~k]+([-+~=/]+)", "~S$1");
  app.findGrepPreferences = NothingEnum.nothing;
}

//function ri_en_to_em_dash_in_font(ri, fontname) {
//  app.findGrepPreferences.appliedFont = fontname;
//  ri_change_grep(ri, "(?<!\S)~=", "~_");
//  ri_change_grep(ri, "~=(?!\S)", "~_");
//  app.findGrepPreferences = NothingEnum.nothing;
//}

function ri_post_remove_footnote_whitespace(ri) {
  if (!ri.ui_post_remove_footnote_whitespace.checkedState)
    return;

  app.findGrepPreferences.findWhat = "(?<=^~F\\t) +";
  app.changeGrepPreferences.changeTo = "";
  try {
    ri.doc.stories.everyItem()
      .footnotes.everyItem()
      .texts.everyItem()
      .changeGrep();
  } catch (e) {
  }
}

function ri_post_convert_post_its(ri) {
  if (!ri.ui_post_convert_post_its.checkedState)
    return;

  try {
    var ugly_ref_style = ri.doc
      .characterStyleGroups.item(AUTOGENERATED_GROUP_NAME)
      .characterStyles.item("(Comment Reference)");
  } catch (e) {
    return;
  }

  if (!ugly_ref_style.isValid)
    return;

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "~F";
  app.findGrepPreferences.appliedCharacterStyle = ugly_ref_style;

  var ugly_refs = app.findGrep();
  for (var i = ugly_refs.length - 1; i >= 0; -- i) {
    var ugly_ref = ugly_refs[i].footnotes[0];
    if (!ugly_ref.isValid)
      continue;

    var nice_frame = ri.doc.textFrames.add();

    var ugly_paragraphs = ugly_ref.paragraphs;
    for (var j = 0; j < ugly_paragraphs.length; ++ j) {
      var ugly_paragraph = ugly_paragraphs[j];
      var nice_paragraph = ugly_paragraph.duplicate(LocationOptions.AT_END, nice_frame);

      nice_characters = nice_paragraph.characters;
      if (nice_characters[0].contents == SpecialCharacters.FOOTNOTE_SYMBOL) {
        nice_characters.itemByRange(0, 1).remove();
      }
    }

    nice_frame.anchoredObjectSettings
      .insertAnchoredObject(ugly_ref.storyOffset, AnchorPosition.ANCHORED);

    ri_fix_post_it(ri, nice_frame);
  }

  // Get rid of the ugly footnotes
  ri.doc.changeGrep();

  // Get rid of the ugly style
  ugly_ref_style.remove();
}

function ri_fix_post_it(ri, frame) {
  frame.applyObjectStyle(ri_post_it_object_style(ri));

  var prefs = frame.textFramePreferences;
  prefs.insetSpacing = 2;
  prefs.autoSizingType = AutoSizingTypeEnum.HEIGHT_ONLY;

  var baseline = frame.baselineFrameGridOptions;
  baseline.useCustomBaselineFrameGrid = true;
  baseline.baselineFrameGridRelativeOption = BaselineFrameGridRelativeOption.TOP_OF_FRAME;
  baseline.startingOffsetForBaselineFrameGrid = 0;
  baseline.baselineFrameGridIncrement = "9pt";

  var anchoring = frame.anchoredObjectSettings;
  anchoring.spineRelative = true;
  anchoring.anchorPoint = AnchorPoint.TOP_RIGHT_ANCHOR;
  anchoring.anchoredPosition = AnchorPosition.ANCHORED;
  anchoring.horizontalAlignment = HorizontalAlignment.LEFT_ALIGN;
  anchoring.horizontalReferencePoint = AnchoredRelativeTo.TEXT_FRAME;
  anchoring.anchorXoffset = "6pt";
  anchoring.verticalAlignment = VerticalAlignment.TOP_ALIGN;
  anchoring.verticalReferencePoint = VerticallyRelativeTo.TOP_OF_LEADING;
  anchoring.anchorYoffset = "0pt";

  var drop = frame.transparencySettings.dropShadowSettings;
  drop.mode = ShadowMode.DROP;
  drop.opacity = 50;
  drop.distance = "6pt";

  frame.resize(
    BoundingBoxLimits.GEOMETRIC_PATH_BOUNDS,
    AnchorPoint.CENTER_ANCHOR,
    ResizeMethods.REPLACING_CURRENT_DIMENSIONS_WITH,
    [72, 72]
  );
}

function ri_post_it_object_style(ri) {
  var groups = ri.doc.objectStyleGroups;

  var group = groups.item(AUTOGENERATED_GROUP_NAME);
  if (!group.isValid)
    group = groups.add({name: AUTOGENERATED_GROUP_NAME});

  var styles = group.objectStyles;
  var style = styles.item("(balloon)");
  if (!style.isValid) {
    style = styles.add({
      name: "(balloon)",
      nonprinting: true,

      fillColor: "C=0 M=0 Y=100 K=0",
      fillTint: 20,

      strokeColor: "Black",
      strokeWeight: 0.5,

      bottomLeftCornerOption: CornerOptions.ROUNDED_CORNER,
      bottomRightCornerOption: CornerOptions.ROUNDED_CORNER,
      topLeftCornerOption: CornerOptions.ROUNDED_CORNER,
      topRightCornerOption: CornerOptions.ROUNDED_CORNER,
      bottomLeftCornerRadius: "6pt",
      bottomRightCornerRadius: "6pt",
      topLeftCornerRadius: "6pt",
      topRightCornerRadius: "6pt",

      enableTransformAttributes: true,
    });

    style.setDimensionAttributeState(DimensionAttributes.WIDTH_ATTRIBUTE, true);
  }

  return style;
}

function ri_groom_resize_tables(ri) {
  if (!ri.ui_groom_resize_tables.checkedState)
    return;

  var pages = ri.doc.pages;
  for (var i = pages.length - 1; i >= 0; --i) {
    var frame = ri_main_frame(ri, pages[i]);
    if (frame == null)
      continue;

    var max_width = frame.geometricBounds[3] - frame.geometricBounds[1];
    var tables = frame.tables.everyItem().getElements();
    for (var j = tables.length - 1; j >= 0; --j) {
      var table = tables[j];
      var columns = table.columns;
      var num_columns = columns.length
      var new_width = max_width / num_columns;
      for (var k = 0; k < num_columns; ++k) {
        columns[k].width = new_width;
      }
    }
  }
}

function ri_groom_fully_justify(ri) {
  if (!ri.ui_groom_fully_justify.checkedState)
    return;

  var page = ri.doc.pages[0];
  var frame = ri_main_frame(ri, page);
  var story = frame.parentStory;
  var paragraphs = story.paragraphs;

  var prefs = ri.doc.viewPreferences;
  var oldUnits = prefs.horizontalMeasurementUnits;
  prefs.horizontalMeasurementUnits = MeasurementUnits.pixels;

  ri.num_adjustified = 0;
  ri.num_considered = 0;
  for (var i = 0; i < paragraphs.count(); ++ i)
    ri_fully_justify(ri, paragraphs, i);

  prefs.horizontalMeasurementUnits = oldUnits;

  if (ri.num_considered) {
    ri.messages.push(
      String(ri.num_considered) + ' of ' +
      String(paragraphs.count()) + ' paragraph(s) ' +
      ' considered for justification adjustment.'
    );
  }
  if (ri.num_adjustified) {
    ri.messages.push(String(ri.num_adjustified) + ' changed.');
  }
}

function ri_fully_justify(ri, paragraphs, index) {
  if (index + 1 == paragraphs.count()) {
    // The last paragraph in the text can stay as-is
    return;
  }

  var paragraph = paragraphs[index];

  if (paragraph.contents == "") {
    // Nothing to justify
    return;
  }

  if (paragraph.paragraphDirection != ParagraphDirectionOptions.RIGHT_TO_LEFT_DIRECTION) {
    // We only know about RTL
    return;
  }

  var justification = paragraph.justification;
  if (justification == Justification.FULLY_JUSTIFIED) {
    // Currently fully justified, may be intentional
    var style = paragraph.appliedParagraphStyle;
    if (style && style.justification == Justification.FULLY_JUSTIFIED) {
      // If that's what the user likes...
      return;
    }
  } else if (justification != Justification.RIGHT_JUSTIFIED) {
    // Some kind of fancy centered paragraph.
    return;
  }

  var lines = paragraph.lines;
  var numLines = lines.count()
  var lastLine = lines[-1];
  var lastLineFrame = lastLine.parentTextFrames[0];
  if (lastLineFrame == undefined) {
    // Still in overset limbo.
    return;
  }

  ++ ri.num_considered;

  var followingFrame = paragraphs[index + 1].lines[0].parentTextFrames[0];
  if ((followingFrame != undefined) && (lastLineFrame != followingFrame)) {
    // Last in its frame, no questions asked
    if (justification != Justification.RIGHT_JUSTIFIED) {
      paragraph.justification = Justification.RIGHT_JUSTIFIED;
      ++ ri.num_adjustified;
    }
    return;
  }

  var lastChar = lastLine.characters[-1];
  if (lastChar == '\n') {
    lastChar = lastLine.characters[-2];
  }

  var fully = null;
  var right = null;

  if (lines.count() > 1) {
    ri.last_good_line = lines[-2];
    ri.last_good_char = ri.last_good_line.characters[-1];
  }

  if (justification == Justification.FULLY_JUSTIFIED) {
    // Currently fully justified, we know the margin
    fully = lastChar.endHorizontalOffset;
    paragraph.justification = Justification.RIGHT_JUSTIFIED;
    right = lastChar.endHorizontalOffset;
  } else if (ri.last_good_line != undefined) {
    // We have something to compare with!
    right = lastChar.endHorizontalOffset;
    fully = ri.last_good_char.endHorizontalOffset;

    var last_good_frame = ri.last_good_line.parentTextFrames[0];

    if (last_good_frame != lastLineFrame) {
      fully -= last_good_frame.parentPage.bounds[1];
      fully += lastLineFrame.parentPage.bounds[1];
    }
  } else {
    // Change and compare
    right = lastChar.endHorizontalOffset;
    right = lastChar.endHorizontalOffset;
    paragraph.justification = Justification.FULLY_JUSTIFIED;
    fully = lastChar.endHorizontalOffset;
  }

  var gap = right - fully;
  var fudge = lastChar.pointSize / 2;

  if (gap != 0 && gap < fudge && gap > -fudge) {
    paragraph.justification = Justification.FULLY_JUSTIFIED;
    ri.last_good_line = lastLine;
    ri.last_good_char = lastChar;
  } else {
    paragraph.justification = Justification.RIGHT_JUSTIFIED;
  }

  if (paragraph.justification != justification) {
    ++ ri.num_adjustified;
  }
}

/* NOT CURRENTLY USED */
function ri_really_fully_justify(ri, paragraph) {
  var unfull_style = paragraph.appliedParagraphStyle;

  groups = ri.doc.paragraphStyleGroups;
  var group = groups.itemByName("ReImport");
  if (!group.isValid)
    group = groups.add({name: "ReImport"});

  full_name = unfull_style.name + " (fully justified)"
  var group_styles = group.paragraphStyles;
  var full_style = group_styles.itemByName(full_name);
  if (!full_style.isValid) {
    full_style = group_styles.add({
      name: full_name,
      basedOn: unfull_style,
      justification: Justification.FULLY_JUSTIFIED,
    });
  }
  paragraph.applyParagraphStyle(full_style);
}

function ri_reset_searches(ri) {
  app.findTextPreferences = NothingEnum.nothing;
  app.changeTextPreferences = NothingEnum.nothing;
  app.findGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences = NothingEnum.nothing;
}

function ri_change_text(ri, findWhat, changeTo) {
  app.findTextPreferences.findWhat = findWhat;
  app.changeTextPreferences.changeTo = changeTo;
  ri.doc.changeText();
}

function ri_change_grep(ri, findWhat, changeTo) {
  app.findGrepPreferences.findWhat = findWhat;
  app.changeGrepPreferences.changeTo = changeTo;
  ri.doc.changeGrep();
}

function ri_groom_fix_masters(ri) {
  if (!ri.ui_groom_fix_masters.checkedState)
    return;

  if (!ri.uig_pre.checkedState || !ri.ui_pre_remaster.checkedState)
    ri_reset_all_masters(ri)

  ri_set_b_master(ri, StartParagraph.NEXT_PAGE, false);
  ri_set_b_master(ri, StartParagraph.NEXT_ODD_PAGE, true);
  ri_set_b_master(ri, StartParagraph.NEXT_EVEN_PAGE, true);
  // TODO: NEXT_FRAME, NEXT_COLUMN
}

function ri_set_b_master(ri, start_paragraph, check_prev) {
  app.findTextPreferences = NothingEnum.nothing;
  app.findTextPreferences.startParagraph = start_paragraph;
  var pars = ri.doc.findText();
  for (var i = 0; i < pars.length; ++ i) {
    var page = pars[i].parentTextFrames[0].parentPage;
    var pageIndex = page.documentOffset;
    if (pageIndex == 0) {
      continue;
    }
    ri_set_master(ri, page, ri.b_master);
    if (check_prev) {
      var prev = ri.doc.pages[pageIndex - 1];
      if (ri_page_is_empty(ri, prev)) {
        ri_set_master(ri, prev, ri.b_master);
      }
    }
  }
  app.findTextPreferences = NothingEnum.nothing;
}

function ri_page_is_empty(ri, page) {
  if (page.pageItems.length == 0) {
    return true;
  }
  if (ri_main_frame(ri, page).contents == "") {
    return true;
  }
}

function ri_set_master(ri, page, master) {
  if (ri.ui_groom_keep_masters.checkedState)
    ri_maybe_set_master(ri, page, master);
  else
    ri_do_set_master(ri, page, master);
}

function ri_maybe_set_master(ri, page, master) {
  if (page.appliedMaster.id != master.id)
    ri_do_set_master(ri, page, master);
}

function ri_do_set_master(ri, page, master) {
  page.appliedMaster = master;
}

function ri_groom_update_toc(ri) {
  if (!ri.have_toc)
    return;

  if (!ri.ui_groom_update_toc.checkedState)
    return;

  var style_index = ri.ui_groom_toc_style.selectedIndex;
  var style_name = ri.toc_styles[style_index];
  var style = ri.doc.tocStyles.itemByName(style_name);
  ri.doc.createTOC(style, true);
}

function ri_disable_grep(ri) {
  if (!ri.ui_disable_grep.checkedState)
    return;

  ri_start_subcounter(ri);
  pstyles = ri.doc.allParagraphStyles;
  for (var i = 0; i < pstyles.length; ++ i) {
    pstyle = pstyles[i];
    gstyles = pstyle.nestedGrepStyles;
    for (var j = 0; j < gstyles.length; ++ j) {
      gstyle = gstyles[j];
      if (gstyle.grepExpression[0] != '*')
        gstyle.grepExpression = '*' + gstyle.grepExpression;
    }
  }
  ri_stop_subcounter(ri, "- Disable GREP");
}

function ri_enable_grep(ri) {
  if (!ri.ui_disable_grep.checkedState)
    return;

  ri_start_subcounter(ri);
  pstyles = ri.doc.allParagraphStyles;
  for (var i = 0; i < pstyles.length; ++ i) {
    pstyle = pstyles[i];
    gstyles = pstyle.nestedGrepStyles;
    for (var j = 0; j < gstyles.length; ++ j) {
      gstyle = gstyles[j];
      if (gstyle.grepExpression[0] == '*')
        gstyle.grepExpression = gstyle.grepExpression.substr(1);
    }
  }
  ri_stop_subcounter(ri, "- Enable GREP");
}

function ri_disable_reflow(ri) {
  if (!ri.ui_disable_reflow.checkedState)
    return;

  if (ri.reflow_changed)
    return;

  ri_start_subcounter(ri);
  ri.saved_reflow = ri.doc.textPreferences.smartTextReflow;
  ri.doc.textPreferences.smartTextReflow = false;
  ri.reflow_changed = true;
  ri_stop_subcounter(ri, "- Disable reflow");
}

function ri_restore_reflow(ri) {
  if (!ri.ui_disable_reflow.checkedState)
    return;

  if (!ri.reflow_changed)
    return;

  var saved_preflight = ri.doc.preflightOptions.preflightOff;

  ri.doc.preflightOptions.preflightOff = false; 
  ri.doc.textPreferences.smartTextReflow = ri.saved_reflow;
  ri.doc.activeProcess.waitForProcess(30);
  ri.doc.preflightOptions.preflightOff = saved_preflight;
  ri.reflow_changed = false;
}

function ri_main_frame(ri, page) {
  var frames = page.textFrames;
  if (frames == null)
    return null;
  for (var i = 0; i < frames.length; ++ i) {
    try {
      var frame = frames[i];
      var master = frame.overriddenMasterPageItem;
      if (master.nextTextFrame != null || master.previousTextFrame != null) {
        return frame;
      }
    } catch (e) {
    }
  }
  return frames[0];
}

ri_main();
