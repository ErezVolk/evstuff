// ex: set et sw=2:

// deno-lint-ignore-file no-var no-inner-declarations no-with no-prototype-builtins

/* TODO:
 - Refuse to work if there are unlinked pages
 - (clickable!) QR Codes
 - flag bad orphans (at top of even page, either one word line or one line pre-space; maybe a pre-pause page-bottom too-close-to-aligned)
 - Assign exported classes for hebrew (Paragraph?) style names (based on ARIA roles? based on Word internal names?)
 - Status indication (progress bar, etc.)
 - Pairwise kerning
 - Check for the double frame thing at beginning/end.
 - Border tricks at end/beginning of frames
 - Some kind of "only this" button
 - Configurable (and savable) Title matcher (r'Title|Frame Top')
 - Split (and unsplit!) frames on specific styles
 - Maybe do the start-of-line negative kerning trick?
 - Change "old load" checkbox to radio
 - Offer the precooked searches!
 - Indexing stuff
*/

AUTOGENERATED_GROUP_NAME = "(autogenerated)";
RASTERIZED_FRAME_LABEL = "ri:(rasterized)";
MY_NAME_RE = RegExp("^ri:[(].*[)]$");

function ri_main() {
  ri = {
    doc: app.activeDocument,
    reflow_changed: false,
    messages: [],
    warnings: []
  };
  ri_run(ri);
}

function ri_run(ri) {
  ri_analyze(ri);

  if (!ri_get_options(ri))
    return;

  if (ri.uig_import.checkedState)
    if (!ri_get_importee(ri))
      return;

  ri_start_counter(ri);
  ri_disable_grep(ri);
  ri_disable_reflow(ri);
  ri_find_story(ri);
  if (ri.uig_pre.checkedState) {
    ri_start_subcounter(ri);
    ri_pre_clear(ri);
    ri_stop_subcounter(ri, "Pre-Clear");
    ri_start_subcounter(ri);
    ri_pre_remaster(ri);
    ri_stop_subcounter(ri, "Pre-Master");
  }
  ri_clear_old_epub_stuff(ri);
  if (ri.uig_import.checkedState) {
    ri_start_subcounter(ri);
    ri_do_import(ri);
    ri_do_images(ri);
    ri_stop_subcounter(ri, "Import");
  }
  if (ri.uig_post.checkedState) {
    ri_start_subcounter(ri);
    ri_post_clear_overrides(ri);
    ri_reset_searches(ri);
    ri_post_fix_spaces(ri);
    ri_post_fix_specific_fonts(ri);
    ri_post_fix_dashes(ri);
    ri_post_remove_footnote_whitespace(ri);
    ri_post_convert_newlines(ri);
    ri_post_convert_post_its(ri);
    ri_post_special_styles(ri);
    ri_reset_searches(ri);
    ri_stop_subcounter(ri, "Post-Import");
  }
  ri_enable_grep(ri);
  ri_restore_reflow(ri);
  if (ri.uig_groom.checkedState) {
    ri_start_subcounter(ri);
    ri_groom_fully_justify(ri);
    ri_groom_resize_tables(ri);
    ri_groom_fix_masters(ri);
    ri_groom_special_styles(ri);
    ri_groom_rasterize(ri);
    ri_groom_update_toc(ri);
    ri_stop_subcounter(ri, "Grooming");
  }
  ri_stop_counter(ri);
}

function ri_start_counter(ri) {
  ri.start_ms = new Date().valueOf();
}

function ri_stop_counter(ri) {
  end_ms = new Date().valueOf();
  elapsed = (end_ms - ri.start_ms) / 1000.0;

  if (ri.warnings.length > 0) {
    ri.messages.push("\nWARNINGS:");
    ri.messages = ri.messages.concat(ri.warnings);
  }

  ri.messages.unshift("Done in " + String(elapsed) + " Sec.");
  alert(ri.messages.join('\n'));
}

function ri_start_subcounter(ri) {
  ri.substart_ms = new Date().valueOf();
}

function ri_stop_subcounter(ri, name) {
  end_ms = new Date().valueOf();
  elapsed = (end_ms - ri.substart_ms) / 1000.0;

  ri_log(ri, name + ": took " + String(elapsed) + " Sec.");
}

function ri_log(ri, msg) {
  ri.messages.push(msg);
}

function ri_unlog(ri) {
  ri.messages.pop();
}

function ri_logw(ri, msg) {
  ri.warnings.push(msg);
}

function ri_analyze(ri) {
  var i;
  var vars = ri.doc.textVariables;
  ri.var_settings = null;
  ri.saved_settings = {}

  for (i = 0; i < vars.length; ++ i) {
    var cur = vars[i]
    if (cur.variableType != VariableTypes.CUSTOM_TEXT_TYPE)
      continue;

    var name = cur.name;
    var value = cur.variableOptions.contents;
    if (name == "Imported From") {
      cur.name = "ReImport Settings";
      ri.var_settings = cur;
      ri.saved_settings = {importee: value};
    } else if (name == "ReImport Settings") {
      ri.var_settings = cur;
      try {
        var obj = eval(value);
        if (obj != null) {
           ri.saved_settings = obj;
        }
      } catch (e) {
        ri_logw(ri, 'Could not read settings: ' + e);
      }
    }
  }

  ri.last_importee = ri.saved_settings.importee;

  var stories = ri.doc.stories;
  ri.have_toc = false;
  if (ri.doc.tocStyles.length > 1) {
    ri.toc_styles = ri.doc.tocStyles.everyItem().name;
    ri.toc_styles.shift();
    for (i = 0; i < stories.length && !ri.have_toc; ++ i) {
      ri.have_toc = (stories[i].storyType == StoryTypes.TOC_STORY);
    }
  }
}

function ri_get_options(ri) {
  var dlg = app.dialogs.add({name: "ReImport Options"});
  with (dlg) {
    with (dialogColumns.add()) {
      with (ri.uig_pre = enablingGroups.add({staticLabel: "Pre-Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_pre_remaster =
            checkboxControls.add({
              staticLabel: "Reset all parent pages",
              checkedState: !ri.saved_settings.not_pre_remaster,
            });
          ri.ui_pre_clear =
            checkboxControls.add({
              staticLabel: "Remove all text",
              checkedState: !ri.saved_settings.not_pre_clear,
            });
        }
      }

      with (ri.uig_import = enablingGroups.add({staticLabel: "Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          if (!ri.last_importee) {
            // staticTexts.add({staticLabel: "No previous import."});
          } else if (!File(ri.last_importee).exists) {
            staticTexts.add({staticLabel: "Cannot reload " + ri.last_importee});
          } else {
            ri.ui_same_importee = checkboxControls.add({
              staticLabel: "Reload " + String(ri.last_importee),
              checkedState: true,
            });
          }
          ri.ui_import_rerun = checkboxControls.add({
            staticLabel: "(If Tagged Taged) Try to reconvert",
            checkedState: true,
          });
          ri.ui_import_options = checkboxControls.add({
            staticLabel: "Show import options",
            checkedState: !!ri.saved_settings.show_import_options,
          });
          ri.ui_import_images = checkboxControls.add({
            staticLabel: "Import images",
            checkedState: !ri.saved_settings.dont_import_images,
          });
        }
      }

      with (ri.uig_post = enablingGroups.add({staticLabel: "Post-Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_post_clear_overrides =
            checkboxControls.add({
              staticLabel: "Clear all imported style overrides",
              checkedState: true,
            });
          ri.ui_post_fix_spaces =
            checkboxControls.add({
              staticLabel: "Eliminate multiple spaces",
              checkedState: true,
            });
          ri.ui_post_fix_specific_fonts =
            checkboxControls.add({
              staticLabel: "Fixes for specific Hebrew fonts",
              checkedState: !ri.saved_settings.unfix_specific_fonts,
            });
          ri.ui_post_fix_dashes =
            checkboxControls.add({
              staticLabel: "Fix spacing around dashes",
              checkedState: true,
            });
          ri.ui_post_remove_footnote_whitespace =
            checkboxControls.add({
              staticLabel: "Remove leading whitespace in footnotes",
              checkedState: !ri.saved_settings.unremove_footnote_whitespace,
            });
          ri.ui_post_convert_post_its =
            checkboxControls.add({
              staticLabel: "(If Tagged Text) Convert comments",
              checkedState: !ri.saved_settings.unconvert_post_its,
            });
          ri.ui_post_convert_newlines =
            checkboxControls.add({
              staticLabel: "(If Tagged Text) Convert U+2028 to newline",
              checkedState: !ri.saved_settings.unconvert_newlines,
            });
          ri.ui_post_special_styles =
            checkboxControls.add({
              staticLabel: "Handle special (@) styles",
              checkedState: !!ri.saved_settings.handle_special_styles,
            });
        }
      }

      with (ri.uig_groom = enablingGroups.add({staticLabel: "Grooming", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_groom_resize_tables = checkboxControls.add({
            staticLabel: "Resize tables to frame width",
            checkedState: !ri.saved_settings.dont_shrink_tables,
          });
          ri.ui_groom_fully_justify =
            checkboxControls.add({
              staticLabel: "Fix to full justification",
              checkedState: !ri.saved_settings.unfix_justification,
            });
          ri.ui_groom_fix_masters =
            checkboxControls.add({
              staticLabel: "Fix parent pages",
              checkedState: !ri.saved_settings.unfix_masters,
            });
          ri.ui_groom_keep_masters =
            checkboxControls.add({
              staticLabel: "Keep correct parents",
              checkedState: !ri.saved_settings.unkeep_masters,
            });
          ri.ui_epubbify =
            checkboxControls.add({
              staticLabel: "Prepare for epub (@Rasterize@, etc.)",
              checkedState: !!ri.saved_settings.epubbify,
            });
          if (ri.have_toc) {
            with (dialogRows.add()) {
              ri.ui_groom_update_toc =
                checkboxControls.add({
                  staticLabel: "Update TOC",
                  checkedState: !ri.saved_settings.unupdate_toc,
                });
              ri.ui_groom_toc_style = dropdowns.add({
                stringList: ri.toc_styles,
                selectedIndex: 0
              });
            }
          }
        }
      }

      with (borderPanels.add()) {
        with (dialogColumns.add() ) {
          staticTexts.add({staticLabel: "Body Parent:"});
          staticTexts.add({staticLabel: "Next Page Parent:"});
          staticTexts.add({staticLabel: "Odd/Even Page Parent:"});
          staticTexts.add({staticLabel: "Title Parent:"});
          staticTexts.add({staticLabel: "End Parent:"});
        }
        with (dialogColumns.add()) {
          var masters = ri.doc.masterSpreads.everyItem().name;
          ri.ui_std_master = dropdowns.add({stringList: masters, selectedIndex: 0});
          ri.ui_nwp_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          ri.ui_nop_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          ri.ui_ttl_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          ri.ui_fnl_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          if (ri.saved_settings.std_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.std_master)).isValid)
              ri.ui_std_master.selectedIndex = m.index;
          if (ri.saved_settings.nwp_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.nwp_master)).isValid)
              ri.ui_ttl_master.selectedIndex = ri.ui_fnl_master.selectedIndex = ri.ui_nwp_master.selectedIndex = m.index;
          if (ri.saved_settings.nop_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.nop_master)).isValid)
              ri.ui_ttl_master.selectedIndex = ri.ui_fnl_master.selectedIndex = ri.ui_nop_master.selectedIndex = m.index;
          if (ri.saved_settings.ttl_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.ttl_master)).isValid)
              ri.ui_ttl_master.selectedIndex = ri.ui_fnl_master.selectedIndex = m.index;
          if (ri.saved_settings.fnl_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.fnl_master)).isValid)
              ri.ui_fnl_master.selectedIndex = m.index;
        }
      }

      with (checkboxControls) {
        with (dialogColumns.add()) {
          ri.ui_disable_grep = add({
            staticLabel: "Disable GREP styles while working",
            checkedState: !ri.saved_settings.keep_grep,
          });
          ri.ui_disable_reflow = add({
            staticLabel: "Disable smart reflow when applicable",
            checkedState: !ri.saved_settings.keep_reflow,
          });
        }
      }
    }
  }
  if (!dlg.show()) {
    dlg.destroy();
    return false;
  }

  ri.std_master_name = masters[ri.ui_std_master.selectedIndex];
  ri.std_master = ri.doc.masterSpreads.itemByName(ri.std_master_name);
  ri.nwp_master_name = masters[ri.ui_nwp_master.selectedIndex];
  ri.nwp_master = ri.doc.masterSpreads.itemByName(ri.nwp_master_name);
  ri.nop_master_name = masters[ri.ui_nop_master.selectedIndex];
  ri.nop_master = ri.doc.masterSpreads.itemByName(ri.nop_master_name);
  ri.ttl_master_name = masters[ri.ui_ttl_master.selectedIndex];
  ri.ttl_master = ri.doc.masterSpreads.itemByName(ri.ttl_master_name);
  ri.fnl_master_name = masters[ri.ui_fnl_master.selectedIndex];
  ri.fnl_master = ri.doc.masterSpreads.itemByName(ri.fnl_master_name);
  return true;
}

function ri_get_importee(ri) {
  if (ri.last_importee && ri.ui_same_importee && ri.ui_same_importee.checkedState)
    ri.importee = File(ri.last_importee);
  else
    ri.importee = File.openDialog("Choose your importee", ri.filter_files)
  return ri.importee;
}

function ri_clear_old_epub_stuff(ri) {
  if (!ri.ui_epubbify.checkedState)
    return;

  ri.for_epub = {};

  var i, j;
  var layers = ri.doc.layers;
  var removed = []
  for (i = layers.length - 1; i >= 0; -- i) {
    var layer = layers[i];
    var name = layer.name;
    if (MY_NAME_RE.test(name)) {
      layer.remove();
      removed.push(name);
    }
  }
  if (removed.length > 0) {
    ri_log(ri, "Removed old layers: " + removed.join(" "));
  }

  var pages = ri.doc.pages;
  var count = 0;
  for (i = pages.length - 1; i >= 0; -- i) {
    var frames = pages[i].textFrames;
    for (j = frames.length - 1; j >= 0; -- j) {
      var frame = frames[j];
      if (MY_NAME_RE.test(frame.label)) {
        frame.remove();
        count ++;
      }
    }
  }
  if (count > 0) {
    ri_log(ri, "Removed " + count + " old frame(s).");
  }

  var groups = ri.doc.characterStyleGroups;
  var group = groups.item(AUTOGENERATED_GROUP_NAME);
  if (!group.isValid)
    group = groups.add({name: AUTOGENERATED_GROUP_NAME});

  var styles = group.characterStyles;
  var style = styles.item("(non_epub)");
  if (!style.isValid)
    style = styles.add({name: "(non_epub)"});
  ri.for_epub.cstyle_invisible = style;
}

function ri_get_epub_layer(ri, name) {
  var layers = ri.doc.layers;
  var full_name = "ri:(" + name + ")";
  var layer = layers.itemByName(full_name);
  if (layer && layer.isValid)
    return layer;
  return ri.doc.layers.add({name: full_name});
}

function ri_pre_remaster(ri) {
  if (!ri.ui_pre_remaster.checkedState)
    return;
  ri_reset_all_masters(ri);
}

function ri_reset_all_masters(ri) {
  var pages = ri.doc.pages;
  ri_maybe_set_master(ri, pages[0], ri.ttl_master);
  for (var i = 1; i < pages.length; ++ i)
    ri_maybe_set_master(ri, pages[i], ri.std_master);
}

function ri_find_story(ri) {
  var pages = ri.doc.pages;
  for (var i = 0; i < pages.length; ++ i) {
    var page = pages[i];
    var frame = ri_main_frame(ri, page)
    var story = frame.parentStory;
    if (story.isValid) {
      ri.story = story;
      return;
    }
  }
  ri_logw("NO PARENT STORY FOUND");
}

function ri_pre_clear(ri) {
  if (!ri.ui_pre_clear.checkedState)
    return;
  try {
    ri.story.contents = "";
  } catch (_e) {
    // What can you do.
  }
  //ri_override_all_master_page_items(ri, page);
}

/*
function ri_override_all_master_page_items(ri, page) {
  for (var i = 0; i < page.masterPageItems.length; ++ i) {
    mpi = page.masterPageItems[i];
    try {
      if (mpi.allowOverrides) {
        mpi.override(page);
      }
    } catch (e) {
    }
  }
}
*/

function ri_do_import(ri) {
  if (ri.ui_import_rerun.checkedState) {
    try {
      rerunner = ri.importee + '.rerun';
      mtime = File(rerunner).modified;
      if (mtime) {
        cmd = 'do shell script "' + rerunner + '"';
        ri_log(ri, cmd);
        app.doScript(cmd, ScriptLanguage.APPLESCRIPT_LANGUAGE);
        for (var n = 0; n < 50 && File(rerunner).modified.getTime() == mtime.getTime(); ++ n)
          $.sleep(100);
      }
      ri_unlog(ri);
    } catch (e) {
      ri_logw(ri, 'Could not rerun: ' + e);
      throw("Hey");
    }
  }

  var where = ri.story.insertionPoints[0];
  try {
    where.place(ri.importee, ri.ui_import_options.checkedState);
  } catch (e) {
    ri_logw(ri, "Could not import " + ri.importee + " to " + where.toSource() + ": " + e);
  }

  if (!ri.var_settings)
    ri.var_settings = ri.doc.textVariables.add({
      name: "ReImport Settings",
      variableType: VariableTypes.CUSTOM_TEXT_TYPE
    });

  obj = {importee: ri.importee.fsName};

  obj["std_master"] = ri.std_master_name;
  obj["nwp_master"] = ri.nwp_master_name;
  obj["nop_master"] = ri.nop_master_name;
  obj["ttl_master"] = ri.ttl_master_name;
  obj["fnl_master"] = ri.fnl_master_name;

  obj["dont_import_images"] = !ri.ui_import_images.checkedState;
  obj["dont_shrink_tables"] = !ri.ui_groom_resize_tables.checkedState;
  obj["handle_special_styles"] = ri.ui_post_special_styles.checkedState;
  obj["show_import_options"] = ri.ui_import_options.checkedState;
  obj["keep_grep"] = !ri.ui_disable_grep.checkedState;
  obj["keep_reflow"] = !ri.ui_disable_reflow.checkedState;
  obj["not_pre_clear"] = !ri.ui_pre_clear.checkedState;
  obj["not_pre_remaster"] = !ri.ui_pre_remaster.checkedState;
  obj["epubbify"] = ri.ui_epubbify.checkedState;
  obj["unconvert_newlines"] = !ri.ui_post_convert_newlines.checkedState;
  obj["unconvert_post_its"] = !ri.ui_post_convert_post_its.checkedState;
  obj["unfix_justification"] = !ri.ui_groom_fully_justify.checkedState;
  obj["unfix_masters"] = !ri.ui_groom_fix_masters.checkedState;
  obj["unfix_specific_fonts"] = !ri.ui_post_fix_specific_fonts.checkedState;
  obj["unkeep_masters"] = !ri.ui_groom_keep_masters.checkedState;
  obj["unremove_footnote_whitespace"] = !ri.ui_post_remove_footnote_whitespace;
  if (ri.have_toc) {
    obj["unupdate_toc"] = !ri.ui_groom_update_toc.checkedState;
  }
  ri.var_settings.variableOptions.contents = uneval(obj);
}

function ri_do_images(ri) {
  var i;

  if (!ri.ui_import_images.checkedState)
    return;

  try {
    var image_ref_style = ri.doc
      .characterStyleGroups.item(AUTOGENERATED_GROUP_NAME)
      .characterStyles.item("(Image)");
    if (!image_ref_style.isValid)
      return;
  } catch (_e) {
    return;
  }

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "\\S+";
  app.findGrepPreferences.appliedCharacterStyle = image_ref_style;

  var refs = ri.story.findGrep();
  for (i = 0; i < refs.length; ++ i) {
    var ref = refs[i];
    var path = File(ri.doc.filePath + "/" + ref.contents);
    ref.select();
    try {
      ri.doc.place(path);
    } catch(e) {
      ri_logw(ri, 'Could not import image ' + path + ': ' + e);
    }
  }

  app.findGrepPreferences = NothingEnum.nothing;

  var links = ri.doc.links;
  for (i = 0; i < links.length; ++ i) {
    links[i].unlink();
  }
}

function ri_post_clear_overrides(ri) {
  if (!ri.ui_post_clear_overrides.checkedState)
    return;
  ri.doc.stories.everyItem().clearOverrides();
  try {
    ri.doc.stories.everyItem().footnotes.everyItem().texts.everyItem().clearOverrides();
  }
  catch (_e) {
    // So don't
  }
}

function ri_post_fix_spaces(ri) {
  if (!ri.ui_post_fix_spaces.checkedState)
    return;

  // Multiple Space to Single Space (ships with InDesign)
  //ri_change_grep(ri, "[~m~>~f~|~S~s~<~/~.~3~4~% ]{2,}", " ");

  // Multiple Return to Single Return (ships with InDesign)
  //ri_change_grep(ri, "~b~b+", "\\r");

  // Only care about space-space, and combine the two searches
  ri_change_grep(ri, "([ ~b])\\1+", "$1");
}

function ri_post_fix_dashes(ri) {
  if (!ri.ui_post_fix_dashes.checkedState)
    return;

  ri_change_grep(ri, "[~m~>~f~|~s~<~/~.~3~4~% ~k]+([-+~=~_/]+)", "~S$1");
  ri_change_grep(ri, "([-+~=~_/]+)[~m~>~f~|~S~s~<~/~.~3~4~% ~k]+", "$1 ");
}

function ri_post_fix_specific_fonts(ri) {
  if (!ri.ui_post_fix_specific_fonts.checkedState)
    return;

  // VAV WITH HOLAM in Hadassah Friedlaender
  ri_fix_vav_in_font(ri, "Hadassah Friedlaender");
  ri_change_grep(ri, "([^~m~>~f~|~S~s~<~/~.~3~4~% ~k])(\\x{FB4B})", "$1~j$2");
  ri_change_grep(ri, "(\\x{FB4B})([^~m~>~f~|~S~s~<~/~.~3~4~% ~k])", "$1~j$2");

  // Em-dash in MF_FrankRuhl (but Hebrew kav mafrid is officialy en-dash :(
  // ri_en_to_em_dash_in_font(ri, "MF_FrankRuhl")
}

function ri_fix_vav_in_font(ri, fontname) {
  app.findGrepPreferences.appliedFont = fontname;
  ri_change_grep(ri, "\\x{05D5}\\x{05B9}", "\\x{FB4B}");
  ri_change_grep(ri, "[~m~>~f~|~S~s~<~/~.~3~4~% ~k]+([-+~=/]+)", "~S$1");
  app.findGrepPreferences = NothingEnum.nothing;
}

/* NOT USED
function ri_en_to_em_dash_in_font(ri, fontname) {
  app.findGrepPreferences.appliedFont = fontname;
  ri_change_grep(ri, "(?<!\S)~=", "~_");
  ri_change_grep(ri, "~=(?!\S)", "~_");
  app.findGrepPreferences = NothingEnum.nothing;
}
*/

function ri_post_remove_footnote_whitespace(ri) {
  if (!ri.ui_post_remove_footnote_whitespace.checkedState)
    return;

  app.findGrepPreferences.findWhat = "(?<=^~F\\t) +";
  app.changeGrepPreferences.changeTo = "";
  try {
    ri.doc.stories.everyItem()
      .footnotes.everyItem()
      .texts.everyItem()
      .changeGrep();
  } catch (_e) {
    // Oh well
  }
}

function ri_post_convert_newlines(ri) {
  if (!ri.ui_post_convert_newlines.checkedState)
    return;

  ri_change_grep(ri, "\\x{2028}", "\\n")
}

function ri_post_convert_post_its(ri) {
  if (!ri.ui_post_convert_post_its.checkedState)
    return;

  try {
    var ugly_ref_style = ri.doc
      .characterStyleGroups.item(AUTOGENERATED_GROUP_NAME)
      .characterStyles.item("(Comment Reference)");
  } catch (_e) {
    return;
  }

  if (!ugly_ref_style.isValid)
    return;

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "~F";
  app.findGrepPreferences.appliedCharacterStyle = ugly_ref_style;

  var ugly_refs = app.findGrep();
  for (var i = ugly_refs.length - 1; i >= 0; -- i) {
    var ugly_ref = ugly_refs[i].footnotes[0];
    if (!ugly_ref.isValid)
      continue;

    var nice_frame = ri.doc.textFrames.add();

    var ugly_paragraphs = ugly_ref.paragraphs;
    for (var j = 0; j < ugly_paragraphs.length; ++ j) {
      var ugly_paragraph = ugly_paragraphs[j];
      var nice_paragraph = ugly_paragraph.duplicate(LocationOptions.AT_END, nice_frame);

      nice_characters = nice_paragraph.characters;
      if (nice_characters[0].contents == SpecialCharacters.FOOTNOTE_SYMBOL) {
        nice_characters.itemByRange(0, 1).remove();
      }
    }

    nice_frame.anchoredObjectSettings
      .insertAnchoredObject(ugly_ref.storyOffset, AnchorPosition.ANCHORED);

    ri_fix_post_it(ri, nice_frame);
  }

  // Get rid of the ugly footnotes
  ri.doc.changeGrep();

  // Get rid of the ugly style
  ugly_ref_style.remove();
}

function ri_fix_post_it(ri, frame) {
  frame.applyObjectStyle(ri_post_it_object_style(ri));

  var prefs = frame.textFramePreferences;
  prefs.insetSpacing = 2;
  prefs.autoSizingType = AutoSizingTypeEnum.HEIGHT_ONLY;

  var baseline = frame.baselineFrameGridOptions;
  baseline.useCustomBaselineFrameGrid = true;
  baseline.baselineFrameGridRelativeOption = BaselineFrameGridRelativeOption.TOP_OF_FRAME;
  baseline.startingOffsetForBaselineFrameGrid = 0;
  baseline.baselineFrameGridIncrement = "9pt";

  var anchoring = frame.anchoredObjectSettings;
  anchoring.spineRelative = true;
  anchoring.anchorPoint = AnchorPoint.TOP_RIGHT_ANCHOR;
  anchoring.anchoredPosition = AnchorPosition.ANCHORED;
  anchoring.horizontalAlignment = HorizontalAlignment.LEFT_ALIGN;
  anchoring.horizontalReferencePoint = AnchoredRelativeTo.TEXT_FRAME;
  anchoring.anchorXoffset = "6pt";
  anchoring.verticalAlignment = VerticalAlignment.TOP_ALIGN;
  anchoring.verticalReferencePoint = VerticallyRelativeTo.TOP_OF_LEADING;
  anchoring.anchorYoffset = "0pt";

  var drop = frame.transparencySettings.dropShadowSettings;
  drop.mode = ShadowMode.DROP;
  drop.opacity = 50;
  drop.distance = "6pt";

  frame.resize(
    BoundingBoxLimits.GEOMETRIC_PATH_BOUNDS,
    AnchorPoint.CENTER_ANCHOR,
    ResizeMethods.REPLACING_CURRENT_DIMENSIONS_WITH,
    [72, 72]
  );
}

function ri_post_it_object_style(ri) {
  var groups = ri.doc.objectStyleGroups;

  var group = groups.item(AUTOGENERATED_GROUP_NAME);
  if (!group.isValid)
    group = groups.add({name: AUTOGENERATED_GROUP_NAME});

  var styles = group.objectStyles;
  var style = styles.item("(balloon)");
  if (!style.isValid) {
    style = styles.add({
      name: "(balloon)",
      nonprinting: true,

      fillColor: "C=0 M=0 Y=100 K=0",
      fillTint: 20,

      strokeColor: "Black",
      strokeWeight: 0.5,

      bottomLeftCornerOption: CornerOptions.ROUNDED_CORNER,
      bottomRightCornerOption: CornerOptions.ROUNDED_CORNER,
      topLeftCornerOption: CornerOptions.ROUNDED_CORNER,
      topRightCornerOption: CornerOptions.ROUNDED_CORNER,
      bottomLeftCornerRadius: "6pt",
      bottomRightCornerRadius: "6pt",
      topLeftCornerRadius: "6pt",
      topRightCornerRadius: "6pt",

      enableTransformAttributes: true,
    });

    style.setDimensionAttributeState(DimensionAttributes.WIDTH_ATTRIBUTE, true);
  }

  return style;
}

function ri_groom_resize_tables(ri) {
  if (!ri.ui_groom_resize_tables.checkedState)
    return;

  var pages = ri.doc.pages;
  for (var i = pages.length - 1; i >= 0; --i) {
    var frame = ri_main_frame(ri, pages[i]);
    if (frame == null)
      continue;

    var max_width = frame.geometricBounds[3] - frame.geometricBounds[1];
    var tables = frame.tables.everyItem().getElements();
    for (var j = tables.length - 1; j >= 0; --j) {
      var table = tables[j];
      var columns = table.columns;
      var num_columns = columns.length
      var new_width = max_width / num_columns;
      for (var k = 0; k < num_columns; ++k) {
        columns[k].width = new_width;
      }
    }
  }
}

function ri_groom_fully_justify(ri) {
  if (!ri.ui_groom_fully_justify.checkedState)
    return;

  var page = ri.doc.pages[0];
  var frame = ri_main_frame(ri, page);
  var story = frame.parentStory;
  var paragraphs = story.paragraphs;

  var prefs = ri.doc.viewPreferences;
  var oldUnits = prefs.horizontalMeasurementUnits;
  prefs.horizontalMeasurementUnits = MeasurementUnits.pixels;

  ri.num_adjustified = 0;
  ri.num_considered = 0;
  for (var i = 0; i < paragraphs.count(); ++ i)
    ri_fully_justify(ri, paragraphs, i);

  prefs.horizontalMeasurementUnits = oldUnits;

  if (ri.num_considered) {
    ri_log(ri, 
      String(ri.num_considered) + ' of ' +
      String(paragraphs.count()) + ' paragraph(s) ' +
      ' considered for justification adjustment.'
    );
  }
  if (ri.num_adjustified) {
    ri_log(ri, String(ri.num_adjustified) + ' changed.');
  }
}

function ri_fully_justify(ri, paragraphs, index) {
  if (index + 1 == paragraphs.count()) {
    // The last paragraph in the text can stay as-is
    return;
  }

  var paragraph = paragraphs[index];

  if (paragraph.contents == "") {
    // Nothing to justify
    return;
  }

  if (paragraph.paragraphDirection != ParagraphDirectionOptions.RIGHT_TO_LEFT_DIRECTION) {
    // We only know about RTL
    return;
  }

  var justification = paragraph.justification;
  if (justification == Justification.FULLY_JUSTIFIED) {
    // Currently fully justified, may be intentional
    var style = paragraph.appliedParagraphStyle;
    if (style && style.justification == Justification.FULLY_JUSTIFIED) {
      // If that's what the user likes...
      return;
    }
  } else if (justification != Justification.RIGHT_JUSTIFIED) {
    // Some kind of fancy centered paragraph.
    return;
  }

  var lines = paragraph.lines;
  var lastLine = lines[-1];
  var lastLineFrame = lastLine.parentTextFrames[0];
  if (lastLineFrame == undefined) {
    // Still in overset limbo.
    return;
  }

  ++ ri.num_considered;

  var followingFrame = paragraphs[index + 1].lines[0].parentTextFrames[0];
  if ((followingFrame != undefined) && (lastLineFrame != followingFrame)) {
    // Last in its frame, no questions asked
    if (justification != Justification.RIGHT_JUSTIFIED) {
      paragraph.justification = Justification.RIGHT_JUSTIFIED;
      ++ ri.num_adjustified;
    }
    return;
  }

  var lastChar = lastLine.characters[-1];
  if (lastChar == '\n') {
    lastChar = lastLine.characters[-2];
  }

  var fully = null;
  var right = null;

  if (lines.count() > 1) {
    ri.last_good_line = lines[-2];
    ri.last_good_char = ri.last_good_line.characters[-1];
  }

  if (justification == Justification.FULLY_JUSTIFIED) {
    // Currently fully justified, we know the margin
    fully = lastChar.endHorizontalOffset;
    paragraph.justification = Justification.RIGHT_JUSTIFIED;
    right = lastChar.endHorizontalOffset;
  } else if (ri.last_good_line != undefined) {
    // We have something to compare with!
    right = lastChar.endHorizontalOffset;
    fully = ri.last_good_char.endHorizontalOffset;

    var last_good_frame = ri.last_good_line.parentTextFrames[0];

    if (last_good_frame != lastLineFrame) {
      fully -= last_good_frame.parentPage.bounds[1];
      fully += lastLineFrame.parentPage.bounds[1];
    }
  } else {
    // Change and compare
    right = lastChar.endHorizontalOffset;
    right = lastChar.endHorizontalOffset;
    paragraph.justification = Justification.FULLY_JUSTIFIED;
    fully = lastChar.endHorizontalOffset;
  }

  var gap = right - fully;
  var fudge = lastChar.pointSize / 2;

  if (gap != 0 && gap < fudge && gap > -fudge) {
    paragraph.justification = Justification.FULLY_JUSTIFIED;
    ri.last_good_line = lastLine;
    ri.last_good_char = lastChar;
  } else {
    paragraph.justification = Justification.RIGHT_JUSTIFIED;
  }

  if (paragraph.justification != justification) {
    ++ ri.num_adjustified;
  }
}

/* NOT CURRENTLY USED
function ri_really_fully_justify(ri, paragraph) {
  var unfull_style = paragraph.appliedParagraphStyle;

  groups = ri.doc.paragraphStyleGroups;
  var group = groups.itemByName("ReImport");
  if (!group.isValid)
    group = groups.add({name: "ReImport"});

  full_name = unfull_style.name + " (fully justified)"
  var group_styles = group.paragraphStyles;
  var full_style = group_styles.itemByName(full_name);
  if (!full_style.isValid) {
    full_style = group_styles.add({
      name: full_name,
      basedOn: unfull_style,
      justification: Justification.FULLY_JUSTIFIED,
    });
  }
  paragraph.applyParagraphStyle(full_style);
}
*/

function ri_reset_searches(_ri) {
  app.findTextPreferences = NothingEnum.nothing;
  app.changeTextPreferences = NothingEnum.nothing;
  app.findGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences = NothingEnum.nothing;
}

/*
function ri_change_text(ri, findWhat, changeTo) {
  app.findTextPreferences.findWhat = findWhat;
  app.changeTextPreferences.changeTo = changeTo;
  ri.doc.changeText();
}
*/

function ri_change_grep(ri, findWhat, changeTo) {
  app.findGrepPreferences.findWhat = findWhat;
  app.changeGrepPreferences.changeTo = changeTo;
  ri.doc.changeGrep();
}

function ri_groom_fix_masters(ri) {
  if (!ri.ui_groom_fix_masters.checkedState)
    return;

  if (!ri.uig_pre.checkedState || !ri.ui_pre_remaster.checkedState)
    ri_reset_all_masters(ri)

  var count = 0;
  count += ri_set_keep_master(ri, StartParagraph.NEXT_PAGE, ri.nwp_master, false);
  count += ri_set_keep_master(ri, StartParagraph.NEXT_ODD_PAGE, ri.nop_master, true);
  count += ri_set_keep_master(ri, StartParagraph.NEXT_EVEN_PAGE, ri.nop_master, true);
  count += ri_set_final_master(ri);

  // TODO: NEXT_FRAME, NEXT_COLUMN
  if (count > 0) {
    ri_log(ri, "Set " + count + " B master(s).");
  }
}

function ri_set_keep_master(ri, start_paragraph, master, check_prev) {
  app.findTextPreferences = NothingEnum.nothing;
  app.findTextPreferences.startParagraph = start_paragraph;
  var pars = ri.doc.findText();
  var count = 0;
  for (var i = 0; i < pars.length; ++ i) {
    var par = pars[i];
    try {
      var page = par.parentTextFrames[0].parentPage;
      var pageIndex = page.documentOffset;
    } catch(err) {
      ri_logw(ri, "Cannot get page object, check Smart Text Reflow for \"" + par.contents + "\": " + err);
      continue;
    }
    if (pageIndex == 0) {
      continue;
    }
    ri_set_master(ri, page, master);
    count += 1;
    if (check_prev) {
      var prev = ri.doc.pages[pageIndex - 1];
      if (ri_page_is_empty(ri, prev)) {
        ri_set_master(ri, prev, master);
        count += 1;
      }
    }
  }
  app.findTextPreferences = NothingEnum.nothing;
  return count;
}

function ri_set_final_master(ri) {
  var i, page, count = 0;
  for (i = ri.doc.pages.length - 1; i > 0; -- i) {
      page = ri.doc.pages[i];
      if (!ri_page_is_empty(ri, page)) {
        break;
      } else {
        ri_set_master(ri, page, ri.fnl_master);
        count += 1;
      }
  }
  return count;
}

function ri_page_is_empty(ri, page) {
  if (page.pageItems.length == 0) {
    return true;
  }
  if (ri_main_frame(ri, page).contents == "") {
    return true;
  }
}

function ri_set_master(ri, page, master) {
  if (ri.ui_groom_keep_masters.checkedState)
    ri_maybe_set_master(ri, page, master);
  else
    ri_do_set_master(ri, page, master);
}

function ri_maybe_set_master(ri, page, master) {
  if (page.appliedMaster.id != master.id)
    ri_do_set_master(ri, page, master);
}

function ri_do_set_master(_ri, page, master) {
  page.appliedMaster = master;
}

function ri_groom_update_toc(ri) {
  if (!ri.have_toc)
    return;

  if (!ri.ui_groom_update_toc.checkedState)
    return;

  var style_index = ri.ui_groom_toc_style.selectedIndex;
  var style_name = ri.toc_styles[style_index];
  var style = ri.doc.tocStyles.itemByName(style_name);
  ri.doc.createTOC(style, true);
}

function ri_disable_grep(ri) {
  if (!ri.ui_disable_grep.checkedState)
    return;

  ri_start_subcounter(ri);
  pstyles = ri.doc.allParagraphStyles;
  for (var i = 0; i < pstyles.length; ++ i) {
    pstyle = pstyles[i];
    gstyles = pstyle.nestedGrepStyles;
    for (var j = 0; j < gstyles.length; ++ j) {
      gstyle = gstyles[j];
      if (gstyle.grepExpression[0] != '*')
        gstyle.grepExpression = '*' + gstyle.grepExpression;
    }
  }
  ri_stop_subcounter(ri, "Disable GREP");
}

function ri_enable_grep(ri) {
  if (!ri.ui_disable_grep.checkedState)
    return;

  ri_start_subcounter(ri);
  pstyles = ri.doc.allParagraphStyles;
  for (var i = 0; i < pstyles.length; ++ i) {
    pstyle = pstyles[i];
    gstyles = pstyle.nestedGrepStyles;
    for (var j = 0; j < gstyles.length; ++ j) {
      gstyle = gstyles[j];
      if (gstyle.grepExpression[0] == '*')
        gstyle.grepExpression = gstyle.grepExpression.substr(1);
    }
  }
  ri_stop_subcounter(ri, "Enable GREP");
}

function ri_disable_reflow(ri) {
  if (!ri.ui_disable_reflow.checkedState)
    return;

  if (ri.reflow_changed)
    return;

  ri_start_subcounter(ri);
  ri.saved_reflow = ri.doc.textPreferences.smartTextReflow;
  ri.doc.textPreferences.smartTextReflow = false;
  ri.reflow_changed = true;
  ri_stop_subcounter(ri, "Disable reflow");
}

function ri_restore_reflow(ri) {
  if (!ri.ui_disable_reflow.checkedState)
    return;

  if (!ri.reflow_changed)
    return;

  var saved_preflight = ri.doc.preflightOptions.preflightOff;

  ri.doc.preflightOptions.preflightOff = false; 
  ri.doc.textPreferences.smartTextReflow = ri.saved_reflow;
  ri.doc.activeProcess.waitForProcess(30);
  ri.doc.preflightOptions.preflightOff = saved_preflight;
  ri.reflow_changed = false;
}

function ri_main_frame(_ri, page) {
  var frames = page.textFrames;
  if (frames == null)
    return null;

  for (var i = 0; i < frames.length; ++ i) {
    try {
      var frame = frames[i];
      var story = frame.parentStory;
      if (!story || !story.isValid)
        continue;
      var layer = frame.itemLayer;
      if (!layer || !layer.isValid)
        continue;
      if (MY_NAME_RE.test(layer.name))
        continue;
      if (frame.nextTextFrame != null || frame.previousTextFrame != null)
        return frame;
    } catch (_e) {
      // Oh well
    }
  }
  return frames[0];
}

function ri_post_special_styles(ri) {
  if (!ri.ui_post_special_styles.checkedState)
    return;

  riss_do_destinations(ri);
  riss_do_sources(ri);

  riss_do_mirrors(ri);

  riss_do_continuations(ri);
}

function ri_groom_special_styles(ri) {
  if (!ri.ui_post_special_styles.checkedState)
    return;

  riss_do_valigns(ri);
  riss_do_sections(ri);
  riss_do_masters(ri);
}

function riss_do_destinations(ri) {
  ri.destinations = {};
  riss_remove_destinations(ri);
  riss_create_destinations(ri);
}

function riss_remove_destinations(ri) {
  var removed = 0;
  var destinations = ri.doc.hyperlinkTextDestinations;
  for (var i = destinations.length - 1; i >= 0; -- i) {
    var destination = destinations[i];
    if (destination.label == "cxr") {
      destination.remove()
      removed = removed + 1;
    }
  }
  if (removed > 0)
    ri_log(ri, "Removed " + removed + " destination(s)");
}

function riss_create_destinations(ri) {
  var added = 0;

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = ".+"; // i.e., no newlines
  var hits = ri_get_all_texts_with_styles_containing(ri, "@Destination@");
  app.findGrepPreferences = NothingEnum.nothing;

  for (var i = 0; i < hits.length; ++ i) {
    var text = hits[i];
    var name = normalize_name(text.contents);
    if (ri.destinations.hasOwnProperty(name)) {
      ri_log(ri, "Ignoring duplicate: \"" + name + "\" is " + ri.destinations[name].toSource());
    } else {
      ri_log(ri, "Creating destination \"" + name + "\"");
      ri.destinations[name] = ri.doc.hyperlinkTextDestinations.add(text, {label: "cxr"})
      ri_unlog(ri);
      added = added + 1;
    }
  }

  if (added > 0)
    ri_log(ri, "Added " + added + " destination(s)");
}

function normalize_name(name) {
  return name.replace(RegExp("\u200c*\uFB4B\u200c*", "g"), "\u05D5\u05B9");
}

function riss_do_sources(ri) {
  riss_undo_sources(ri);
  riss_redo_sources(ri);
}

function riss_undo_sources(ri) {
  var sources = ri.doc.crossReferenceSources;
  var removed = 0;
  for (var i = sources.length - 1; i >= 0; -- i) {
    var source = sources[i];
    if (source.label.substr(0, 4) == "cxr:") {
      source.sourceText.contents = source.label.substr(4);
      source.remove();
      removed = removed + 1;
    }
  }
  if (removed > 0)
    ri_log(ri, "Undid " + removed + " source(s)");
}

function riss_redo_sources(ri) {
  ri.source_style = ri.doc.crossReferenceFormats.itemByName("Bare Page Number");
  if (!ri.source_style.isValid) {
    ri.source_style = ri.doc.crossReferenceFormats.add("Bare Page Number");
    ri.source_style.buildingBlocks.add(BuildingBlockTypes.PAGE_NUMBER_BUILDING_BLOCK);
  }

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = ".+"; // i.e., no newlines
  hits = ri_get_all_texts_with_styles_containing(ri, "@Source@");
  app.findGrepPreferences = NothingEnum.nothing;

  var added = 0;
  for (var i = 0; i < hits.length; ++ i) {
    var text = hits[i];
    var contents = text.contents;
    if (contents[0] != "=" && contents[0] != "@") {
      ri_log(ri, "Ignoring malformed source: \"" + contents + "\"");
      continue;
    }

    var name = normalize_name(contents.substring(1));
    if (!ri.destinations.hasOwnProperty(name)) {
      ri_log(ri, "Ignoring unknown destination: \"" + name + "\"");
      continue;
    }

    ri_log(ri, "Creating source \"" + name + "\"");
    source = ri.doc.crossReferenceSources.add(text, ri.source_style, {label: "cxr:" + contents})
    ri.doc.hyperlinks.add(source, ri.destinations[name], {label: "cxr"});
    ri_unlog(ri);
    added = added + 1;
  }
  if (added > 0)
    ri_log(ri, "Added " + added + " source(s)");
}

function riss_do_mirrors(ri) {
  var count = 0;

  app.findTextPreferences = NothingEnum.nothing;
  hits = ri_get_all_texts_with_styles_containing(ri, "@Reversed@");
  app.findTextPreferences = NothingEnum.nothing;

  if (hits.length == 0)
    return;

  var outlines, layer, epubbify = ri.ui_epubbify.checkedState;

  if (epubbify)
    layer = ri_get_epub_layer(ri, "non_epub");

  for (var i = 0; i < hits.length; ++ i) {
    var hit = hits[i];
    try {
      if (epubbify) {
        outlines = hit.createOutlines(false);
        hit.fillColor = "None";
      } else {
        outlines = hit.createOutlines();
      }

      for (var j = 0; j < outlines.length; ++ j) {
        var outline = outlines[j];
        outline.flipItem(Flip.HORIZONTAL);

        if (epubbify) {
          outline.itemLayer = layer;
          outline.contentType = ContentType.TEXT_TYPE; // Creates a text frame
          var new_frame = outline.itemLayer.textFrames.lastItem(); // TODO: Is this dependable?
          new_frame.name = "flipped(" + hit.contents + ")";
          new_frame.texts[0].appliedCharacterStyle = ri.for_epub.cstyle_invisible;
        }
      }
      count ++;
    } catch(err) {
      ri_logw(ri, "Couldn't flip " + hit.constructor.name + " \"" + hit.contents + "\": " + err);
    }
  }

  if (count > 0) {
    ri_log(ri, "Flipped " + count + " outline(s).");
    if (epubbify)
      ri_logw(ri,
        "When exporting to epub, either hide the layer \"" + layer.name + "\" " +
        "or make the style \"" + ri.for_epub.cstyle_invisible.name + "\" invisible in CSS.");
  }
}

function riss_do_continuations(ri) {
  var count = 0;

  paras = ri_get_all_paras_with_styles_containing(ri, "@Continuation@");

  if (paras.length == 0)
    return;

  // Now fix them
  var prefs = ri.doc.viewPreferences;
  var oldUnits = prefs.horizontalMeasurementUnits;
  prefs.horizontalMeasurementUnits = MeasurementUnits.points;

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "^\\s*";
  app.changeGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences.changeTo = "";

  for (var i = 0; i < paras.length; ++ i) {
    var currPara = paras[i];
    var prevChar = currPara.parent.characters.item(currPara.index - 2);

    currPara.changeGrep();

    currPara.firstLineIndent = 0;
    try {
      var oldOffset = currPara.horizontalOffset;
      var refOffset = prevChar.endHorizontalOffset;
      var newIndent = Math.abs(refOffset - oldOffset);
      currPara.firstLineIndent = newIndent;
      count += 1;
    } catch(err) {
      ri_logw(
        ri, "Error in line " + err.line + " fixing \"" + currPara.contents + "\" with style \"" + currPara.appliedParagraphStyle.name + "\":" + err.description
      );
      currPara.clearOverrides();
    }
  }

  app.findGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences = NothingEnum.nothing;

  prefs.horizontalMeasurementUnits = oldUnits;

  if (count > 0) {
    ri_log(ri, "Fixed " + count + " continuation paragraph(s).");
  }
}

function riss_do_valigns(ri) {
  var count = 0;
  count += riss_do_valign(ri, "@VBottom@", VerticalJustification.BOTTOM_ALIGN);
  count += riss_do_valign(ri, "@VCenter@", VerticalJustification.CENTER_ALIGN);
  if (count > 0) {
    ri_log(ri, "Vertically aligned " + count + " text frame(s).");
  }
}

function riss_do_valign(ri, substr, justification) {
  var count = 0;

  frames = ri_get_all_frames_with_para_styles_containins(ri, substr);

  for (var j = 0; j < frames.length; ++ j) {
    var frame = frames[j];
    try {
      var prefs = frame.textFramePreferences;
      prefs.verticalJustification = justification;
    } catch (err) {
      ri_logw(ri, "Cannot set paragraph \"" + para.contents + "\+ with style \"" + para.appliedParagraphStyle.name + "\" in frame " + frame + " to " + justification + ": " + err);
    }
    count ++;
  }

  return count;
}

function riss_do_sections(ri) {
  var count = 0;

  frames = ri_get_all_frames_with_para_styles_containins(ri, "@Section@");

  if (frames.length == 0) {
    return 0;
  }

  try {
    ri.doc.sections.itemsByRange(1, -1).remove();
  } catch(_e) {
    // Ignore
  }
  for (var j = 0; j < frames.length; ++ j) {
    var page = frames[j].parentPage;
    try {
      ri.doc.sections.add(page);
      count ++;
    } catch(_e) {
      // Ignore
    }
  }

  if (count > 0) {
    ri_log(ri, "Created " + count + " section(s).");
  }
}

function riss_do_masters(ri) {
  var count = 0;
  for (var i = 0; i < ri.doc.masterSpreads.length; ++ i) {
    count += riss_do_master(ri, ri.doc.masterSpreads[i]);
  }

  if (count > 0) {
    ri_log(ri, "Forced " + count + " master(s).");
  }
}

function riss_do_master(ri, master) {
  var frames = ri_get_all_frames_with_para_styles_containins(ri, "@Master" + master.namePrefix + "@");

  if (frames.length == 0)
    return

  var count = 0;
  for (var i = 0; i < frames.length; ++ i) {
    try {
      ri_set_master(ri, frames[i].parentPage, master);
      count += 1;
    } catch(err) {
      ri_logw(ri, "Cannot set " + master.name + ": " + err);
    }
  }

  return count;
}

function ri_groom_rasterize(ri) {
  if (!ri.ui_epubbify.checkedState)
    return;

  var i, src_frame, dst_frame, src_frames;

  src_frames = ri_get_all_frames_with_para_styles_containins(ri, "@Rasterize@");
  if (src_frames.length == 0)
    return;

  app.findGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = ".+";
  app.changeGrepPreferences.changeTo = "";

  //var dst_layer = ri_get_epub_layer(ri, "rasterized");
  for (i = src_frames.length - 1; i >= 0; -- i) {
    src_frame = src_frames[i];
    dst_frame = src_frame.duplicate();
    dst_frame.label = RASTERIZED_FRAME_LABEL;
    dst_frame.objectExportOptions.properties = {
      customLayout: true,
      customLayoutType: CustomLayoutTypeEnum.ALIGNMENT_AND_SPACING,
      imageConversionType: ImageFormat.JPEG,
      imageExportResolution: ImageResolution.PPI_300,
      imagePageBreak: ImagePageBreakType.PAGE_BREAK_AFTER,
      jpegOptionsFormat: JPEGOptionsFormat.BASELINE_ENCODING,
      jpegOptionsQuality: JPEGOptionsQuality.HIGH,
      preserveAppearanceFromLayout: PreserveAppearanceFromLayoutEnum.PRESERVE_APPEARANCE_RASTERIZE_CONTAINER,
      sizeType: SizeTypeEnum.NONE_SIZE }

    // This is a hack, there are probably better ways, but if I use
    //  src_frame.contents = SpecialCharacters.FRAME_BREAK;
    // then the next frame gets this frame's first paragraph style.
    try {
      src_frame.changeGrep();
    } catch (e) {
      ri_logw(ri, "Cannot clear source frame: " + e);
    }
  }

  app.findGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences = NothingEnum.nothing;

  ri_log(ri, "Rasterized " + src_frames.length + " frame(s).");
}

function ri_get_all_frames_with_para_styles_containins(ri, substr) {
  var fids = {};
  var paras = ri_get_all_paras_with_styles_containing(ri, substr);
  var frames = [];
  for (var i = 0; i < paras.length; ++ i) {
    try {
      var frame = paras[i].parentTextFrames[0];
    } catch (_e) {
      continue;
    }
    if (!frame || !frame.isValid)
      continue;
    if (!frame.itemLayer || !frame.itemLayer.isValid)
      continue;
    if (MY_NAME_RE.test(frame.itemLayer.name))
      continue;
    var fid = frame.id;
    if (fids.hasOwnProperty(fid))
      continue;
    fids[fid] = true;
    frames.push(frame);
  }

  frames.sort(function(fx, fy){ x = fx.parentPage.index; y = fy.parentPage.index; return x < y ? -1 : x == y ? 0 : 1 });
  return frames;
}

function ri_get_all_paras_with_styles_containing(ri, substr) {
  var paras = [];

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "^.";
  var styles = ri_filter_styles(ri.doc.allParagraphStyles, substr);
  for (var j = 0; j < styles.length; ++ j) {
    app.findGrepPreferences.appliedParagraphStyle = styles[j];
    var hits = ri.doc.findGrep();
    for (var k = 0; k < hits.length; ++ k) {
      paras.push(hits[k].paragraphs[0]);
    }
  }

  if (paras.length > 0) {
    paras.sort(function(px, py){ x = px.index; y = py.index; return x < y ? -1 : x == y ? 0 : 1 });
  }
  app.findGrepPreferences = NothingEnum.nothing;

  return paras;
}

// Uses any fields currently in app.findGrepPreferences
function ri_get_all_texts_with_styles_containing(ri, substr) {
  var texts = [];

  var styles = ri_filter_styles(ri.doc.allCharacterStyles, substr);
  for (var j = 0; j < styles.length; ++ j) {
    app.findGrepPreferences.appliedCharacterStyle = styles[j];
    var hits = ri.doc.findGrep();
    for (var k = 0; k < hits.length; ++ k) {
      texts.push(hits[k]);
    }
  }

  return texts;
}

function ri_filter_styles(all_styles, substr) {
  var styles = [];
  for (var j = 0; j < all_styles.length; ++ j) {
    var style = all_styles[j];
    if (style.name.indexOf(substr) >= 0)
      styles.push(style)
  }

  return styles;
}


ri_main();
