// ex: set et sw=2:

// TODO: Pairwise kerning
// TODO: Check for the double frame thing at beginning/end.
// TODO: Border tricks at end/beginning of frames
// TODO: Some kind of "only this" button
// TODO: Configurable (and savable) Title matcher (r'Title|Frame Top')
// TODO: Split (and unsplit!) frames on specific styles
// TODO: Maybe do the start-of-line negative kerning trick?
// TODO: Status indication
// TODO: Change "old load" checkbox to radio
// TODO: Offer the precooked searches!
// TODO: Indexing stuff

AUTOGENERATED_GROUP_NAME = "(autogenerated)";

function ri_main() {
  ri = {
    doc: app.activeDocument,
    reflow_changed: false,
    messages: []
  };
  ri_run(ri);
}

function ri_run(ri) {
  ri_analyze(ri);

  if (!ri_get_options(ri))
    return;

  if (ri.uig_import.checkedState)
    if (!ri_get_importee(ri))
      return;

  ri_start_counter(ri);
  ri_disable_grep(ri);
  ri_disable_reflow(ri);
  if (ri.uig_pre.checkedState) {
    ri_pre_remaster(ri);
    ri_pre_clear(ri);
  }
  if (ri.uig_import.checkedState) {
    ri_do_import(ri);
    ri_do_images(ri);
  }
  if (ri.uig_post.checkedState) {
    ri_post_clear_overrides(ri);
    ri_reset_searches(ri);
    ri_post_fix_spaces(ri);
    ri_post_fix_dashes(ri);
    ri_post_fix_vav(ri);
    ri_post_remove_footnote_whitespace(ri);
    ri_post_convert_post_its(ri);
    ri_post_shrink_tables(ri);
    ri_reset_searches(ri);
  }
  if (ri.uig_groom.checkedState) {
    ri_groom_fully_justify(ri);
    ri_restore_reflow(ri);
  }
  ri_enable_grep(ri);
  ri_restore_reflow(ri);
  if (ri.uig_groom.checkedState) {
    ri_groom_fix_masters(ri);
    ri_groom_update_toc(ri);
  }
  ri_stop_counter(ri);
}

function ri_start_counter(ri) {
  ri.start_ms = new Date().valueOf();
}

function ri_stop_counter(ri) {
  end_ms = new Date().valueOf();
  elapsed = (end_ms - ri.start_ms) / 1000.0;

  ri.messages.unshift("Done in " + String(elapsed) + " Sec.");
  alert(ri.messages.join('\n'));
}

function ri_analyze(ri) {
  var vars = ri.doc.textVariables;
  ri.var_settings = null;
  ri.saved_settings = {}

  for (var i = 0; i < vars.length; ++ i) {
    var cur = vars[i]
    if (cur.variableType != VariableTypes.CUSTOM_TEXT_TYPE)
      continue;

    var name = cur.name;
    var value = cur.variableOptions.contents;
    if (name == "Imported From") {
      cur.name = "ReImport Settings";
      ri.var_settings = cur;
      ri.saved_settings = {importee: value};
    } else if (name == "ReImport Settings") {
      ri.var_settings = cur;
      try {
        ri.saved_settings = eval(value);
      } catch (e) {
      }
    }
  }

  ri.last_importee = ri.saved_settings.importee;

  var stories = ri.doc.stories;
  ri.have_toc = false;
  if (ri.doc.tocStyles.length > 1) {
    ri.toc_styles = ri.doc.tocStyles.everyItem().name;
    ri.toc_styles.shift();
    for (var i = 0; i < stories.length && !ri.have_toc; ++ i) {
      ri.have_toc = (stories[i].storyType == StoryTypes.TOC_STORY);
    }
  }
}

function ri_get_options(ri) {
  var dlg = app.dialogs.add({name: "ReImport Options"});
  with (dlg) {
    with (dialogColumns.add()) {
      with (ri.uig_pre = enablingGroups.add({staticLabel: "Pre-Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_pre_remaster =
            checkboxControls.add({
              staticLabel: "Reset all parent pages",
              checkedState: true,
            });
          ri.ui_pre_clear =
            checkboxControls.add({
              staticLabel: "Remove all text",
              checkedState: true,
            });
        }
      }

      with (ri.uig_import = enablingGroups.add({staticLabel: "Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          if (!ri.last_importee) {
            // staticTexts.add({staticLabel: "No previous import."});
          } else if (!File(ri.last_importee).exists) {
            staticTexts.add({staticLabel: "Cannot reload " + ri.last_importee});
          } else {
            ri.ui_same_importee = checkboxControls.add({
              staticLabel: "Reload " + String(ri.last_importee),
              checkedState: true,
            });
          }
          ri.ui_import_rerun = checkboxControls.add({
            staticLabel: "(If Tagged Taged) Try to reconvert",
            checkedState: true,
          });
          ri.ui_import_options = checkboxControls.add({
            staticLabel: "Show import options",
            checkedState: !ri.saved_settings.hide_import_options,
          });
          ri.ui_import_images = checkboxControls.add({
            staticLabel: "Import images",
            checkedState: !ri.saved_settings.dont_import_images,
          });
        }
      }

      with (ri.uig_post = enablingGroups.add({staticLabel: "Post-Import", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_post_clear_overrides =
            checkboxControls.add({
              staticLabel: "Clear all imported style overrides",
              checkedState: true,
            });
          ri.ui_post_fix_spaces =
            checkboxControls.add({
              staticLabel: "Eliminate multiple spaces",
              checkedState: true,
            });
          ri.ui_post_fix_dashes =
            checkboxControls.add({
              staticLabel: "Fix spacing around dashes",
              checkedState: true,
            });
          ri.ui_post_fix_vav =
            checkboxControls.add({
              staticLabel: "Use VAV WITH HOLAM glyph (Hadassah)",
              checkedState: !ri.saved_settings.unfix_vav,
            });
          ri.ui_post_remove_footnote_whitespace =
            checkboxControls.add({
              staticLabel: "Remove leading whitespace in footnotes",
              checkedState: true,
            });
          ri.ui_post_convert_post_its =
            checkboxControls.add({
              staticLabel: "(If Tagged Text) Convert comments",
              checkedState: true,
            });
          ri.ui_post_shrink_tables = checkboxControls.add({
            staticLabel: "Shrink tables to frame width",
            checkedState: !ri.saved_settings.dont_shrink_tables,
          });
        }
      }

      with (ri.uig_groom = enablingGroups.add({staticLabel: "Grooming", checkedState: true})) {
        with (dialogColumns.add() ) {
          ri.ui_groom_fully_justify =
            checkboxControls.add({
              staticLabel: "Fix to full justification",
              checkedState: !ri.saved_settings.unfix_justification,
            });
          ri.ui_groom_fix_masters =
            checkboxControls.add({
              staticLabel: "Fix parent pages",
              checkedState: !ri.saved_settings.unfix_masters,
            });
          ri.ui_groom_keep_masters =
            checkboxControls.add({
              staticLabel: "Keep correct parents",
              checkedState: !ri.saved_settings.unkeep_masters,
            });
          if (ri.have_toc) {
            ri.ui_groom_update_toc =
              checkboxControls.add({
                staticLabel: "Update TOC",
                checkedState: !ri.saved_settings.unupdate_toc,
              });
            ri.ui_groom_toc_style = dropdowns.add({
              stringList: ri.toc_styles,
              selectedIndex: 0
            });
          }
        }
      }

      with (borderPanels.add()) {
        with (dialogColumns.add() ) {
          staticTexts.add({staticLabel: "Default Parent:"});
          staticTexts.add({staticLabel: "Headless Parent:"});
        }
        with (dialogColumns.add()) {
          var masters = ri.doc.masterSpreads.everyItem().name;
          ri.ui_a_master = dropdowns.add({stringList: masters, selectedIndex: 0});
          ri.ui_b_master = dropdowns.add({stringList: masters, selectedIndex: masters.length - 1});
          if (ri.saved_settings.a_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.a_master)).isValid)
              ri.ui_a_master.selectedIndex = m.index;
          if (ri.saved_settings.b_master)
            if ((m = ri.doc.masterSpreads.itemByName(ri.saved_settings.b_master)).isValid)
              ri.ui_b_master.selectedIndex = m.index;
        }
      }

      with (checkboxControls) {
        with (dialogColumns.add()) {
          ri.ui_disable_grep = add({
            staticLabel: "Disable GREP styles while working",
            checkedState: !ri.saved_settings.keep_grep,
          });
          ri.ui_disable_reflow = add({
            staticLabel: "Disable smart reflow when applicable",
            checkedState: !ri.saved_settings.keep_reflow,
          });
        }
      }
    }
  }
  if (!dlg.show()) {
    dlg.destroy();
    return false;
  }

  ri.a_master_name = masters[ri.ui_a_master.selectedIndex];
  ri.b_master_name = masters[ri.ui_b_master.selectedIndex];
  ri.a_master = ri.doc.masterSpreads.itemByName(ri.a_master_name);
  ri.b_master = ri.doc.masterSpreads.itemByName(ri.b_master_name);
  return true;
}

function ri_get_importee(ri) {
  if (ri.last_importee && ri.ui_same_importee && ri.ui_same_importee.checkedState)
    ri.importee = File(ri.last_importee);
  else
    ri.importee = File.openDialog("Choose your importee", ri.filter_files)
  return ri.importee;
}

function ri_filter_files(ri, file) {
  if (file.constructor.name == "Folder") {
    return true;
  }
  if (file.name.match(/\.(docx?|txt|idtt)$/)) {
    return true;
  }
  return false;
}

function ri_pre_remaster(ri) {
  if (!ri.ui_pre_remaster.checkedState)
    return;
  ri.doc.pages.everyItem().appliedMaster = ri.a_master;
}

function ri_pre_clear(ri) {
  if (!ri.ui_pre_clear.checkedState)
    return;
  var page = ri.doc.pages[0];
  try {
    var frame = ri_main_frame(ri, page)
    var story = frame.parentStory;
    story.contents = "";
  } catch (e) {
  }
  //ri_override_all_master_page_items(ri, page);
}

function ri_override_all_master_page_items(ri, page) {
  for (var i = 0; i < page.masterPageItems.length; ++ i) {
    mpi = page.masterPageItems[i];
    try {
      if (mpi.allowOverrides) {
        mpi.override(page);
      }
    } catch (e) {
    }
  }
}

function ri_do_import(ri) {
  var page = ri.doc.pages[0];
  var frame = ri_main_frame(ri, page);

  if (ri.ui_import_rerun.checkedState) {
    try {
      rerunner = ri.importee + '.rerun';
      mtime = File(rerunner).modified;
      if (mtime) {
        File(rerunner).execute();
        for (var n = 0; n < 50 && File(rerunner).modified.getTime() == mtime.getTime(); ++ n)
          $.sleep(100);
      }
    } catch (e) {
      // No harm done.
    }
  }

  try {
    frame.place(ri.importee, ri.ui_import_options.checkedState);
  } catch (e) {
    ri.messages.push('Could not import document: ' + e);
  }

  if (!ri.var_settings)
    ri.var_settings = ri.doc.textVariables.add({
      name: "ReImport Settings",
      variableType: VariableTypes.CUSTOM_TEXT_TYPE
    });

  ri.var_settings.variableOptions.contents = uneval({
    importee: ri.importee.fsName,

    a_master: ri.a_master_name,
    b_master: ri.b_master_name,
    dont_import_images: !ri.ui_import_images.checkedState,
    hide_import_options: !ri.ui_import_options.checkedState,
    keep_grep: !ri.ui_disable_grep.checkedState,
    keep_reflow: !ri.ui_disable_reflow.checkedState,
    unfix_justification: !ri.ui_groom_fully_justify.checkedState,
    unfix_masters: !ri.ui_groom_fix_masters,
    unfix_vav: !ri.ui_post_fix_vav,
    unkeep_masters: !ri.ui_groom_keep_masters,
    unupdate_toc: !ri.ui_groom_update_toc,
  })
}

function ri_do_images(ri) {
  if (!ri.ui_import_images.checkedState)
    return;

  try {
    var image_ref_style = ri.doc
      .characterStyleGroups.item(AUTOGENERATED_GROUP_NAME)
      .characterStyles.item("(Image)");
    if (!image_ref_style.isValid)
      return;
  } catch (e) {
    return;
  }

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "\\S+";
  app.findGrepPreferences.appliedCharacterStyle = image_ref_style;

  try {
    var refs = app.findGrep();
    for (var i = 0; i < refs.length; ++ i) {
      var ref = refs[i];
      var path = File(ri.doc.filePath + "/" + ref.contents);
      ref.select();
      ri.doc.place(path);
    }
  } catch(e) {
    ri.messages.push('Could not import image ' + path + ': ' + e);
    ri.messages.push('Giving up on image conversion.');
  }

  app.findGrepPreferences = NothingEnum.nothing;
}

function ri_post_clear_overrides(ri) {
  if (!ri.ui_post_clear_overrides.checkedState)
    return;
  ri.doc.stories.everyItem().clearOverrides();
  try {
    ri.doc.stories.everyItem().footnotes.everyItem().texts.everyItem().clearOverrides();
  }
  catch (e) {
  }
}

function ri_post_fix_spaces(ri) {
  if (!ri.ui_post_fix_spaces.checkedState)
    return;

  // Multiple Space to Single Space
  ri_change_grep(ri, "[~m~>~f~|~S~s~<~/~.~3~4~% ]{2,}", " ");

  // No whitespace at the end of paragraphs (doesn't work!?)
  ri_change_grep(ri, "\\s+$", "");
}

function ri_post_fix_dashes(ri) {
  if (!ri.ui_post_fix_dashes.checkedState)
    return;

  ri_change_grep(ri, "[~m~>~f~|~S~s~<~/~.~3~4~% ~k]+([-+~=/]+)", "~S$1");
  ri_change_grep(ri, "([-+~=/]+)[~m~>~f~|~S~s~<~/~.~3~4~% ~k]+", "$1 ");
}

function ri_post_fix_vav(ri) {
  if (!ri.ui_post_fix_vav.checkedState)
    return;

  app.findGrepPreferences.appliedFont = "Hadassah Friedlaender";
  ri_change_grep(ri, "\\x{05D5}\\x{05B9}", "\\x{FB4B}");
  app.findGrepPreferences = NothingEnum.nothing;

  ri_change_grep(ri, "([^~m~>~f~|~S~s~<~/~.~3~4~% ~k])(\\x{FB4B})", "$1~j$2");
  ri_change_grep(ri, "(\\x{FB4B})([^~m~>~f~|~S~s~<~/~.~3~4~% ~k])", "$1~j$2");
}

function ri_post_remove_footnote_whitespace(ri) {
  if (!ri.ui_post_remove_footnote_whitespace.checkedState)
    return;

  app.findGrepPreferences.findWhat = "(?<=^~F\\t) +";
  app.changeGrepPreferences.changeTo = "";
  try {
    ri.doc.stories.everyItem()
      .footnotes.everyItem()
      .texts.everyItem()
      .changeGrep();
  } catch (e) {
  }
}

function ri_post_convert_post_its(ri) {
  if (!ri.ui_post_convert_post_its.checkedState)
    return;

  try {
    var ugly_ref_style = ri.doc
      .characterStyleGroups.item(AUTOGENERATED_GROUP_NAME)
      .characterStyles.item("(Comment Reference)");
  } catch (e) {
    return;
  }

  if (!ugly_ref_style.isValid)
    return;

  app.findGrepPreferences = NothingEnum.nothing;
  app.findGrepPreferences.findWhat = "~F";
  app.findGrepPreferences.appliedCharacterStyle = ugly_ref_style;

  var ugly_refs = app.findGrep();
  for (var i = 0; i < ugly_refs.length; ++ i) {
    var ugly_ref = ugly_refs[i].footnotes[0];

    var nice_frame = ri.doc.textFrames.add();

    var ugly_paragraphs = ugly_ref.paragraphs;
    for (var j = 0; j < ugly_paragraphs.length; ++ j) {
      var ugly_paragraph = ugly_paragraphs[j];
      var nice_paragraph = ugly_paragraph.duplicate(LocationOptions.AT_END, nice_frame);

      nice_characters = nice_paragraph.characters;
      if (nice_characters[0].contents == SpecialCharacters.FOOTNOTE_SYMBOL) {
        nice_characters.itemByRange(0, 1).remove();
      }
    }

    nice_frame.anchoredObjectSettings
      .insertAnchoredObject(ugly_ref.storyOffset, AnchorPosition.ANCHORED);

    ri_fix_post_it(ri, nice_frame);
  }

  // Get rid of the ugly footnotes
  ri.doc.changeGrep();

  // Get rid of the ugly style
  ugly_ref_style.remove();
}

function ri_fix_post_it(ri, frame) {
  frame.applyObjectStyle(ri_post_it_object_style(ri));

  var prefs = frame.textFramePreferences;
  prefs.insetSpacing = 2;
  prefs.autoSizingType = AutoSizingTypeEnum.HEIGHT_ONLY;

  var baseline = frame.baselineFrameGridOptions;
  baseline.useCustomBaselineFrameGrid = true;
  baseline.baselineFrameGridRelativeOption = BaselineFrameGridRelativeOption.TOP_OF_FRAME;
  baseline.startingOffsetForBaselineFrameGrid = 0;
  baseline.baselineFrameGridIncrement = "9pt";

  var anchoring = frame.anchoredObjectSettings;
  anchoring.spineRelative = true;
  anchoring.anchorPoint = AnchorPoint.TOP_RIGHT_ANCHOR;
  anchoring.anchoredPosition = AnchorPosition.ANCHORED;
  anchoring.horizontalAlignment = HorizontalAlignment.LEFT_ALIGN;
  anchoring.horizontalReferencePoint = AnchoredRelativeTo.TEXT_FRAME;
  anchoring.anchorXoffset = "6pt";
  anchoring.verticalAlignment = VerticalAlignment.TOP_ALIGN;
  anchoring.verticalReferencePoint = VerticallyRelativeTo.TOP_OF_LEADING;
  anchoring.anchorYoffset = "0pt";

  var drop = frame.transparencySettings.dropShadowSettings;
  drop.mode = ShadowMode.DROP;
  drop.opacity = 50;
  drop.distance = "6pt";

  frame.resize(
    BoundingBoxLimits.GEOMETRIC_PATH_BOUNDS,
    AnchorPoint.CENTER_ANCHOR,
    ResizeMethods.REPLACING_CURRENT_DIMENSIONS_WITH,
    [72, 72]
  );
}

function ri_post_it_object_style(ri) {
  var groups = ri.doc.objectStyleGroups;

  var group = groups.item(AUTOGENERATED_GROUP_NAME);
  if (!group.isValid)
    group = groups.add({name: AUTOGENERATED_GROUP_NAME});

  var styles = group.objectStyles;
  var style = styles.item("(balloon)");
  if (!style.isValid) {
    style = styles.add({
      name: "(balloon)",
      nonprinting: true,

      fillColor: "C=0 M=0 Y=100 K=0",
      fillTint: 20,

      strokeColor: "Black",
      strokeWeight: 0.5,

      bottomLeftCornerOption: CornerOptions.ROUNDED_CORNER,
      bottomRightCornerOption: CornerOptions.ROUNDED_CORNER,
      topLeftCornerOption: CornerOptions.ROUNDED_CORNER,
      topRightCornerOption: CornerOptions.ROUNDED_CORNER,
      bottomLeftCornerRadius: "6pt",
      bottomRightCornerRadius: "6pt",
      topLeftCornerRadius: "6pt",
      topRightCornerRadius: "6pt",

      enableTransformAttributes: true,
    });

    style.setDimensionAttributeState(DimensionAttributes.WIDTH_ATTRIBUTE, true);
  }

  return style;
}

function ri_post_shrink_tables(ri) {
  if (!ri.ui_post_shrink_tables.checkedState)
    return;

  var pages = ri.doc.pages;
  for (var i = pages.length - 1; i >= 0; --i) {
    var frame = ri_main_frame(ri, pages[i]);
    var max_width = frame.geometricBounds[3] - frame.geometricBounds[1];
    var tables = frame.tables.everyItem().getElements();
    for (var j = tables.length - 1; j >= 0; --j) {
      var table = tables[j];
      if (table.width > max_width) {
        var columns = table.columns;
        var num_columns = columns.length
        var new_width = max_width / num_columns;
        for (var k = 0; k < num_columns; ++k) {
          columns[k].width = new_width;
        }
      }
    }
  }
}

function ri_groom_fully_justify(ri) {
  if (!ri.ui_groom_fully_justify.checkedState)
    return;

  var page = ri.doc.pages[0];
  var frame = ri_main_frame(ri, page);
  var story = frame.parentStory;
  var paragraphs = story.paragraphs;

  var prefs = ri.doc.viewPreferences;
  var oldUnits = prefs.horizontalMeasurementUnits;
  prefs.horizontalMeasurementUnits = MeasurementUnits.pixels;

  ri.num_adjustified = 0;
  ri.num_considered = 0;
  for (var i = 0; i < paragraphs.count(); ++ i)
    ri_fully_justify(ri, paragraphs, i);

  prefs.horizontalMeasurementUnits = oldUnits;

  if (ri.num_considered) {
    ri.messages.push(
      String(ri.num_considered) + ' of ' +
      String(paragraphs.count()) + ' paragraph(s) ' +
      ' considered for justification adjustment.'
    );
  }
  if (ri.num_adjustified) {
    ri.messages.push(String(ri.num_adjustified) + ' changed.');
  }
}

function ri_fully_justify(ri, paragraphs, index) {
  if (index + 1 == paragraphs.count()) {
    // The last paragraph in the text can stay as-is
    return;
  }

  var paragraph = paragraphs[index];

  if (paragraph.paragraphDirection != ParagraphDirectionOptions.RIGHT_TO_LEFT_DIRECTION) {
    // We only know about RTL
    return;
  }

  var justification = paragraph.justification;
  if (justification == Justification.FULLY_JUSTIFIED) {
    // Currently fully justified, may be intentional
    var style = paragraph.appliedParagraphStyle;
    if (style && style.justification == Justification.FULLY_JUSTIFIED) {
      // If that's what the user likes...
      return;
    }
  } else if (justification != Justification.RIGHT_JUSTIFIED) {
    // Some kind of fancy centered paragraph.
    return;
  }

  var lines = paragraph.lines;
  var numLines = lines.count()
  var lastLine = lines[-1];
  var lastLineFrame = lastLine.parentTextFrames[0];
  if (lastLineFrame == undefined) {
    // Still in overset limbo.
    return;
  }

  ++ ri.num_considered;

  var followingFrame = paragraphs[index + 1].lines[0].parentTextFrames[0];
  if ((followingFrame != undefined) && (lastLineFrame != followingFrame)) {
    // Last in its frame, no questions asked
    if (justification != Justification.RIGHT_JUSTIFIED) {
      paragraph.justification = Justification.RIGHT_JUSTIFIED;
      ++ ri.num_adjustified;
    }
    return;
  }

  var lastChar = lastLine.characters[-1];
  if (lastChar == '\n') {
    lastChar = lastLine.characters[-2];
  }

  var fully = null;
  var right = null;

  if (lines.count() > 1) {
    ri.last_good_line = lines[-2];
    ri.last_good_char = ri.last_good_line.characters[-1];
  }

  if (justification == Justification.FULLY_JUSTIFIED) {
    // Currently fully justified, we know the margin
    fully = lastChar.endHorizontalOffset;
    paragraph.justification = Justification.RIGHT_JUSTIFIED;
    right = lastChar.endHorizontalOffset;
  } else if (ri.last_good_line != undefined) {
    // We have something to compare with!
    right = lastChar.endHorizontalOffset;
    fully = ri.last_good_char.endHorizontalOffset;

    var last_good_frame = ri.last_good_line.parentTextFrames[0];

    if (last_good_frame != lastLineFrame) {
      fully -= last_good_frame.parentPage.bounds[1];
      fully += lastLineFrame.parentPage.bounds[1];
    }
  } else {
    // Change and compare
    right = lastChar.endHorizontalOffset;
    right = lastChar.endHorizontalOffset;
    paragraph.justification = Justification.FULLY_JUSTIFIED;
    fully = lastChar.endHorizontalOffset;
  }

  var gap = right - fully;
  var fudge = lastChar.pointSize / 2;

  if (gap != 0 && gap < fudge && gap > -fudge) {
    paragraph.justification = Justification.FULLY_JUSTIFIED;
    ri.last_good_line = lastLine;
    ri.last_good_char = lastChar;
  } else {
    paragraph.justification = Justification.RIGHT_JUSTIFIED;
  }

  if (paragraph.justification != justification) {
    ++ ri.num_adjustified;
  }
}

/* NOT CURRENTLY USED */
function ri_really_fully_justify(ri, paragraph) {
  var unfull_style = paragraph.appliedParagraphStyle;

  groups = ri.doc.paragraphStyleGroups;
  var group = groups.itemByName("ReImport");
  if (!group.isValid)
    group = groups.add({name: "ReImport"});

  full_name = unfull_style.name + " (fully justified)"
  var group_styles = group.paragraphStyles;
  var full_style = group_styles.itemByName(full_name);
  if (!full_style.isValid) {
    full_style = group_styles.add({
      name: full_name,
      basedOn: unfull_style,
      justification: Justification.FULLY_JUSTIFIED,
    });
  }
  paragraph.applyParagraphStyle(full_style);
}

function ri_reset_searches(ri) {
  app.findTextPreferences = NothingEnum.nothing;
  app.changeTextPreferences = NothingEnum.nothing;
  app.findGrepPreferences = NothingEnum.nothing;
  app.changeGrepPreferences = NothingEnum.nothing;
}

function ri_change_text(ri, findWhat, changeTo) {
  app.findTextPreferences.findWhat = findWhat;
  app.changeTextPreferences.changeTo = changeTo;
  ri.doc.changeText();
}

function ri_change_grep(ri, findWhat, changeTo) {
  app.findGrepPreferences.findWhat = findWhat;
  app.changeGrepPreferences.changeTo = changeTo;
  ri.doc.changeGrep();
}

function ri_groom_fix_masters(ri) {
  if (!ri.ui_groom_fix_masters.checkedState)
    return;

  // title page is B-Master
  var title_page = ri.doc.pages[0];
  ri_set_master(ri, title_page, ri.b_master);

  for (var i = 1; i < ri.doc.pages.length; ++ i) {
    var page = ri.doc.pages[i];
    if (ri_page_is_empty(ri, page) || ri_page_is_chapter(ri, page)) {
      page.appliedMaster = ri.b_master;
    } else {
      page.appliedMaster = ri.a_master;
    }
  }
}

function ri_set_master(ri, page, master) {
  if (ri.ui_groom_keep_masters)
    if (page.appliedMaster.id == master.id)
      return;
  page.appliedMaster = master;
}

function ri_groom_update_toc(ri) {
  if (!ri.have_toc)
    return;

  if (!ri.ui_groom_update_toc.checkedState)
    return;

  var style_index = ri.ui_groom_toc_style.selectedIndex;
  var style_name = ri.toc_styles[style_index];
  var style = ri.doc.tocStyles.itemByName(style_name);
  ri.doc.createTOC(style, true);
}

function ri_page_is_empty(ri, page) {
  if (page.pageItems.length == 0) {
    return true;
  }
  if (ri_main_frame(ri, page).contents == "") {
    return true;
  }
}

function ri_page_is_chapter(ri, page) {
  var frame = ri_main_frame(ri, page);
  var paragraph = frame.paragraphs[0];
  if (paragraph.startParagraph == StartParagraph.NEXT_PAGE ||
    paragraph.startParagraph == StartParagraph.NEXT_ODD_PAGE) {
    return true;
  }
  if (paragraph.appliedParagraphStyle.name.toLowerCase().indexOf("title") != -1) {
    return true;
  }
  return false;
}

function ri_disable_grep(ri) {
  if (!ri.ui_disable_grep.checkedState)
    return;

  pstyles = ri.doc.allParagraphStyles;
  for (var i = 0; i < pstyles.length; ++ i) {
    pstyle = pstyles[i];
    gstyles = pstyle.nestedGrepStyles;
    for (var j = 0; j < gstyles.length; ++ j) {
      gstyle = gstyles[j];
      if (gstyle.grepExpression[0] != '*')
        gstyle.grepExpression = '*' + gstyle.grepExpression;
    }
  }
}

function ri_enable_grep(ri) {
  if (!ri.ui_disable_grep.checkedState)
    return;

  pstyles = ri.doc.allParagraphStyles;
  for (var i = 0; i < pstyles.length; ++ i) {
    pstyle = pstyles[i];
    gstyles = pstyle.nestedGrepStyles;
    for (var j = 0; j < gstyles.length; ++ j) {
      gstyle = gstyles[j];
      if (gstyle.grepExpression[0] == '*')
        gstyle.grepExpression = gstyle.grepExpression.substr(1);
    }
  }
}

function ri_disable_reflow(ri) {
  if (!ri.ui_disable_reflow.checkedState)
    return;

  if (ri.reflow_changed)
    return;

  ri.saved_reflow = ri.doc.textPreferences.smartTextReflow;
  ri.doc.textPreferences.smartTextReflow = false;
  ri.reflow_changed = true;
}

function ri_restore_reflow(ri) {
  if (!ri.ui_disable_reflow.checkedState)
    return;

  if (!ri.reflow_changed)
    return;

  var saved_preflight = ri.doc.preflightOptions.preflightOff;

  ri.doc.preflightOptions.preflightOff = false; 
  ri.doc.textPreferences.smartTextReflow = ri.saved_reflow;
  ri.doc.activeProcess.waitForProcess(30);
  ri.doc.preflightOptions.preflightOff = saved_preflight;

  ri.reflow_changed = false;
}

function ri_main_frame(ri, page) {
  var frames = page.textFrames;
  for (var i = 0; i < frames.length; ++ i) {
    try {
      var frame = frames[i];
      var master = frame.overriddenMasterPageItem;
      if (master.nextTextFrame != null || master.previousTextFrame != null) {
        return frame;
      }
    } catch (e) {
    }
  }
  return frames[0];
}

ri_main();
