#!/usr/bin/env python3
"""Practice Makes Perfect"""
import argparse
import dataclasses
import hashlib
import graphlib
import io
from pathlib import Path
import plistlib
import random
import re

from collections import defaultdict
from collections.abc import Container
from collections.abc import Iterable
from collections.abc import Sequence
from typing import Generic
from typing import NamedTuple
from typing import NoReturn
from typing import TextIO
from typing import TypeAlias
from typing import TypeVar

# TO DO:
# - "Ray Brown's Blues (p.100), {} pattern in {}-major: {A+B|C|D|E|F} {major}"
# - Support {}->[]
# - Refactor to make all choosers integerish? And all in self.choosers
# - "easy-major := C|F|G" etc., a sort of mnem-mnem


T = TypeVar("T")
Playable: TypeAlias = "Etude | BookRef"
TableOfContents: TypeAlias = list[Playable]
PitchClass: TypeAlias = Sequence[str]


@dataclasses.dataclass
class Pool:
    """A pool of choices for an etude"""
    keys: str | list[str]
    mnem: str = dataclasses.field(init=False)

    def __post_init__(self):
        if isinstance(self.keys, str):
            self.mnem = self.keys
        else:
            self.mnem = "|".join(sorted(self.keys))


@dataclasses.dataclass
class Etude:
    """A concrete etude, e.g., 'minor pentatonic'"""
    name: str
    pools: list[Pool]


@dataclasses.dataclass
class Chooser(Generic[T]):
    """Chooses from a defined pool, minimizing repetitions"""
    pool: list[T]
    queue: list[T] | None = dataclasses.field(default=None)
    used: bool = dataclasses.field(default=False, init=False)

    def __post_init__(self):
        if self.queue:
            random.shuffle(self.queue)

    def __len__(self):
        return len(self.pool)

    def get(self) -> T:
        """Get the next item"""
        if not self.queue:
            self.queue = list(self.pool)
            random.shuffle(self.queue)
        self.used = True
        return self.queue.pop()


@dataclasses.dataclass
class Book:
    """A collections of etudes or pointers to other books"""
    toc: TableOfContents
    sequential: bool = False
    chooser: Chooser[int] = dataclasses.field(init=False)

    def __len__(self):
        return len(self.toc)

    def __post_init__(self):
        self.make_chooser()

    def __hash__(self) -> int:
        hashable = "\x00".join([entry.name for entry in self.toc])
        return int(hashlib.sha256(hashable.encode()).hexdigest(), 16)

    @property
    def used(self) -> bool:
        """Whether this book has been used"""
        return self.chooser.used

    def get(self) -> Playable:
        """Get the next random playable"""
        return self.toc[self.chooser.get()]

    def restore(self, queue) -> None:
        """Validate and restore a saved queue"""
        if not isinstance(queue, list):
            return
        if not all(isinstance(idx, int) for idx in queue):
            return
        if queue:
            idxs = set(queue)
            if len(idxs) != len(queue):
                return
            if max(idxs) >= len(self):
                return
        self.chooser.queue = queue

    def append(self, playable: Playable):
        """Add an entry to the TOC"""
        self.toc.append(playable)

    def make_chooser(self):
        """(Re)create the chooser"""
        self.chooser = Chooser(list(range(len(self))))


class BookRef(NamedTuple):
    """A reference to a book"""
    name: str
    num_etudes: int | None = None


DEFAULT_CONFIG = """
note:  # Just pick a note
  : ANY

scale:  # Play a scale
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

mode:  # Play a mode
  ' ionian': ionian
  ' dorian': dorian
  ' phrygian': phrygian
  ' lydian': lydian
  ' mixolydian': mixolydian
  ' aeolian': aeolian
  ' locrian': locrian

arp:  # Play an arpeggio
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  ' major pentatonic': major
  ' minor pentatonic': minor
"""


class Configuration(NamedTuple):
    """The information from the config file"""
    books: dict[str, Book]
    starred: list[str]


class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace
    config: Configuration

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(
            description="Practice Makes Perfect"
        )
        parser.add_argument(
            "books",
            metavar="BOOK",
            type=str,
            nargs="*",
        )

        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--num-tracks",
            type=int,
        )
        group.add_argument(
            "-N",
            "--one-of-each",
            action="store_true",
        )

        parser.add_argument(
            "-i",
            "--max-etudes",
            type=int,
        )
        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
        )
        parser.add_argument(
            "-v",
            "--verbose",
            action="store_true",
        )
        parser.add_argument(
            "-c",
            "--config",
            type=Path,
            default=Path.home() / ".pmprc",
        )
        parser.add_argument(
            "-C",
            "--state-file",
            type=Path,
            default=Path.home() / ".pmp.plist",
        )
        self.args = parser.parse_args()
        self.parser = parser

    _LETTERS = "CDEFGAB"
    _MODES = (
        "ionian",
        "dorian",
        "phrygian",
        "lydian",
        "mixolydian",
        "aeolian",
        "locrian",
    )

    PITCH_CLASSES: list[PitchClass] = [
        ("C",),
        ("C♯", "D♭"),
        ("D",),
        ("D♯", "E♭"),
        ("E",),
        ("F",),
        ("F♯", "G♭"),
        ("G",),
        ("G♯", "A♭"),
        ("A",),
        ("A♯", "B♭"),
        ("B",),
    ]

    SCALE_FIX: dict[str, dict[str, str]] = {
        "NONE": {},
        "ANY": {},
        "major": {
            "G♯": "A♭",
            "D♯": "E♭",
            "A♯": "B♭",
        },
        "minor": {
            "G♭": "F♯",
            "D♭": "C♯",
            "A♭": "G♯",
        }
    }

    all_books: dict[str, Book]
    choosers: dict[str, Chooser]
    state: dict
    book_name: str

    STATE_VERSION = "v2"

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()

        if self.args.books == ["default-config"]:
            print(DEFAULT_CONFIG)
            return

        self.add_modes()
        self.configure()
        self.load_state()
        self.make_choosers()
        self.restore_book_state()

        self.book_name = self.choose_book()
        self.run_book(
            self.book_name,
            None if self.args.one_of_each else self.args.num_tracks,
            spaced=True,
        )
        self.save_state()

    def run_book(self, name: str, num_tracks: int | None, spaced=False):
        """Run any book"""
        book = self.all_books[name]
        if book.sequential:
            self.run_agenda(book, spaced=spaced)
        else:
            self.book_name = name
            self.run_plain(book, num_tracks)

    def run_agenda(self, book: Book, spaced: bool) -> None:
        """Run an agenda: A sequence of books"""
        for entry in book.toc:
            if isinstance(entry, Etude):
                print(self.make_track(entry))
            else:
                ref: BookRef = entry
                self.run_book(ref.name, ref.num_etudes)
            if spaced:
                print("")

    def run_plain(self, book: Book, num_tracks: int | None):
        """Run a "simple" book, choosing etudes and assigining keys"""
        playables = book.toc
        if self.args.max_etudes:
            num_playables = min(self.args.max_etudes, len(playables))
            playables = random.sample(playables, num_playables)

        if num_tracks is None:
            num_tracks = len(playables)
        elif num_tracks == 0:
            num_tracks = len(self.PITCH_CLASSES)

        if self.args.verbose:
            print(f"[{self.book_name} × {num_tracks}]")

        pseudo_book = Book(playables)
        etude_seq = self.choose_etudes(pseudo_book, num_tracks)
        track_seq = self.make_tracks(etude_seq)

        print(self.get_sep(track_seq).join(track_seq))

    def choose_etudes(
        self,
        book: Book,
        count: int
    ) -> Iterable[Etude]:
        """Yields chosen etudes"""
        assert not book.sequential
        for _ in range(count):
            entry = book.get()
            if isinstance(entry, Etude):
                yield entry
            else:
                yield from self.choose_etudes(
                    self.all_books[entry.name],
                    entry.num_etudes or 1
                )

    def choose_book(self) -> str:
        """Pick out a book"""
        if self.args.books:
            pool = self.args.books
            if (unknown := set(pool) - set(self.all_books)):
                self.fail(f"Unknown book(s): {' '.join(unknown)}")
        else:
            pool = self.config.starred
            if len(pool) > 1:
                self.args.verbose = True
        return random.choice(pool)

    def make_tracks(
        self,
        etude_seq: Iterable[Etude],
    ) -> list[str]:
        """Pick a key for each etude"""
        return [
            self.make_track(etude)
            for etude in etude_seq
        ]

    def make_track(self, etude: Etude) -> str:
        """Pick a key for one etude"""
        keys = []
        for pool in etude.pools:
            key = self.choosers[pool.mnem].get()
            if not isinstance(key, str):  # e.g., ("C♯", "D♭")
                key = random.choice(key)
            keys.append(key)

        if "{}" in etude.name:
            return etude.name.format(*keys)

        return f"{keys[0]}{etude.name}"

    def get_sep(self, tracks: list[str]) -> str:
        """Return space or newline separator"""
        if self.args.multiline:
            return "\n"
        if any(" " in track for track in tracks):
            return "\n"
        if sum(len(track) for track in tracks) + len(tracks) >= 80:
            return "\n"
        return " "

    def add_modes(self) -> None:
        """Add the Greek modes and their hypotheticals to our known scales"""
        model = self.SCALE_FIX["major"]
        mapping: dict[str, str]

        for offset, mode in enumerate(self._MODES):
            mapping = {
                note: self._LETTERS[(idx + offset) % len(self._LETTERS)]
                for idx, note in enumerate(self._LETTERS)
            }

            def modify(note: str) -> str:
                try:
                    return mapping[note[0]] + note[1:]
                except KeyError:
                    return note

            self.SCALE_FIX[mode] = {
                modify(key): modify(value)
                for key, value in model.items()
            }

    @classmethod
    def choose(cls, options: Iterable[T], num_choices: int) -> list[T]:
        """Choose so we have as many "full" repetitions and a random tail"""
        opts = list(options)
        nopts = len(opts)

        if num_choices <= nopts:
            return random.sample(opts, max(num_choices, 1))

        ntail = num_choices % nopts
        n_full_rounds = (num_choices - ntail) // nopts

        choices = (opts * n_full_rounds) + random.sample(opts, ntail)
        return choices

    def configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self.parse_config(fobj)
        except (FileNotFoundError, ValueError):
            self.config = self.parse_config(io.StringIO(DEFAULT_CONFIG))
        self.all_books = self.config.books
        self.check_refs()

    def load_state(self) -> None:
        """Read saved state.

        Sets `self.state`.
        """
        try:
            with open(self.args.state_file, "rb") as fobj:
                loaded = plistlib.load(fobj)
            self.state = loaded[self.STATE_VERSION]
        except (FileNotFoundError, plistlib.InvalidFileException, KeyError):
            self.state = {}
        self.state.setdefault("book", {})
        self.state.setdefault("etude", {})

    def save_state(self) -> None:
        """Save the queue state"""
        # Remove goners
        for key in list(self.state["etude"]):
            if key not in self.choosers:
                del self.state["etude"][key]
        for key, saved in list(self.state["book"].items()):
            if hash(self.all_books.get(key)) != saved["hash"]:
                del self.state["book"][key]

        # Update current
        for key, chooser in self.choosers.items():
            if chooser.used and len(chooser) > 2:
                self.state["etude"][key] = chooser.queue
        for key, book in self.all_books.items():
            if book.used and len(book) > 2:
                self.state["book"][key] = {
                    "hash": hash(book),
                    "queue": book.chooser.queue,
                }

        with open(self.args.state_file, "wb") as fobj:
            plistlib.dump(
                {self.STATE_VERSION: self.state},
                fobj,
            )

    def make_choosers(self) -> None:
        """Prepare randomizers"""
        self.choosers = {
            scale: Chooser(
                [
                    [
                        fixes.get(note, note)
                        for note in pitch_class
                    ]
                    for pitch_class in self.PITCH_CLASSES
                ],
                self.state.get(scale),
            )
            for scale, fixes in self.SCALE_FIX.items()
        }
        self.choosers["NONE"] = Chooser([""])
        for book in self.all_books.values():
            book.make_chooser()
            for etude in book.toc:
                if not isinstance(etude, Etude):
                    continue
                for pool in etude.pools:
                    if not isinstance(pool.keys, list):
                        continue
                    if pool.mnem in self.choosers:
                        continue
                    self.choosers[pool.mnem] = Chooser(
                        pool.keys,
                        self.state["etude"].get(pool.mnem),
                    )

    def restore_book_state(self) -> None:
        """Continue books from where we left off"""
        for name, saved in self.state["book"].items():
            if (book := self.all_books[name]):
                if saved.get("hash") == hash(book):
                    book.restore(saved.get("queue"))

    def parse_config(self, stream: TextIO) -> Configuration:
        """Read configuration file"""
        try:
            return ConfigParser(self.SCALE_FIX).parse(stream)
        except BadConfig as err:
            self.fail(str(err))
            raise err  # Won't happen, just to appease pyright

    def check_refs(self) -> None:
        """Check configured graph is legit"""
        graph = defaultdict(set)
        for name, book in self.all_books.items():
            for ref in book.toc:
                if not isinstance(ref, BookRef):
                    continue
                other = ref.name
                if self.all_books[other].sequential and not book.sequential:
                    self.fail(f"{name}{{}}->{other}[] not supported")
                graph[other].add(name)

        if (missing := graph.keys() - self.all_books.keys()):
            error = ", ".join(
                f"{name} (used by {', '.join(graph[name])})"
                for name in missing
            )
            self.fail(f"Unknown reference(s): {error}")

        try:
            topo = graphlib.TopologicalSorter(graph)
            topo.prepare()
        except graphlib.CycleError as exc:
            self.fail(f"Cyclical configuration: {' -> '.join(exc.args[1])}")

    def fail(self, message: str) -> NoReturn:
        """Handy wrapper around ArgumentParser's `.fail()` method"""
        self.parser.error(message)


class BadConfig(ValueError):
    """Problem with config file"""


class ConfigParser:
    """Read configuration file"""
    books: dict[str, Book] = {}
    starred: list[str] = []
    curr: Book | None = None
    line_num: int
    line: str
    mobj: re.Match | None

    def __init__(self, known_scales: Container[str]):
        self.known_scales = known_scales

    def match(self, expr: str) -> bool:
        """Handy wrapper around `re.fullmatch` for the current line"""
        self.mobj = re.fullmatch(expr, self.line)
        return bool(self.mobj)

    def group(self, group: int | str) -> str:
        """Group from previous `self.match()`."""
        assert self.mobj is not None
        return self.mobj.group(group)

    PART_RE = r"(?P<at>(?P<num>[1-9]\d*)?@)?(?P<book>\S+)"

    def parse(self, stream: TextIO) -> "Configuration":
        """Read configuration file"""
        for self.line_num, line in enumerate(stream, 1):
            self.line = re.sub(r"\s*(#.*)?$", "", line)

            if self.match(r"([*]?)(\S[^:]*):"):
                self.enter_book(name=self.group(2).strip(), star=self.group(1))
            elif self.match(r"\s+([^:]*):\s+(.*)"):
                self.add_etude(
                    name=self.group(1).strip(),
                    description=self.group(2).strip(),
                )
            elif self.match(f"\\s+{self.PART_RE}\\s*") and self.group("at"):
                self.add_ref()
            elif self.match(r"(?P<name>[^=]*)\s*=\s*{(?P<parts>[^}]*)}"):
                self.add_one_liner(sequential=False)
            elif self.match(r"(?P<name>[^=]*)\s*=\s*\[(?P<parts>[^]]*)\]"):
                self.add_one_liner(sequential=True)
            elif not self.match(r""):
                raise BadConfig(f"Bad line {self.line_num}: {repr(self.line)}")

        return Configuration(
            books=self.books,
            starred=self.starred or list(self.books),
        )

    def enter_book(self, name: str, star: str) -> None:
        """Found a book line"""
        if name in self.books:
            raise BadConfig(f"Duplicate name: {repr(name)}")

        self.books[name] = self.books[name] = self.curr = Book([])
        if star == "*":
            self.starred.append(name)

    def add_etude(self, name: str, description: str) -> None:
        """Found an etude line"""
        if self.curr is None:
            raise BadConfig(f"Bookless etude in line {self.line_num}")

        if name and name[0] in "'\"" and name[-1] == name[0]:
            name = name[1:-1]

        if re.fullmatch(r"({[^}]*}\s*)+", description.strip()):
            parts = [
                substr[1:-1]
                for substr in re.findall(r"{[^}]*}", description)
            ]
        else:
            parts = [description]

        num_placeholders = len(re.findall(r"{}", name)) or 1
        if len(parts) != num_placeholders:
            raise BadConfig(f"Placeholder mismatch in line {self.line_num}")

        pools = []
        for part in parts:
            if part in self.known_scales:
                pools.append(Pool(part))
            else:
                pools.append(Pool([key.strip() for key in part.split("|")]))
        self.curr.append(Etude(name=name, pools=pools))

    def add_ref(self) -> None:
        """Add book reference line (in self.mobj)"""
        if self.curr is None:
            raise BadConfig(f"Bookless reference in line {self.line_num}")
        assert self.mobj is not None
        self.add_ref_to(self.curr.toc, self.mobj)

    def add_one_liner(self, sequential: bool) -> None:
        """A one-liner is in `self.group("name" | "parts")`"""
        name = self.group("name").strip()
        if (starred := name.startswith("*")):
            name = name[1:]
        if name in self.books:
            raise BadConfig(f"Duplicate {repr(name)} (line {self.line_num})")

        parts = self.group("parts").split()
        if not parts:
            raise BadConfig(f"Empty one-liner {name} (line {self.line_num})")

        toc: TableOfContents = []
        for part in parts:
            if not (mobj := re.fullmatch(self.PART_RE, part)):
                raise BadConfig(f"Bad {repr(part)} (line {self.line_num})")
            self.add_ref_to(toc, mobj)
        self.books[name] = Book(toc=toc, sequential=sequential)

        if starred:
            self.starred.append(name)

    def add_ref_to(self, toc: TableOfContents, mobj: re.Match):
        """Add book reference to a give TOC"""
        if (nstr := mobj.group("num")):
            num = int(nstr)
        elif mobj.group("at"):
            num = 1
        else:
            num = None
        toc.append(BookRef(num_etudes=num, name=mobj.group("book")))


if __name__ == "__main__":
    PracticeMakesPerfect().main()
