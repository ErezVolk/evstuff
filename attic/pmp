#!/usr/bin/env python3
"""Practice Makes Perfect

Assuming you have more scales, drills, licks and etudes to practice regularly
than you have time for each day, this utility will present them to you in
random order.

Sort of like spaced repetition, only _it never ends_.


About the code:

There are two different types of object identifiers:
- "label" is the name used by other parts of the system (references, config).
- "layout" is used to identify saved states.

Sometimes (e.g., in "well-known" things like the major scale), the label and
the layout are equal and human-readable ("major", etc.). Other times, the
layout is a hash of the different options, and the label is the reference
name.

Most objects also have a "blurb", which is for display purposes only.

For consistency, all of these are properties (real or @property).
"""
import argparse
from bisect import bisect
import contextlib
import csv
import dataclasses
import datetime
import graphlib
import hashlib
import io
import logging
from pathlib import Path
import plistlib
import random
import re

from collections import defaultdict
from collections.abc import Iterable
from collections.abc import Sequence
from os import PathLike
from typing import Any
from typing import NoReturn
from typing import TextIO
from typing import TypeAlias


DEFAULT_CONFIG = """
note:  # Just pick a note
  : ANY

scale:  # Play a scale
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

arp:  # Play an arpeggio
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  -major pentatonic: major
  -minor pentatonic: minor

form:
  Blues in {}: C|F|G
  {}-major scale on the {} string: {major} {E|A|D|G}
"""


__TODO__ = """
- Printable but unhashable note
- "ANY := C‖C#|Db‖D#|Eb‖...‖B" "major := C#|Db‖...‖B"
- Modes. Maybe "locrian := major@7" or "locrian :+ major@11"
  - degrees? "major := 1 2 3 4 5 6 7", "h.minor := 1 2 3- 4 5 6- 7"
  - semitones? "major := 0 2 4 5 7 8 11"? But how rule to out G-sharp major?
  - https://en.wikipedia.org/wiki/List_of_musical_scales_and_modes
  - wiki "Scale (music)": "In naming the notes of a scale, it is
    customary that each scale degree be assigned its own letter name"
- A UI to mark what was done? With a metronome? And a drone?
"""


SEP = " ‖ "
Filename: TypeAlias = str | PathLike
Label: TypeAlias = str
Layout: TypeAlias = str
Playable: TypeAlias = "Etude | BookRef"
TableOfContents: TypeAlias = list[Playable]
PitchClass: TypeAlias = tuple[str, ...]
Books: TypeAlias = dict[Label, "Book"]
Decks: TypeAlias = dict[Layout, "Deck"]

log = logging.getLogger("pmp")


class BadConfig(ValueError):
    """Problem with config file"""


class SerializationError(ValueError):
    """Raised internally when a deck cannot be restored."""


class Deck:
    """A deck of strings"""

    cards: tuple[str, ...]
    queue: list[str]
    used: bool = False
    label: Label
    layout: Layout
    preblurb: str

    MIN_SERIALIZABLE = 3

    def __init__(self, cards: Sequence[str], label="", layout=""):
        if not cards:
            raise ValueError("Empty decks not supported")
        self.cards = tuple(cards)
        if layout:
            self.layout = layout
        else:
            hashable = "\0".join(sorted(self.cards)).encode()
            hashed = hashlib.sha256(hashable).hexdigest()[:8]
            self.layout = f":{hashed}:"
        if label:
            self.label = label
        else:
            self.label = "|".join(self.cards)
        if self.layout == self.label:
            self.preblurb = f"{self.label}"
        else:
            self.preblurb = f"{self.label} ({self.layout})"
        self.queue = []

    def __len__(self) -> int:
        return len(self.cards)

    @property
    def blurb(self) -> str:
        """A description of the deck in its current state"""
        if self._midway():
            return f"{self.preblurb} {len(self.queue)} of {len(self)}"
        return f"{self.preblurb} {len(self)}"

    def _midway(self) -> bool:
        """Is a queue currently being dealt?"""
        return 0 < len(self.queue) < len(self)

    def check_serializable(self):
        """Make sure we want to serialize this deck"""
        if not self.used:
            raise SerializationError("Never drawn")
        if not self._midway():
            raise SerializationError("Starting new cycle")
        if len(self) < self.MIN_SERIALIZABLE:
            raise SerializationError("Too small")

    def serialize(self) -> dict:
        """Serialize"""
        return {
            "blurb": self.blurb,
            "label": self.label,
            "layout": self.layout,
            "queue": self.queue,
        }

    def deserialize(self, saved: object):
        """Validate and restore a saved queue"""
        if len(self) < self.MIN_SERIALIZABLE:
            raise SerializationError("Too few items to load state")
        if not isinstance(saved, dict):
            raise SerializationError("Not a dict")
        if saved.get("layout") != self.layout:
            raise SerializationError("Hash mismatch")
        queue = saved.get("queue")
        if not isinstance(queue, list):
            raise SerializationError("Not a list")
        if not queue:
            raise SerializationError("Empty list")
        if not all(isinstance(card, str) for card in queue):
            raise SerializationError("Not a list of strings")
        if not set(queue).issubset(self.cards):
            raise SerializationError("List contains unknown cards")
        self._set_queue(queue)

    def draw(self) -> str:
        """Get the next card"""
        if not self.queue:
            self._set_queue(self.cards)
        self.used = True
        return self.queue.pop()

    def peek(self, count: int) -> list[str]:
        """Draw `count` cards without affecting the queue."""
        if count < 1 or count > len(self):
            raise ValueError(f"Cannot draw {count} from {len(self)} cards")

        if count <= len(self.queue):  # Enough lined up
            return self.queue[:count]

        return random.sample(self.cards, count)

    def _set_queue(self, queue: Sequence[str]) -> None:
        """Set the queue"""
        self.queue = list(queue)
        random.shuffle(self.queue)


class NoneDeck(Deck):
    """The NONE deck doesn't really have cards, so make the blurb nicer"""

    def __init__(self):
        super().__init__(cards=[""], label="NONE", layout="NONE")

    @property
    def blurb(self) -> str:
        return "NONE"


@dataclasses.dataclass
class Etude:
    """A concrete etude, e.g., 'minor pentatonic'.

    It is a kind of template string with one or more `Deck` variables.

    `Etude.label` has the same meaning as `Deck.label`; there is no need
    for a layout member.
    """

    template: str
    decks: list[Deck]
    label: Label = dataclasses.field(init=False)
    blurb: str = dataclasses.field(init=False)

    def __post_init__(self):
        for key in ("label", "blurb"):
            vals = (getattr(deck, key) for deck in self.decks)
            setattr(self, key, f"{self.template}={SEP.join(vals)}")


@dataclasses.dataclass
class Book:
    """A collection of etudes or pointers to other books"""

    toc: TableOfContents
    sequential: bool = False
    deck: Deck = dataclasses.field(init=False)
    labels: list[Label] = dataclasses.field(init=False)
    shortlist: list[Label] = dataclasses.field(init=False)
    blurb: str = dataclasses.field(init=False)

    def draw(self) -> Playable:
        """Get the next random playable"""
        while (label := self.deck.draw()) not in self.shortlist:
            continue
        return self.toc[self.labels.index(label)]

    def num_active_etudes(self) -> int:
        """Return the number of different etudes currently drawable"""
        return len(self.shortlist)

    @contextlib.contextmanager
    def limit_etudes(self, max_etudes: int | None):
        """Select a shortlist.

        Use as context manager:
        ```
        with book.limit_etudes(3):
            book.draw()
        ```
        """
        previous = self.shortlist
        if max_etudes and 0 < max_etudes < len(self.labels):
            self.shortlist = self.deck.peek(max_etudes)
        try:
            yield
        finally:
            self.shortlist = previous

    def append(self, playable: Playable):
        """Add an entry to the TOC"""
        self.toc.append(playable)

    def finalize(self, label: Label) -> Deck:
        """(Re)create the deck"""
        self.labels = [entry.label for entry in self.toc]
        self.shortlist = self.labels
        self.deck = Deck(self.shortlist, label=label)
        parens = "[]" if self.sequential else "{}"
        self.blurb = (
            f"({self.deck.layout}) "
            f"{parens[0]}{len(self.deck)} of {len(self.toc)}{parens[1]}"
        )
        return self.deck


@dataclasses.dataclass
class BookRef:
    """A reference to a book"""

    ref_label: Label
    count: int | None = None
    book: Book = dataclasses.field(init=False)
    label: Label = dataclasses.field(init=False)
    blurb: str = dataclasses.field(init=False)

    def __post_init__(self):
        if self.count:
            self.label = f"{self.count}@{self.ref_label}"
        else:
            self.label = "={self.ref_label}"
        self.blurb = self.label


@dataclasses.dataclass
class Config:
    """The information from the config file"""

    books: Books
    starred: list[Label]


class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(description="Practice Makes Perfect")
        parser.add_argument(
            "books",
            metavar="BOOK",
            type=str,
            nargs="*",
            help=(
                "Choose books from this list; specify 'default-config' to "
                "print out the default configuration file"
            ),
        )

        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--num-tracks",
            type=int,
            help="Number of tracks (etude × key) to generate",
        )
        group.add_argument(
            "-N",
            "--one-of-each",
            action="store_true",
            help="Make one track per etude in the chosen book",
        )

        parser.add_argument(
            "-i",
            "--max-etudes",
            type=int,
            help="Use at most MAX_ETUDES different etude types",
        )
        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
            help="Always print tracks on separate lines",
        )
        parser.add_argument(
            "-d",
            "--debug",
            action="store_true",
            help="Print lots of debugging information",
        )
        parser.add_argument(
            "-c",
            "--config",
            type=Path,
            default=Path.home() / ".pmprc",
            help="Path for config file",
        )
        parser.add_argument(
            "-s",
            "--state-file",
            type=Path,
            default=Path.home() / ".pmpstate.plist",
            help="Path for state file",
        )
        parser.add_argument(
            "-r",
            "--report-file",
            type=Path,
            default=Path.home() / ".pmpreport.csv",
            help="Path for report file",
        )
        parser.add_argument(
            "-S",
            "--saveless",
            action="store_true",
            help="Don't save state/report files",
        )
        self.args = parser.parse_args()
        self.parser = parser

    PITCH_CLASSES: tuple[PitchClass, ...] = (
        ("C",),
        ("C♯", "D♭"),
        ("D",),
        ("D♯", "E♭"),
        ("E",),
        ("F",),
        ("F♯", "G♭"),
        ("G",),
        ("G♯", "A♭"),
        ("A",),
        ("A♯", "B♭"),
        ("B",),
    )

    SCALE_FIX: dict[str, dict[str, str]] = {
        "ANY": {},
        "major": {
            "G♯": "A♭",
            "D♯": "E♭",
            "A♯": "B♭",
        },
        "minor": {
            "G♭": "F♯",
            "D♭": "C♯",
            "A♭": "G♯",
        },
    }

    books: Books
    decks: Decks
    config: Config
    state: dict
    reporter: "PmpReporter"

    STATE_VERSION = "v4"

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()
        self._configure_logging()

        if self.args.books == ["default-config"]:
            log.info(DEFAULT_CONFIG)
            return

        self._make_basic_decks()
        self._configure()
        self._load_state()
        self._make_all_decks()
        self._restore_state()

        self._run_book(
            self._choose_book(),
            None if self.args.one_of_each else self.args.num_tracks,
            spaced=True,
        )
        if not self.args.saveless:
            self._save_state()

    def _configure_logging(self):
        """Set logging format(s) and level"""
        handler = logging.StreamHandler()
        formats = {
            logging.INFO: "%(message)s",
            logging.DEBUG: "DEBUG [%(module)s:%(lineno)d] %(message)s",
        }
        handler.setFormatter(LevelFormatter(formats))
        log.addHandler(handler)

        if self.args.debug:
            level = logging.DEBUG
        else:
            level = logging.INFO
        log.setLevel(level)

    def _run_book(self, book: Book, num_tracks: int | None, spaced=False):
        """Run any book"""
        if book.sequential:
            self._run_sequential(book, spaced=spaced)
        else:
            self._run_plain(book, num_tracks)

    def _run_sequential(self, book: Book, spaced: bool) -> None:
        """Run a sequence of items"""
        for entry in book.toc:
            if isinstance(entry, Etude):
                log.info(self._make_track(entry))
            else:
                self._run_book(entry.book, entry.count)
            if spaced:
                log.info("")

    def _run_plain(self, book: Book, num_tracks: int | None):
        """Run a "simple" book, choosing etudes and assigining keys"""
        with book.limit_etudes(self.args.max_etudes):
            if num_tracks is None:
                num_tracks = book.num_active_etudes()
            elif num_tracks == 0:
                num_tracks = len(self.PITCH_CLASSES)

            etude_seq = self._choose_etudes(book, num_tracks)
        track_seq = self._make_tracks(etude_seq)
        log.info(self._get_sep(track_seq).join(track_seq))

    def _choose_etudes(self, book: Book, count: int) -> Iterable[Etude]:
        """Yields chosen etudes.

        This method can call itself recursively, since we used
        `TopologicalSorter` to make sure the graph is cycle-free.
        """
        for _ in range(count):
            self.reporter.in_use(book)
            entry = book.draw()
            if isinstance(entry, Etude):
                yield entry
            else:
                yield from self._choose_etudes(entry.book, entry.count or 1)

    def _choose_book(self) -> Book:
        """Pick out a book"""
        if self.args.books:
            labels = self.args.books
            unknown = set(labels) - set(self.books)
            if unknown:
                self._fail(f"Unknown book(s): {' '.join(unknown)}")
        else:
            labels = self.config.starred
        label = random.choice(labels)
        return self.books[label]

    def _make_tracks(
        self,
        etude_seq: Iterable[Etude],
    ) -> list[str]:
        """Pick a key (or selection of keys) for each etude"""
        return [self._make_track(etude) for etude in etude_seq]

    def _make_track(self, etude: Etude) -> str:
        """Pick a key for one etude"""
        keys = []
        for deck in etude.decks:
            self.reporter.in_use(deck)
            key = deck.draw()
            if "|" in key:  # Can only come from our pitch classes
                key = random.choice(key.split("|"))
            keys.append(key)

        if "{}" not in etude.template:
            return f"{keys[0]}{etude.template}"

        parts = re.split(r"({})", etude.template)
        ikey = iter(keys)
        return "".join(next(ikey) if part == "{}" else part for part in parts)

    def _get_sep(self, tracks: list[str]) -> str:
        """Return space or newline separator"""
        if self.args.multiline:
            return "\n"
        if any(" " in track for track in tracks):
            return "\n"
        if sum(len(track) for track in tracks) + len(tracks) >= 80:
            return "\n"
        return " "

    def _make_basic_decks(self) -> None:
        """Start `self.decks` with the basic scales"""
        self.decks = {}
        for scale, fixes in self.SCALE_FIX.items():
            cards = [
                "|".join((fixes.get(note, note) for note in pitch_class))
                for pitch_class in self.PITCH_CLASSES
            ]
            self._have_deck(Deck(cards=cards, label=scale, layout=scale))
        self._have_deck(NoneDeck())
        log.debug("Key decks: %s", SEP.join(self.decks))

    def _have_deck(self, deck: Deck) -> Deck:
        """Add a deck to our records"""
        return self.decks.setdefault(deck.layout, deck)

    def _configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self._parse_config(self.args.config, fobj)
        except (FileNotFoundError, ValueError):
            self.config = self._parse_config("", io.StringIO(DEFAULT_CONFIG))
        self.reporter = PmpReporter(self.args.report_file)
        self.books = self.config.books
        self._finalize_books()

    def _load_state(self) -> None:
        """Read saved state info `self.state`"""
        try:
            with open(self.args.state_file, "rb") as fobj:
                loaded = plistlib.load(fobj)
            self.state = loaded[self.STATE_VERSION]
        except (FileNotFoundError, plistlib.InvalidFileException, KeyError):
            self.state = {}
        self.state.setdefault("deck", {})

    def _save_state(self) -> None:
        """Save the queue state"""
        saveds = self.state["deck"]
        for layout in saveds.keys() - self.decks.keys():
            self.reporter.deck_gone(layout, saveds.pop(layout))

        used = []
        for layout, deck in self.decks.items():
            try:
                deck.check_serializable()
                saveds[layout] = deck.serialize()
                used.append(deck.blurb)
            except SerializationError as exc:
                log.debug("Not serializing %s: %s", deck.blurb, exc)
        if used:
            log.debug("Saving %d: %s", len(used), SEP.join(used))

        self.state["debug"] = self.reporter.finish(self.decks, self.books)

        with open(self.args.state_file, "wb") as fobj:
            plistlib.dump(
                {self.STATE_VERSION: self.state},
                fobj,
                sort_keys=False,
            )

    def _make_all_decks(self) -> None:
        """Make sure every deck is created and registered"""
        log.debug("All books: %s", SEP.join(self.books))
        for book in self.books.values():
            for etude in book.toc:
                if isinstance(etude, Etude):
                    etude.decks = [
                        self._have_deck(deck) for deck in etude.decks
                    ]

    def _restore_state(self) -> None:
        """Restore states for any eligible deck"""
        saveds = self.state["deck"]
        n_used = 0
        for layout in list(self.decks):
            if (saved := saveds.get(layout)) is None:
                continue
            deck = self.decks[layout]
            try:
                deck.deserialize(saved)
                log.debug(
                    "Loaded %s -> %s",
                    deck.blurb,
                    SEP.join(deck.queue),
                )
                n_used += 1
            except SerializationError as exc:
                log.debug("Forgetting saved state of %s: %s", layout, exc)
                del self.decks[layout]
        log.debug("Resuming %d of %d decks", n_used, len(self.decks))

    def _parse_config(self, filename: Filename, stream: TextIO) -> Config:
        """Read configuration file"""
        try:
            labeldecks = {deck.label: deck for deck in self.decks.values()}
            return ConfigParser(labeldecks).parse(filename, stream)
        except BadConfig as err:
            self._fail(str(err))
            raise err  # Won't happen, just to appease pyright

    def _finalize_books(self) -> None:
        """Check configured graph is legit and prepare all books for action"""
        graph = defaultdict(set)
        for label, book in self.books.items():
            for ref in book.toc:
                if isinstance(ref, BookRef):
                    graph[ref.ref_label].add(label)
                    ref.book = self.books[ref.ref_label]

        if (missing := graph.keys() - self.books.keys()):
            error = ", ".join(
                f"{label} (used by {', '.join(graph[label])})"
                for label in missing
            )
            self._fail(f"Unknown reference(s): {error}")

        try:
            order = list(graphlib.TopologicalSorter(graph).static_order())
        except graphlib.CycleError as exc:
            self._fail(f"Cyclical configuration: {' -> '.join(exc.args[1])}")

        # The hash of a book depends on the layouts of book refs in the toc
        order.extend(self.books.keys() - set(order))
        for label in reversed(order):
            book = self.books[label]
            book.deck = self._have_deck(book.finalize(label))

    def _fail(self, message: str) -> NoReturn:
        """Handy wrapper around ArgumentParser's `.fail()` method"""
        self.parser.error(message)


class ConfigParser:
    """Read configuration file"""

    books: Books = {}
    starred: list[Label] = []
    curr: Book | None = None
    line_num: int
    line: str
    mobj: re.Match | None

    def __init__(self, labeldecks: dict[Label, Deck]):
        self.labeldecks = dict(labeldecks)

    def match(self, expr: str) -> bool:
        """Handy wrapper around `re.fullmatch` for the current line"""
        self.mobj = re.fullmatch(expr, self.line)
        return bool(self.mobj)

    def group(self, group: int | str) -> str:
        """Group from previous `self.match()`."""
        assert self.mobj is not None
        return self.mobj.group(group)

    PART_RE = r"(?P<at>(?P<count>[1-9]\d*)?@)?(?P<label>\S+)"

    def parse(self, filename: Filename, stream: TextIO) -> "Config":
        """Read configuration file"""
        try:
            return self.do_parse(stream)
        except BadConfig as exc:
            raise BadConfig(f"[{filename}:{self.line_num}] {exc}") from exc

    def do_parse(self, stream: TextIO) -> "Config":
        """The actual reading function"""
        for self.line_num, line in enumerate(stream, 1):
            self.line = re.sub(r"\s*(#.*)?$", "", line)

            if self.match(r"([^:|]+):=(.*)"):
                self.add_deck(
                    label=self.group(1).strip(),
                    keys=self.group(2).strip(),
                )
            elif self.match(r"([*]?)(\S[^:]*):"):
                self.enter_book(
                    label=self.group(2).strip(),
                    star=self.group(1),
                )
            elif self.match(r"\s+([^:]*):\s+(.*)"):
                self.add_etude(
                    template=self.group(1).strip(),
                    description=self.group(2).strip(),
                )
            elif self.match(f"\\s+{self.PART_RE}\\s*") and self.group("at"):
                self.add_ref()
            elif self.match(r"(?P<label>[^=]*)\s*=\s*{(?P<parts>[^}]*)}"):
                self.add_one_liner(sequential=False)
            elif self.match(r"(?P<label>[^=]*)\s*=\s*\[(?P<parts>[^]]*)\]"):
                self.add_one_liner(sequential=True)
            elif not self.match(r""):
                raise BadConfig(f"Bad line: {repr(self.line)}")

        return Config(
            books=self.books,
            starred=self.starred or list(self.books),
        )

    def enter_book(self, label: Label, star: str) -> None:
        """Found a book line"""
        if label in self.books:
            raise BadConfig(f"Duplicate book: {repr(label)}")

        self.books[label] = self.books[label] = self.curr = Book([])
        if star == "*":
            self.starred.append(label)

    def add_deck(self, label: str, keys: str) -> None:
        """Found a deck line, e.g.,

        easy-major := C|F|G
        """
        if label in self.labeldecks:
            raise BadConfig(f"Duplicate deck: {repr(label)}")

        cards = [key.strip() for key in keys.split("|")]
        self.labeldecks[label] = Deck(label=label, cards=cards)

    def add_etude(self, template: str, description: str) -> None:
        """Found an etude line"""
        if self.curr is None:
            raise BadConfig("Bookless etude")

        if template and template[0] in "'\"" and template[-1] == template[0]:
            template = template[1:-1]

        parts = self._description_to_parts(description)
        num_placeholders = len(re.findall(r"{}", template)) or 1
        if len(parts) != num_placeholders:
            raise BadConfig("Placeholder mismatch")

        decks: list[Deck] = []
        for part in parts:
            try:
                decks.append(self.labeldecks[part])
            except KeyError:
                decks.append(Deck([key.strip() for key in part.split("|")]))
        self.curr.append(Etude(template=template, decks=decks))

    def _description_to_parts(self, description: str) -> list[str]:
        """Parse an etude description"""
        if not re.fullmatch(r"({[^}]*}\s*)+", description):
            return [description]
        return [part[1:-1] for part in re.findall(r"{[^{}]*}", description)]

    def add_ref(self) -> None:
        """Add book reference line (in self.mobj)"""
        if self.curr is None:
            raise BadConfig("Bookless reference")
        assert self.mobj is not None
        self.add_ref_to(self.curr.toc, self.mobj)

    def add_one_liner(self, sequential: bool) -> None:
        """A one-liner is in `self.group("label" | "parts")`"""
        label = self.group("label").strip()
        starred = label.startswith("*")
        if starred:
            label = label[1:]
        if label in self.books:
            raise BadConfig(f"Duplicate book {repr(label)}")

        parts = self.group("parts").split()
        if not parts:
            raise BadConfig(f"Empty one-liner {label}")

        toc: TableOfContents = []
        for part in parts:
            if not (mobj := re.fullmatch(self.PART_RE, part)):
                raise BadConfig(f"Bad {repr(part)}")
            self.add_ref_to(toc, mobj)
        self.books[label] = Book(toc=toc, sequential=sequential)

        if starred:
            self.starred.append(label)

    def add_ref_to(self, toc: TableOfContents, mobj: re.Match):
        """Add book reference to a given TOC"""
        nstr = mobj.group("count")
        if nstr:
            count = int(nstr)
        elif mobj.group("at"):
            count = 1
        else:
            count = None
        toc.append(BookRef(count=count, ref_label=mobj.group("label")))


class PmpReporter:
    """In charge of debug and statistics"""

    path: Path
    debug: dict[str, Any]
    report: dict[Layout, dict]
    now: str
    then: str

    def __init__(self, report_file: Path):
        self.now = str(now := datetime.date.today())
        self.then = str(now - datetime.timedelta(days=30))
        self.debug = {"gone": {}}
        self.path = report_file
        self._read()

    def _read(self) -> None:
        """Read the old report, or create an empty one"""
        try:
            with open(self.path, encoding="utf-8", newline="") as csvfo:
                self.report = {
                    row["layout"]: row for row in csv.DictReader(csvfo)
                }
        except (FileNotFoundError, ValueError, KeyError, csv.Error):
            self.report = {}
        log.debug("Read %s (N = %d)", self.path, len(self.report))

    def _row(self, label: Label, layout: Layout) -> dict:
        """Get the report row for a deck"""
        try:
            return self.report[layout]
        except KeyError:
            self.report[layout] = row = {"label": label, "layout": layout}
            return row

    def _deck_row(self, deck: Deck) -> dict:
        """Get the report row for a deck"""
        return self._row(label=deck.label, layout=deck.layout)

    def in_use(self, drawable: Deck | Book) -> None:
        """Note that something has been used in the present run"""
        deck = drawable if isinstance(drawable, Deck) else drawable.deck
        row = self._deck_row(deck)
        row["used"] = self.now
        row["length"] = len(deck)
        row["blurb"] = deck.blurb
        try:
            row["drawn"] = int(row["drawn"]) + 1
        except (KeyError, ValueError):
            row["drawn"] = 1
        row.pop("gone", None)

    def deck_gone(self, layout: Layout, serialized: dict) -> None:
        """A deck serialized in a previous run is no more."""
        row = self._row(layout=layout, label=serialized.get("label", "N/A"))
        row["gone"] = self.now
        self.debug["gone"] = serialized
        try:
            row["blurb"] = description = serialized["blurb"]
        except (KeyError, TypeError):
            description = layout
        log.debug("%s is gone", description)

    def finish(self, decks: Decks, books: Books) -> dict[str, str]:
        """Make the stuff that goes in the debug part of the state"""
        self._write()
        self.debug["n_decks"] = len(decks)
        self.debug["decks"] = {
            layout: deck.blurb for layout, deck in decks.items()
        }
        self.debug["n_books"] = len(books)
        self.debug["books"] = {
            f"{label} {book.blurb}": [entry.blurb for entry in book.toc]
            for label, book in books.items()
        }
        return self.debug

    def _write(self) -> None:
        """Write the updated report"""
        rows = [
            row
            for row in self.report.values()
            if (row.get("used") or row.get("gone") or self.then) >= self.then
        ]
        colset = set.union(*[set(row) for row in rows])
        cols = ["label", "layout"] + sorted(colset - {"label", "layout"})

        log.debug("Write %s (N = %d)", self.path, len(self.report))
        with open(self.path, "w", encoding="utf-8", newline="") as csvfo:
            rows = sorted(rows, key=lambda row: row["label"])
            writer = csv.DictWriter(csvfo, fieldnames=cols)
            writer.writeheader()
            for row in rows:
                writer.writerow(row)


class LevelFormatter(logging.Formatter):
    """Adapted from https://stackoverflow.com/questions/14844970

    ```
    log = logging.getLogger("hey")
    handler = logging.StreamHandler()
    handler.setFormatter(LevelFormatter({
        logging.INFO: "%(message)s",
        logging.DEBUG: "DEBUG [%(module)s:%(lineno)d] %(message)s",
    }))
    log.setLevel(logging.INFO)
    log.addHandler(handler)
    ```
    """

    def __init__(self, formats: dict[int, str], **kwargs):
        super().__init__()

        if "fmt" in kwargs:
            raise ValueError("Use formats=, not fmt=")

        self.formats = sorted(
            (level, logging.Formatter(fmt, **kwargs))
            for level, fmt in formats.items()
        )

    def format(self, record: logging.LogRecord) -> str:
        idx = bisect(self.formats, (record.levelno,), hi=len(self.formats) - 1)
        _, formatter = self.formats[idx]
        return formatter.format(record)


if __name__ == "__main__":
    PracticeMakesPerfect().main()
