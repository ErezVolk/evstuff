#!/usr/bin/env python3
"""Practice Makes Perfect"""
import argparse
from dataclasses import dataclass
import io
from pathlib import Path
import random
import re
from collections.abc import Iterable
import typing

T = typing.TypeVar("T")

NSETS = (
    ("C"),
    ("C♯", "D♭"),
    ("D"),
    ("D♯", "E♭"),
    ("E"),
    ("F"),
    ("F♯", "G♭"),
    ("G"),
    ("G♯", "A♭"),
    ("A"),
    ("A♯", "B♭"),
    ("B"),
)

SCALE_FIX = {
    "ANY": {},
    "major": {
        "G♯": "A♭",
        "D♯": "E♭",
        "A♯": "B♭",
    },
    "minor": {
        "G♭": "F♯",
        "D♭": "C♯",
        "A♭": "G♯",
        # "A♯": "B♭",  (according to Wikipedia)
    }
}

DEFAULT_CONFIG = """
note:
  : ANY

scale:
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

mode:
  ' ionian': ionian
  ' dorian': dorian
  ' phrygian': phrygian
  ' lydian': lydian
  ' mixolydian': mixolydian
  ' aeolian': aeolian
  ' locrian': locrian

arp:
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  ' major pentatonic': major
  ' minor pentatonic': minor
"""


@dataclass
class DrillItem:
    name: str
    scale: str


Drill: typing.TypeAlias = list[DrillItem]


@dataclass
class Configuration:
    drills: dict[str, Drill]
    defaults: list[str]


def main():
    """Practice Makes Perfect"""
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "drill",
        nargs="?",
    )
    parser.add_argument(
        "-n",
        "--count",
        type=int,
        default=len(NSETS),
    )
    parser.add_argument(
        "-c",
        "--config",
        type=Path,
        default=Path.home() / ".pmprc",
    )
    args = parser.parse_args()

    if args.drill == "default-config":
        print(DEFAULT_CONFIG)
        return

    add_modes()

    try:
        with open(args.config, "r", encoding="UTF-8") as fobj:
            config = parse_config(fobj)
    except (FileNotFoundError, ValueError):
        config = parse_config(io.StringIO(DEFAULT_CONFIG))
    drills = config.drills

    drill_name = args.drill
    if not drill_name:
        drill_name = random.choice(config.defaults)
        if len(config.defaults) > 1:
            print(f"[{drill_name} × {args.count}]")
    elif drill_name not in drills:
        raise ValueError(f"Unknown entity {repr(drill_name)}")

    n = args.count
    all_items = drills[drill_name]
    nsets = choose(NSETS, min(n, len(NSETS)))
    items = choose(all_items, len(nsets))
    nset_items = list(zip(nsets, items))
    if (n := n - len(nset_items)) > 0:
        all_nset_items = {(nset, item) for nset in NSETS for item in all_items}
        other_nset_items = all_nset_items - set(nset_items)
        if len(other_nset_items) > 0:
            nset_items.extend(choose(
                other_nset_items,
                min(n, len(other_nset_items))
            ))
        if (n := n - len(nset_items)) > 0:
            nset_items.extend(choose(all_nset_items, n))
    nitems = [
        "".join([choose_note(nset, item.scale), item.name])
        for nset, item in nset_items
    ]
    random.shuffle(nitems)
    spaceless = all(" " not in nitem for nitem in nitems)
    if spaceless and len(one_line := " ".join(nitems)) < 80:
        print(one_line)
    else:
        print("\n".join(nitems))


def add_modes():
    """Add the Greek modes and their hypotheticals"""
    NOTES = "CDEFGAB"
    MODES = [
        "ionian",
        "dorian",
        "phrygian",
        "lydian",
        "mixolydian",
        "aeolian",
        "locrian",
    ]
    MODEL = SCALE_FIX["major"]

    for offset, mode in enumerate(MODES):
        mapping = {
            note: NOTES[(idx + offset) % len(NOTES)]
            for idx, note in enumerate(NOTES)
        }

        def modify(note: str) -> str:
            try:
                return mapping[note[0]] + note[1:]
            except KeyError:
                return note

        SCALE_FIX[mode] = {
            modify(key): modify(value)
            for key, value in MODEL.items()
        }


def choose_note(nset, scale: str) -> str:
    """Choose one way of spelling a note"""
    note = random.choice(nset)
    return SCALE_FIX[scale].get(note, note)


def choose(options: Iterable[T], n: int) -> list[T]:
    """Choose so we have as many "full" repetitions and a random tail"""
    opts = list(options)
    nopts = len(opts)

    if n <= nopts:
        return random.sample(opts, max(n, 1))

    ntail = n % nopts
    n_full_rounds = (n - ntail) // nopts

    choices = (opts * n_full_rounds) + random.sample(opts, ntail)
    return choices


def parse_config(stream: typing.TextIO) -> Configuration:
    SCALE_RE = "|".join(SCALE_FIX)
    drills = {}
    defaults = []
    curr: Drill | None = None
    for nline, line in enumerate(stream, 1):
        line = re.sub(r"\s*(#.*)?$", "", line)

        def match(expr):
            return re.fullmatch(expr, line)

        if (mobj := match(r"([*]?)(\S[^:]*):")):
            name = mobj.group(2).strip()
            drills[name] = curr = Drill([])
            if mobj.group(1) == "*":
                defaults.append(name)
        elif (mobj := match(r"\s+([^:]*):\s+(" + SCALE_RE + ")")):
            if curr is None:
                raise ValueError(f"Key without section in line {nline}")
            name = mobj.group(1).strip()
            if name and name[0] in ["'", '"'] and name[-1] == name[0]:
                name = name[1:-1]
            curr.append(DrillItem(
                name=name,
                scale=mobj.group(2).strip()
            ))
        elif not match(r""):
            raise ValueError(f"Cannot parse line {nline}")
    return Configuration(
        drills=drills,
        defaults=defaults or list(drills),
    )


if __name__ == "__main__":
    main()
