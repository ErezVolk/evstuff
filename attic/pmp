#!/usr/bin/env python3
"""Practice Makes Perfect"""
# TODO: Consistent nomenclature
import argparse
from dataclasses import dataclass
import io
import itertools
from pathlib import Path
import random
import re
import shlex

from collections.abc import Iterable
import typing


@dataclass
class DrillItem:
    """A single drill item, e.g., 'minor pentatonic'"""
    name: str
    field: str | list[str]


DrillItems: typing.TypeAlias = list["DrillItem | Drill"]


@dataclass
class Drill:
    """Basically a list of items"""
    items: DrillItems


NoteSet: typing.TypeAlias = tuple[str] | tuple[str, str]


@dataclass
class MetaDrill:
    """A drill that just an amalamation of other drills"""
    nline: int
    allsies: set[str]
    onesies: set[str]


@dataclass
class Configuration:
    """The information from the config file"""
    drills: dict[str, Drill]
    defaults: list[str]
    cli: str


DEFAULT_CONFIG = """
note:
  : ANY

scale:
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

mode:
  ' ionian': ionian
  ' dorian': dorian
  ' phrygian': phrygian
  ' lydian': lydian
  ' mixolydian': mixolydian
  ' aeolian': aeolian
  ' locrian': locrian

arp:
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  ' major pentatonic': major
  ' minor pentatonic': minor
"""


class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace
    config: Configuration

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(
            description="Practice Makes Perfect"
        )
        parser.add_argument(
            "drill",
            nargs="?",
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--count",
            type=int,
        )
        group.add_argument(
            "-N",
            "--one-per-item",
            action="store_true",
        )
        parser.add_argument(
            "-i",
            "--max-items",
            type=int,
        )
        parser.add_argument(
            "-d",
            "--drill-set",
            metavar="DRILL",
            type=str,
            nargs="*",
        )
        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
        )
        parser.add_argument(
            "-v",
            "--verbose",
            action="store_true",
        )
        parser.add_argument(
            "-c",
            "--config",
            type=Path,
            default=Path.home() / ".pmprc",
        )
        self.args = parser.parse_args()
        self.parser = parser

    T = typing.TypeVar("T")

    _NOTES = "CDEFGAB"
    _MODES = (
        "ionian",
        "dorian",
        "phrygian",
        "lydian",
        "mixolydian",
        "aeolian",
        "locrian",
    )

    NSETS: list[NoteSet] = [
        ("C",),
        ("C♯", "D♭"),
        ("D",),
        ("D♯", "E♭"),
        ("E",),
        ("F",),
        ("F♯", "G♭"),
        ("G",),
        ("G♯", "A♭"),
        ("A",),
        ("A♯", "B♭"),
        ("B",),
    ]

    SCALE_FIX: dict[str, dict[str, str]] = {
        "NONE": {},
        "ANY": {},
        "major": {
            "G♯": "A♭",
            "D♯": "E♭",
            "A♯": "B♭",
        },
        "minor": {
            "G♭": "F♯",
            "D♭": "C♯",
            "A♭": "G♯",
            # "A♯": "B♭",  (according to Wikipedia)
        }
    }

    DEFAULT_CLI = f"--count {len(NSETS)}"

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()

        if self.args.drill == "default-config":
            print(DEFAULT_CONFIG)
            return

        self.add_modes()
        self.configure()

        drills = self.config.drills

        drill_name = self.args.drill
        report_drill = False
        if drill_name:
            if drill_name not in drills:
                self.fail(f"Unknown entity {repr(drill_name)}")
        else:
            drill_set = self.args.drill_set or self.config.defaults
            drill_name = random.choice(drill_set)
            if len(self.config.defaults) > 1:
                report_drill = True

        try:
            all_items = drills[drill_name].items
        except KeyError:
            self.fail(f"Unknown drill specified: {drill_name}")
        if self.args.max_items and len(all_items) > self.args.max_items:
            all_items = random.sample(all_items, self.args.max_items)

        if self.args.one_per_item:
            nchoices = len(all_items)
        else:
            nchoices = min(self.args.count, len(drills))

        if self.args.verbose or report_drill:
            print(f"[{drill_name} × {nchoices}]")

        nsets = self.choose(self.NSETS, min(nchoices, len(self.NSETS)))
        items = self.choose(all_items, len(nsets))
        nset_items = list(zip(nsets, items))
        if (nchoices := nchoices - len(nset_items)) > 0:
            all_nset_items = set(itertools.product(self.NSETS, all_items))
            other_nset_items = all_nset_items - set(nset_items)
            if len(other_nset_items) > 0:
                nset_items.extend(self.choose(
                    other_nset_items,
                    min(nchoices, len(other_nset_items))
                ))
            if (nchoices := nchoices - len(nset_items)) > 0:
                nset_items.extend(self.choose(all_nset_items, nchoices))

        named_items = [
            self.make_named_item(nset, item)
            for nset, item in nset_items
        ]
        random.shuffle(named_items)

        print(self.get_sep(named_items).join(named_items))

    def get_sep(self, named_items: list[str]) -> str:
        """Return space or newline separator"""
        if self.args.multiline:
            return "\n"
        if any(" " not in nitem for nitem in named_items):
            return "\n"
        if sum(len(nitem) for nitem in named_items) + len(named_items) >= 80:
            return "\n"
        return " "

    def make_named_item(self, nset, item: DrillItem | Drill) -> str:
        """Created named item, e.g., 'C-major'."""
        if isinstance(item, Drill):
            item = random.choice(item.items)

        assert isinstance(item, DrillItem)
        if item.field == "NONE":
            return item.name

        if isinstance(item.field, list):
            member = random.choice(item.field)
        else:
            member = self.choose_note(nset, item.field)

        return member + item.name

    def add_modes(self) -> None:
        """Add the Greek modes and their hypotheticals to our known scales"""
        model = self.SCALE_FIX["major"]
        mapping: dict[str, str]

        for offset, mode in enumerate(self._MODES):
            mapping = {
                note: self._NOTES[(idx + offset) % len(self._NOTES)]
                for idx, note in enumerate(self._NOTES)
            }

            def modify(note: str) -> str:
                try:
                    return mapping[note[0]] + note[1:]
                except KeyError:
                    return note

            self.SCALE_FIX[mode] = {
                modify(key): modify(value)
                for key, value in model.items()
            }

    def choose_note(self, nset: NoteSet, scale: str) -> str:
        """Choose one way of spelling a note (e.g., C♯ or D♭")."""
        note = random.choice(nset)
        return self.SCALE_FIX[scale].get(note, note)

    def choose(self, options: Iterable[T], nchoices: int) -> list[T]:
        """Choose so we have as many "full" repetitions and a random tail"""
        opts = list(options)
        nopts = len(opts)

        if nchoices <= nopts:
            return random.sample(opts, max(nchoices, 1))

        ntail = nchoices % nopts
        n_full_rounds = (nchoices - ntail) // nopts

        choices = (opts * n_full_rounds) + random.sample(opts, ntail)
        return choices

    def configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self.parse_config(fobj)
        except (FileNotFoundError, ValueError):
            self.config = self.parse_config(io.StringIO(DEFAULT_CONFIG))
        for cli in (self.config.cli, self.DEFAULT_CLI):
            new_args = self.parser.parse_args(shlex.split(cli))
            for key, val in vars(self.args).items():
                if val is None:
                    if (new_val := getattr(new_args, key)):
                        setattr(self.args, key, new_val)

    def parse_config(self, stream: typing.TextIO) -> Configuration:
        """Read configuration file"""
        drills: dict[str, Drill] = {}
        metas: dict[str, MetaDrill] = {}
        defaults = []
        curr: Drill | None = None
        line: str
        cli: str = ""

        def match(expr: str) -> re.Match | None:
            return re.fullmatch(expr, line)

        for nline, line in enumerate(stream, 1):
            line = re.sub(r"\s*(#.*)?$", "", line)

            if (mobj := match(r"cli:\s+(.*)")):
                cli = mobj.group(1).strip()
            elif (mobj := match(r"([*]?)(\S[^:]*):")):
                name = mobj.group(2).strip()
                drills[name] = curr = Drill([])
                if mobj.group(1) == "*":
                    defaults.append(name)
            elif (mobj := match(r"\s+([^:]*):\s+(.*)")):
                if curr is None:
                    self.fail(f"Key without section in line {nline}")
                name = mobj.group(1).strip()
                if name and name[0] in ["'", '"'] and name[-1] == name[0]:
                    name = name[1:-1]
                field = mobj.group(2).strip()
                if field in self.SCALE_FIX:
                    curr.items.append(DrillItem(name=name, field=field))
                else:
                    choices = [choice.strip() for choice in field.split("|")]
                    curr.items.append(DrillItem(name=name, field=choices))
            elif (mobj := match(r"([^=]*)\s*=\s*{([^}]*)}")):
                name = mobj.group(1).strip()
                members = {drill.strip() for drill in mobj.group(2).split()}
                if not members:
                    self.fail(f"No drill in {name} (line {nline})")
                allsies = {one for one in members if not one.startswith("@")}
                onesies = {one[1:] for one in members - allsies}
                metas[name] = MetaDrill(
                    nline=nline,
                    allsies=allsies,
                    onesies=onesies,
                )
            elif not match(r""):
                self.fail(f"Cannot parse line {nline}: {repr(line)}")

        # Now add the metas; check the names first to avoid loops
        known = set(drills)
        for name, meta in metas.items():
            unknown = (meta.allsies | meta.onesies) - known
            if unknown:
                unks = " ".join(unknown)
                self.fail(
                    f"Unknown drill(s) on line {meta.nline}: "
                    f"{unks} in meta {name}"
                )

        for name, meta in metas.items():
            items: DrillItems = [drills[onesie] for onesie in meta.onesies]
            for allsie in meta.allsies:
                items.extend(drills[allsie].items)
            drills[name] = Drill(items)

        return Configuration(
            drills=drills,
            defaults=defaults or list(drills),
            cli=cli,
        )

    def fail(self, message: str) -> typing.NoReturn:
        """Handy wrapper around ArgumentParser's fail method"""
        self.parser.error(message)


if __name__ == "__main__":
    PracticeMakesPerfect().main()
