#!/usr/bin/env python3
"""Practice Makes Perfect"""
import argparse
from dataclasses import dataclass
import io
import itertools
from pathlib import Path
import random
import re
import shlex

from collections.abc import Iterable
import typing


@dataclass
class DrillItem:
    """A single drill item, e.g., 'minor pentatonic'"""
    name: str
    field: str | list[str]


Drill: typing.TypeAlias = list[DrillItem]
NoteSet: typing.TypeAlias = tuple[str] | tuple[str, str]


@dataclass
class Configuration:
    """The information from the config file"""
    drills: dict[str, Drill]
    defaults: list[str]
    cli: str


DEFAULT_CONFIG = """
note:
  : ANY

scale:
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

mode:
  ' ionian': ionian
  ' dorian': dorian
  ' phrygian': phrygian
  ' lydian': lydian
  ' mixolydian': mixolydian
  ' aeolian': aeolian
  ' locrian': locrian

arp:
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  ' major pentatonic': major
  ' minor pentatonic': minor
"""


class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace
    config: Configuration

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(
            description="Practice Makes Perfect"
        )
        parser.add_argument(
            "drill",
            nargs="?",
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--count",
            type=int,
        )
        group.add_argument(
            "-N",
            "--one-per-item",
            action="store_true",
        )
        parser.add_argument(
            "-i",
            "--max-items",
            type=int,
        )
        parser.add_argument(
            "-d",
            "--drill-set",
            metavar="DRILL",
            type=str,
            nargs="*",
        )
        parser.add_argument(
            "-c",
            "--config",
            type=Path,
            default=Path.home() / ".pmprc",
        )
        self.args = parser.parse_args()
        self.parser = parser

    T = typing.TypeVar("T")

    _NOTES = "CDEFGAB"
    _MODES = (
        "ionian",
        "dorian",
        "phrygian",
        "lydian",
        "mixolydian",
        "aeolian",
        "locrian",
    )

    NSETS: list[NoteSet] = [
        ("C",),
        ("C♯", "D♭"),
        ("D",),
        ("D♯", "E♭"),
        ("E",),
        ("F",),
        ("F♯", "G♭"),
        ("G",),
        ("G♯", "A♭"),
        ("A",),
        ("A♯", "B♭"),
        ("B",),
    ]

    SCALE_FIX: dict[str, dict[str, str]] = {
        "NONE": {},
        "ANY": {},
        "major": {
            "G♯": "A♭",
            "D♯": "E♭",
            "A♯": "B♭",
        },
        "minor": {
            "G♭": "F♯",
            "D♭": "C♯",
            "A♭": "G♯",
            # "A♯": "B♭",  (according to Wikipedia)
        }
    }

    DEFAULT_CLI = f"--count {len(NSETS)}"

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()

        if self.args.drill == "default-config":
            print(DEFAULT_CONFIG)
            return

        self.add_modes()
        self.configure()

        drills = self.config.drills

        drill_name = self.args.drill
        report_drill = False
        if drill_name:
            if drill_name not in drills:
                self.fail(f"Unknown entity {repr(drill_name)}")
        else:
            drill_set = self.args.drill_set or self.config.defaults
            drill_name = random.choice(drill_set)
            if len(self.config.defaults) > 1:
                report_drill = True

        all_items = drills[drill_name]
        if self.args.max_items and len(all_items) > self.args.max_items:
            all_items = random.sample(all_items, self.args.max_items)

        if self.args.one_per_item:
            n = len(all_items)
        else:
            n = min(self.args.count, len(drills))

        if report_drill:
            print(f"[{drill_name} × {n}]")

        nsets = self.choose(self.NSETS, min(n, len(self.NSETS)))
        items = self.choose(all_items, len(nsets))
        nset_items = list(zip(nsets, items))
        if (n := n - len(nset_items)) > 0:
            all_nset_items = set(itertools.product(self.NSETS, all_items))
            other_nset_items = all_nset_items - set(nset_items)
            if len(other_nset_items) > 0:
                nset_items.extend(self.choose(
                    other_nset_items,
                    min(n, len(other_nset_items))
                ))
            if (n := n - len(nset_items)) > 0:
                nset_items.extend(self.choose(all_nset_items, n))

        nitems = [
            self.make_nitem(nset, item)
            for nset, item in nset_items
        ]
        random.shuffle(nitems)
        spaceless = all(" " not in nitem for nitem in nitems)
        if spaceless and len(one_line := " ".join(nitems)) < 80:
            print(one_line)
        else:
            print("\n".join(nitems))

    def make_nitem(self, nset, item: DrillItem) -> str:
        """Created named item, e.g., 'C-major'."""
        if item.field == "NONE":
            return item.name

        if isinstance(item.field, list):
            member = random.choice(item.field)
        else:
            member = self.choose_note(nset, item.field)

        return member + item.name

    def add_modes(self) -> None:
        """Add the Greek modes and their hypotheticals to our known scales"""
        model = self.SCALE_FIX["major"]
        mapping: dict[str, str]

        for offset, mode in enumerate(self._MODES):
            mapping = {
                note: self._NOTES[(idx + offset) % len(self._NOTES)]
                for idx, note in enumerate(self._NOTES)
            }

            def modify(note: str) -> str:
                try:
                    return mapping[note[0]] + note[1:]
                except KeyError:
                    return note

            self.SCALE_FIX[mode] = {
                modify(key): modify(value)
                for key, value in model.items()
            }

    def choose_note(self, nset: NoteSet, scale: str) -> str:
        """Choose one way of spelling a note (e.g., C♯ or D♭")."""
        note = random.choice(nset)
        return self.SCALE_FIX[scale].get(note, note)

    def choose(self, options: Iterable[T], n: int) -> list[T]:
        """Choose so we have as many "full" repetitions and a random tail"""
        opts = list(options)
        nopts = len(opts)

        if n <= nopts:
            return random.sample(opts, max(n, 1))

        ntail = n % nopts
        n_full_rounds = (n - ntail) // nopts

        choices = (opts * n_full_rounds) + random.sample(opts, ntail)
        return choices

    def configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self.parse_config(fobj)
        except (FileNotFoundError, ValueError):
            self.config = self.parse_config(io.StringIO(DEFAULT_CONFIG))
        for cli in (self.config.cli, self.DEFAULT_CLI):
            new_args = self.parser.parse_args(shlex.split(cli))
            for key, val in vars(self.args).items():
                if val is None:
                    if (new_val := getattr(new_args, key)):
                        setattr(self.args, key, new_val)

    def parse_config(self, stream: typing.TextIO) -> Configuration:
        """Read configuration file"""
        drills: dict[str, Drill] = {}
        defaults = []
        curr: Drill | None = None
        line: str
        cli: str = ""

        def match(expr: str) -> re.Match | None:
            return re.fullmatch(expr, line)

        for nline, line in enumerate(stream, 1):
            line = re.sub(r"\s*(#.*)?$", "", line)

            if (mobj := match(r"cli:\s+(.*)")):
                cli = mobj.group(1).strip()
            elif (mobj := match(r"([*]?)(\S[^:]*):")):
                name = mobj.group(2).strip()
                drills[name] = curr = Drill([])
                if mobj.group(1) == "*":
                    defaults.append(name)
            elif (mobj := match(r"\s+([^:]*):\s+(.*)")):
                if curr is None:
                    self.fail(f"Key without section in line {nline}")
                name = mobj.group(1).strip()
                if name and name[0] in ["'", '"'] and name[-1] == name[0]:
                    name = name[1:-1]
                field = mobj.group(2).strip()
                if field in self.SCALE_FIX:
                    curr.append(DrillItem(name=name, field=field))
                else:
                    members = [member.strip() for member in field.split("|")]
                    curr.append(DrillItem(name=name, field=members))
            elif not match(r""):
                self.fail(f"Cannot parse line {nline}: {repr(line)}")
        return Configuration(
            drills=drills,
            defaults=defaults or list(drills),
            cli=cli,
        )

    def fail(self, message: str) -> typing.NoReturn:
        self.parser.error(message)


if __name__ == "__main__":
    PracticeMakesPerfect().main()
