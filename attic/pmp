#!/usr/bin/env python3
"""Practice Makes Perfect.

Assuming you have more scales, drills, licks and etudes to practice regularly
than you have time for each day, this utility will present them to you in
random order. Sort of like spaced repetition, only _it never ends_.


About the code:
There are two different types of object identifiers:
- `x.label` is the name used by other parts of the system (references, config).
- `x.layout` is used to identify saved states.

Sometimes (in "well-known" things like the major scale), `label` and `layout`
are equal and human-readable ("major", etc.). Other times, `layout` is a hash
of the different options, and `label` is the reference name.

Most objects also have `x.blurb`, which is for display purposes only.
"""

import argparse
import collections
import csv
import datetime
import graphlib
import hashlib
import io
import logging
import plistlib
import random
import re
import shutil
import typing as t
import unicodedata as ud
from collections.abc import Iterable
from collections.abc import Sequence
from pathlib import Path
from xml.parsers.expat import ExpatError

DEFAULT_CONFIG = """
note:  # Just pick a note
  : ANY

scale:  # Play a scale
  -major: major
  -natural minor: minor

arp:  # Play an arpeggio
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major

form:
  Blues in {}: C|F|G
  {} on the {} string: {@arp} {oneString}
  Page {} in The Book: {[1,3-5,9-100]}

oneString := E|A|D|G
"""


__TODO__ = """
- "ANY := C‖C#|Db‖D#|Eb‖...‖B" "major := C#|Db‖...‖B"
- Visitor pattern (on_etude=, on_ref=)
- Build modes, e.g., "altered := minor+7", then we can only predefine major
- A UI to mark what was done? With a metronome? And a drone? (Kivy?)
- Less repetitions in "{yes|no} {up|down}" (compound them)
- Less repetitions in "{[100-200]} {a|b}"
"""

NOW = datetime.datetime.now(tz=datetime.UTC)
WIDTH = shutil.get_terminal_size().columns
SEP = " ‖ "
Filename: t.TypeAlias = str | Path
Label = t.NewType("Label", str)
Layout = t.NewType("Layout", str)
Entry: t.TypeAlias = "Etude | BookRef"
Books: t.TypeAlias = dict[Label, "Book"]
Decks: t.TypeAlias = dict[Layout, "Deck"]
Strs: t.TypeAlias = Iterable[str]
StringDict: t.TypeAlias = dict[str, t.Any]

log = logging.getLogger("pmp")
tracked: set[Layout] = set()


class ConfigError(ValueError):
    """Problem with config file."""


class SerializationError(ValueError):
    """Raised internally when a deck cannot be restored."""


class Deck:
    """A deck of strings."""

    cards: tuple[str, ...]
    queue: list[str]
    label: Label
    layout: Layout
    counts: collections.Counter
    old_layout: Layout | None = None

    EVENTS = ("drawn", "flipped", "flopped")
    _MIN_SERIALIZABLE = 3
    SERIALIZEES = frozenset(["blurb", "label", "cards", "qidxs"])

    _RANGE_RE = r"\d+(-\d+)?"
    RANGES_RE = f"\\[({_RANGE_RE},)*{_RANGE_RE}\\]"

    def __init__(self, cards: Strs, label: str = "", layout: str = "") -> None:
        self.cards = tuple(cards)
        assert self.cards, f"{label or layout!r} Empty decks not supported"
        self.label = Label(label or "|".join(self.cards))
        self.layout = Layout(layout or self._digest(self.cards))
        self.counts = collections.Counter()
        self._set_queue(self.cards)

    def _digest(self, strs: Strs) -> str:
        """Hash a list of strings, but make it reordering-stable."""
        hashee = "\0".join(sorted(strs)).encode()
        return f":{hashlib.sha256(hashee).hexdigest()[:8]}:"

    def __len__(self) -> int:
        return len(self.cards)

    @property
    def blurb(self) -> str:
        """A description of the deck in its current state."""
        if self.label == self.layout:
            return f"{self.label} @{len(self.queue)}/{len(self)}"
        return f"{self.label!r} {self.layout} @{len(self.queue)}/{len(self)}"

    def serialize(self) -> StringDict:
        """Serialize for the state file."""
        if not self.counts["drawn"]:
            raise SerializationError("Never drawn")
        if len(self) < self._MIN_SERIALIZABLE:
            raise SerializationError("Too small")
        log.debug("Serializing %s", self.blurb)
        return {key: getattr(self, key) for key in self.SERIALIZEES}

    def adapt(self, old_layout: Layout, saved: StringDict) -> None:
        """Try to salvage a modified deck (same label, different layout)."""
        if len(self) < self._MIN_SERIALIZABLE:
            raise SerializationError("Too few items to load state")

        theirs = set(old_cards := self._get_cards(saved))
        ours = set(self.cards)
        if len(theirs & ours) < self._MIN_SERIALIZABLE:
            raise SerializationError("Not enough shared cards to adapt")

        added = ours - theirs
        gone = theirs - ours
        log.debug("Adapting %s +%s -%s", self.label, added, gone)

        if not (queued := self._get_queue(saved, order=old_cards) & ours):
            raise SerializationError("No shared cards in queue")

        self._set_queue(queued | added)
        self.old_layout = old_layout
        self.counts["flopped"] += 1

    def deserialize(self, saved: StringDict) -> None:
        """Validate and restore a saved queue."""
        self._deserialize(saved, order=self._get_cards(saved))

    def _deserialize(self, saved: StringDict, order: Sequence[str]) -> None:
        """Validate and restore a saved queue, given a card ordering."""
        queue = self._get_queue(saved, order)
        if unknown := queue - set(self.cards):
            raise SerializationError(f"Saved queue contains unknown {unknown}")
        self._track("Deserializing")
        self._set_queue(queue)

    def _get_cards(self, saved: StringDict) -> Sequence[str]:
        """Validate and return the saved list of cards."""
        if not (cards := saved.get("cards")):
            raise SerializationError("No saved cards")
        if not isinstance(cards, list):
            raise SerializationError(f"cards: Not a list ({type(cards)})")
        if not all(isinstance(card, str) for card in cards):
            raise SerializationError("cards: Not a list of strings")
        return cards

    def _get_queue(self, saved: StringDict, order: Sequence[str]) -> set[str]:
        """Parse and validate saved queue idxs."""
        if (ranges := saved.get("qidxs")) in (None, "[]"):
            return set()
        if not isinstance(ranges, str):
            raise SerializationError(f"qidxs: Not a str ({type(ranges)})")
        if not re.fullmatch(self.RANGES_RE, ranges):
            raise SerializationError(f"qidxs: Not a range {ranges!r}")
        if max(idxs := self._parse_ranges(ranges)) >= len(order):
            raise SerializationError(f"{ranges!r} goes too far")
        return {order[idx] for idx in idxs}

    def predraw(self, count: int) -> None:
        """Try and make sure the next `count` cards won't have dupes."""
        if self.queue and count > len(self.queue):
            lineup = list(set(self.cards) - set(self.queue))
            random.shuffle(lineup)
            self._track("Adding %s to %s", lineup, self.queue)
            self.counts["flipped"] += 1
            self.queue = list(self.queue + lineup)

    def draw(self) -> str:
        """Get the next card."""
        self.ping()
        if not self.queue:
            self.counts["flipped"] += 1
            self._set_queue(self.cards)
        card = self.queue.pop(0)
        self._track("%d after drawing %r", len(self.queue), card)
        return card

    def ping(self) -> None:
        """Notify the deck it's being used."""
        self.counts["drawn"] += 1

    @property
    def qidxs(self) -> str:
        """Indexes in the queue."""
        ranges: list[list[int]] = []
        curr: list[int] = []
        for num in sorted(self.cards.index(card) for card in self.queue):
            if curr and num == curr[1] + 1:
                curr[1] = num
            else:
                ranges.append(curr := [num, num])
        descs = (f"{n1}-{n2}" if n2 > n1 else f"{n1}" for n1, n2 in ranges)
        return f"[{','.join(descs)}]"

    def _set_queue(self, queue: Strs) -> None:
        """Set the queue."""
        self.queue = list(queue)
        random.shuffle(self.queue)
        self._track("Queue set to %s", self.queue)

    def _parse_ranges(self, ranges: str) -> set[int]:
        """Convert a range description ("[1,5-7]") to ints ({1,5,6,7})."""
        numbers: set[int] = set()
        for rstr in ranges[1:-1].split(","):  # e.g., ["1", "5-7"]
            subs = [int(sub) for sub in rstr.split("-")]  # e.g., [1] or [5, 7]
            numbers.update(range(subs[0], subs[-1] + 1))
        return numbers

    def _track(self, fmt: str, *args: list[str] | str | int) -> None:
        """Print special tracking info if we're in the list."""
        if self.layout in tracked:
            fmt = f"{self.layout!r}: {fmt}"
            log.info(fmt, *args)


class RangeDeck(Deck):
    """Random choice from a range of numbers, e.g., "[1,3-4,15-50]"."""

    SERIALIZEES = Deck.SERIALIZEES - {"cards"}

    def __init__(self, parent: str, ranges: str) -> None:
        cards = [str(num) for num in sorted(self._parse_ranges(ranges))]
        layout = self._digest([parent, *cards])
        super().__init__(cards, label=ranges, layout=layout)

    def deserialize(self, saved: StringDict) -> None:
        """Override since cards aren't saved."""
        return self._deserialize(saved, order=self.cards)

    def _get_cards(self, saved: StringDict) -> Sequence[str]:
        """Override since cards aren't saved."""
        del saved  # Linter B Quiet
        return self.cards


class NoneDeck(Deck):
    """The NONE deck doesn't really have cards, so make the blurb nicer."""

    NAME = "NONE"

    def __init__(self) -> None:
        super().__init__([""], layout=self.NAME, label=self.NAME)

    def serialize(self) -> StringDict:
        """Override to make sure we don't try."""
        raise SerializationError("What would be the point?")

    def draw(self) -> str:
        """Override parent so we don't count these."""
        return ""

    @property
    def blurb(self) -> str:
        """Override for a nice blurb."""
        return self.NAME


class Etude:  # pylint: disable=too-few-public-methods
    """A concrete etude, e.g., '{}-minor pentatonic'.

    A template string with one or more `Deck` variables.
    """

    def __init__(self, template: str, decks: Iterable[Deck]) -> None:
        self.template = template
        self.decks = decks = list(decks)
        meat = re.sub(r"\s*\[.*\]$", "", template)
        self.label = Label(f"{meat}={SEP.join(deck.label for deck in decks)}")

    @property
    def blurb(self) -> str:
        """Current state of the etude."""
        return f"{self.template}={SEP.join(deck.blurb for deck in self.decks)}"


class Book:
    """A collection of etudes or pointers to other books."""

    toc: list[Entry]
    deck: Deck
    labels: list[Label]

    def __init__(self, label: Label, *, serial: bool = False) -> None:
        self.label = label
        self.serial = serial
        self.toc = []

    def finalize(self) -> Deck:
        """Create the deck."""
        self.labels = [entry.label for entry in self.toc]
        self.deck = Deck(cards=self.labels, label=self.label)
        return self.deck

    def draw_all(self) -> Iterable[Entry]:
        """Yield all entries in order, one by one."""
        self.deck.ping()
        yield from self.toc

    def draw_n(self, count: int) -> Iterable[Entry]:
        """Yield `count` random entries."""
        self.deck.predraw(count)
        for _ in range(count):
            yield self.toc[self.labels.index(Label(self.deck.draw()))]

    @property
    def blurb(self) -> str:
        """Book-level blurb (changes with the deck's state)."""
        return f"{self.deck.blurb} {'[]' if self.serial else '{}'}"

    def entry_blurbs(self) -> list[str]:
        """Blurbs of the entries (changes with etude states)."""
        return [entry.blurb for entry in self.toc]


class BookRef:  # pylint: disable=too-few-public-methods
    """A "pointer-style" ToC entry, e.g. "2@song"."""

    book_label: Label
    count: int | None
    book: Book
    label: Label
    blurb: str

    def __init__(self, bklb: Book | Label, count: int | None) -> None:
        if isinstance(bklb, Book):
            self.book = bklb
            bklb = self.book.label
        self.book_label = bklb
        self.count = count
        self.label = Label(f"{count}@{bklb}" if count else bklb)
        self.blurb = self.label


class Config(t.NamedTuple):
    """The information from the config file."""

    books: Books
    starred: list[Label]


class PracticeMakesPerfect:
    """Practice Makes Perfect."""

    parser: argparse.ArgumentParser
    args: argparse.Namespace

    def parse_command_line(self) -> None:
        """Command-line."""
        parser = argparse.ArgumentParser(description="Practice Makes Perfect")
        parser.add_argument(
            "books",
            metavar="BOOK",
            type=Label,
            nargs="*",
            help=(
                "Choose books from this list; specify 'default-config' to "
                "print out the default configuration file"
            ),
        )

        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--num-tracks",
            type=int,
            help="Number of tracks (etude \xD7 key) to generate",
        )
        group.add_argument(
            "-N",
            "--one-of-each",
            action="store_true",
            help="Make one track per etude in the chosen book",
        )

        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
            help="Always print tracks on separate lines",
        )
        parser.add_argument(
            "-d",
            "--debug",
            nargs="?",
            const="-",
            metavar="FILE",
            help="Print lots of debugging information",
        )
        parser.add_argument(
            "-D",
            "--track-decks",
            nargs="+",
            help="Print debugging info on specific deck",
        )
        parser.add_argument(
            "-H",
            "--home",
            type=Path,
            default=Path.home(),
            help="Look for configuration files here",
        )
        parser.add_argument("-c", "--config", type=Path, help="Config file")
        parser.add_argument("-s", "--state-file", type=Path, help="State file")
        parser.add_argument(
            "-r",
            "--report-file",
            type=Path,
            help="Report file",
        )
        parser.add_argument(
            "-S",
            "--saveless",
            action="store_true",
            help="Don't save state/report files",
        )
        self.args = args = parser.parse_args()
        args.config = args.config or args.home / ".pmprc"
        args.state_file = args.state_file or args.home / ".pmpstate.plist"
        args.report_file = args.report_file or args.home / ".pmpreport.csv"
        self.parser = parser

    LETTERS = frozenset("ABCDEFG")
    ALL_NOTES = LETTERS | {f"{let}{suf}" for let in LETTERS for suf in "♯♭𝄪𝄫"}

    SCALE_KEYS: t.ClassVar[dict[str, str]] = {  # Valid keys (no G♯-major)
        "ANY": "C‖C♯|D♭‖D‖D♯|E♭‖E‖F‖F♯|G♭‖G‖G♯|A♭‖A‖A♯|B♭‖B",
        "major": "C ‖ C♯|D♭ ‖ D ‖ E♭ ‖ E ‖ F ‖ F♯|G♭ ‖ G ‖ A♭ ‖ A ‖ B♭ ‖ B|C♭",
        "minor": "C ‖ C♯ ‖ D ‖ D♯|E♭ ‖ E ‖ F ‖ F♯ ‖ G ‖ G♯|A♭ ‖ A ‖ A♯|B♭ ‖ B",
        "ionian": "C‖C♯|D♭‖D‖E♭‖E‖F‖F♯|G♭‖G‖A♭‖A‖B♭‖B|C♭",
        "dorian": "D‖D♯|E♭‖E‖F‖F♯‖G‖G♯|A♭‖A‖B♭‖B‖C‖C♯|D♭",
        "phrygian": "E‖E♯|F‖F♯‖G‖G♯‖A‖A♯|B♭‖B‖C‖C♯‖D‖D♯|E♭",
        "lydian": "F‖F♯|G♭‖G‖A♭‖A‖B♭‖B|C♭‖C‖D♭‖D‖E♭‖E|F♭",
        "mixolydian": "G‖G♯|A♭‖A‖B♭‖B‖C‖C♯|D♭‖D‖E♭‖E‖F‖F♯|G♭",
        "aeolian": "A‖A♯|B♭‖B‖C‖C♯‖D‖D♯|E♭‖E‖F‖F♯‖G‖G♯|A♭",
        "locrian": "B‖B♯|C‖C♯‖D‖D♯‖E‖E♯|F‖F♯‖G‖G♯‖A‖A♯|B♭",
    }

    books: Books
    decks: Decks
    starred: list[Label]
    state: StringDict
    reporter: "Reporter"

    STATE_VER = "v4"

    def main(self) -> None:
        """Practice Makes Perfect."""
        self.parse_command_line()
        self._configure_logging()

        if self.args.books == ["default-config"]:
            print(DEFAULT_CONFIG)
            return

        self._make_basic_decks()
        self._configure()
        self._finalize_books()
        self._start_reporter()
        self._load_state()
        self._restore_state()

        self._run()
        if not self.args.saveless:
            self._save_state()
        log.debug("\n\n\n")

    def _header(self, text: str, level: int = 1) -> None:
        """Print a markdown-like header."""
        if level == 1:
            print(f"{text}\n{'=' * self._vlen(text)}")
        else:
            print(f"\n{text}\n{'-' * self._vlen(text)}")

    def _vlen(self, text: str) -> int:
        """Return visible Length (or an approximation thereof)."""
        chars = [c for c in text if ud.category(c)[0] in "LNPSZ"]
        wides = [c for c in chars if ud.east_asian_width(c) in "WF"]
        return len(chars) + len(wides)

    def _configure_logging(self) -> None:
        """Set logging format(s) and level."""
        if self.args.track_decks:
            tracked.update(self.args.track_decks)
        if self.args.debug is None:
            logging.basicConfig(format="INFO: %(message)s", level=logging.INFO)
            return

        if self.args.debug == "-":
            handler: logging.Handler = logging.StreamHandler()
        else:
            handler = logging.FileHandler(self.args.debug)
            handler.setLevel(logging.DEBUG)
        fmt = logging.Formatter("%(asctime)s [pmp:%(lineno)d] %(message)s")
        handler.setFormatter(fmt)
        log.addHandler(handler)
        log.setLevel(logging.DEBUG)

    def _run(self) -> None:
        """Choose, report, and run the top-level book."""
        book = self._choose_book()
        count = None if self.args.one_of_each else self.args.num_tracks
        weekday = "月火水木金土日"[NOW.weekday()]
        header = NOW.strftime(f"%Y-%m-%d {weekday} %H:%M {book.label}")
        self._header(header)
        self._run_book(BookRef(book, count), top=True)

    def _run_book(self, ref: BookRef, *, top: bool = False) -> None:
        """Run any book."""
        if ref.book.serial:
            self._run_serial(ref.book, top=top)
        else:
            self._run_plain(ref)

    def _run_serial(self, book: Book, *, top: bool = False) -> None:
        """Run a sequence of items."""
        for entry in book.draw_all():
            if top:
                self._header(entry.label, level=2)
            if isinstance(etude := entry, Etude):
                self._run_etudes([etude])
            elif isinstance(ref := entry, BookRef):
                self._run_book(ref)

    def _run_plain(self, ref: BookRef) -> None:
        """Run a "simple" book, choosing etudes and assigining keys."""
        if (count := ref.count) is None:
            count = len(ref.book.deck)
        elif count <= 0:
            count = len(self.decks[Layout("ANY")])
        self._run_etudes(self._choose_etudes(ref.book, count))

    def _choose_etudes(self, book: Book, count: int | None) -> Iterable[Etude]:
        """Yield chosen etudes.

        Recursion is safe here, since we've made sure the graph is cycle-free.
        """
        for entry in book.draw_n(count or 1):
            if isinstance(etude := entry, Etude):
                yield etude
            elif isinstance(ref := entry, BookRef):
                yield from self._choose_etudes(ref.book, ref.count)

    def _choose_book(self) -> Book:
        """Pick out a book."""
        labels = self.args.books or self.starred
        if unknown := set(labels) - self.books.keys():
            self._fail(f"Unknown book(s): {' '.join(unknown)}")
        return self.books[random.choice(labels)]

    def _make_track(self, etude: Etude) -> str:
        """Fill in the template for one etude."""
        keys = []
        for deck in etude.decks:
            key = deck.draw()
            if "|" in key:  # Can only come from our pitch classes
                key = random.choice(key.split("|"))
            if (label := Label(key.removeprefix("@"))) != key:
                (other_etude,) = self._choose_etudes(self.books[label], 1)
                key = self._make_track(other_etude)
            keys.append(key)

        if "{}" not in etude.template:
            return f"{keys[0]}{etude.template}"

        parts = re.split(r"({})", etude.template)
        ikey = iter(keys)
        return "".join(next(ikey) if part == "{}" else part for part in parts)

    def _run_etudes(self, etudes: Iterable[Etude]) -> None:
        """Choose keys for a bunch of etudes and print them."""
        tracks = [self._make_track(etude) for etude in etudes]
        txt = "\n".join(tracks)
        if not self.args.multiline:
            if " " not in txt:
                if self._vlen(txt) < WIDTH:
                    txt = " ".join(tracks)
        print(txt)

    def _make_basic_decks(self) -> None:
        """Start `self.decks` with the basic scales (major, minor, etc.)."""
        self.decks = {Layout(NoneDeck.NAME): NoneDeck()}
        for key, cardstr in self.SCALE_KEYS.items():
            self._have(Deck(cards=self._prep(cardstr), layout=key, label=key))
        log.debug("Basic decks: %s", SEP.join(self.decks))

    def _prep(self, cardstr: str) -> list[str]:
        """Split, strip, and sanity-check a known scale."""
        cards = [card.strip() for card in cardstr.split("‖")]
        notes = "|".join(cards).upper().split("|")
        assert len(notes) == len(set(notes)), f"{cardstr!r}: not unique"
        bad = frozenset(notes) - self.ALL_NOTES
        assert not bad, f"{cardstr!r}: {bad}?"
        bad = self.LETTERS - {note[0] for note in notes}
        assert not bad, f"{cardstr!r}: no {bad}"
        return cards

    def _have(self, deck: Deck) -> Deck:
        """Add a deck to our records."""
        return self.decks.setdefault(deck.layout, deck)

    def _configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with self.args.config.open(encoding="UTF-8") as fobj:
                config = self._parse_config(self.args.config, fobj)
        except (FileNotFoundError, ValueError):
            config = self._parse_config("", io.StringIO(DEFAULT_CONFIG))
        self.books = config.books
        self.starred = config.starred

    def _load_state(self) -> None:
        """Read saved deck queues state info `self.state`."""
        try:
            with self.args.state_file.open("rb") as fobj:
                self.state = plistlib.load(fobj).get(self.STATE_VER, {})
        except (FileNotFoundError, ExpatError, AttributeError):
            log.debug("Error reading %s", self.args.state_file, exc_info=True)
            self.state = {}
        if not isinstance(self.state.get("deck"), dict):
            self.state["deck"] = {}

    def _save_state(self) -> None:
        """Save queues for all decks, plus some debug info."""
        self.state["debug"] = {
            "n_decks": len(decks := self.decks.values()),
            "decks": {deck.layout: deck.blurb for deck in decks},
            "n_books": len(books := self.books.values()),
            "books": {book.blurb: book.entry_blurbs() for book in books},
        } | {
            event: [deck.blurb for deck in decks if deck.counts[event]]
            for event in Deck.EVENTS
        }
        self.state["deck"] = {deck.layout: self._save(deck) for deck in decks}

        with self.args.state_file.open("wb") as fobj:
            plistlib.dump({self.STATE_VER: self.state}, fobj, sort_keys=False)

        self.reporter.save_report(self.decks)

    def _save(self, deck: Deck) -> StringDict | str:
        """Serialize a single deck, or leave untouched."""
        try:
            return deck.serialize()
        except SerializationError as exc:
            log.debug("Not serializing %s: %s", deck.blurb, exc)
            self.state["deck"][deck.layout] = reason = str(exc)
            return reason

    def _restore_state(self) -> None:
        """Restore queues for any eligible deck."""
        nowies: dict[Layout, StringDict] = {}  # Current layouts found
        oldies: dict[Label, Layout] = {}  # Unknown layout, known label
        for layout, saved in (saveds := self.state["deck"]).items():
            if isinstance(saved, dict):
                if layout in self.decks:
                    nowies[Layout(layout)] = saved
                elif isinstance(label := saved.get("label"), str):
                    oldies[Label(label)] = layout

        n_used = 0
        for layout, deck in self.decks.items():
            try:
                if saved := nowies.get(layout):
                    deck.deserialize(saved)
                elif old_layout := oldies.get(deck.label):
                    deck.adapt(old_layout, saveds[old_layout])
                if 0 < len(loaded := deck.queue) < len(deck):
                    log.debug("Loaded %s -> %s", deck.blurb, SEP.join(loaded))
                    n_used += 1
            except SerializationError as exc:
                log.debug("Not restoring %s: %s", deck.blurb, exc)
        log.debug("Resuming %d of %d decks", n_used, len(self.decks))

    def _parse_config(self, filename: Filename, stream: t.TextIO) -> Config:
        """Read configuration file."""
        try:
            labeldecks = {deck.label: deck for deck in self.decks.values()}
            return ConfigParser(labeldecks).parse(filename, stream)
        except ConfigError as err:
            self._fail(str(err))

    def _finalize_books(self) -> None:
        """Prepare all decks for action, making sure they're unique."""
        log.debug("All books: %s", SEP.join(self.books))
        for book in self.books.values():
            book.deck = self._have(book.finalize())
            for entry in book.toc:
                if isinstance(etude := entry, Etude):
                    etude.decks = [self._have(deck) for deck in etude.decks]
                elif isinstance(ref := entry, BookRef):
                    ref.book = self.books[ref.book_label]

    def _start_reporter(self) -> None:
        """Create reporter object."""
        self.reporter = Reporter(self.args.report_file)

    def _fail(self, message: str) -> t.NoReturn:
        """Handy wrapper around `ArgumentParser.error()`."""
        self.parser.error(message)


class ConfigParser:  # pylint: disable=too-many-instance-attributes
    """Read configuration file."""

    labeldecks: dict[Label, Deck]
    books: Books
    starred: list[Label]
    curr: Book | None = None
    line_num: int
    whences: dict[Label, int]
    line: str
    mobj: re.Match | None
    deps: dict[Label, set[Label]]

    def __init__(self, labeldecks: dict[Label, Deck]) -> None:
        self.labeldecks = dict(labeldecks)
        self.whences = {label: -1 for label in labeldecks}
        self.books = {}
        self.starred = []
        self.deps = collections.defaultdict(set)

    def match(self, expr: str, line: str | None = None) -> bool:
        """Handy wrapper around `re.fullmatch` for the current line."""
        self.mobj = re.fullmatch(expr, self.line if line is None else line)
        return bool(self.mobj)

    def group(self, group: int | str) -> str:
        """Group from previous `self.match()`, and also strip it."""
        assert self.mobj is not None, "Call only after successful match()"
        return (self.mobj.group(group) or "").strip()

    PART_RE = r"(?P<at>(?P<count>[1-9]\d*)?@)?(?P<label>\S+)"

    def parse(self, filename: Filename, stream: t.TextIO) -> Config:
        """Read configuration file."""
        try:
            self.do_parse(stream)
            self.check_references()
            return Config(self.books, starred=self.starred or list(self.books))
        except ConfigError as exc:
            line = f":{self.line_num}" if self.line_num else ""
            raise ConfigError(f"[{filename}{line}] {exc}") from exc

    def do_parse(self, stream: t.TextIO) -> None:
        """Really go over the file."""
        for self.line_num, line in enumerate(stream, 1):
            self.line = re.sub(r"\s*(#.*)?$", "", line)

            if self.match(r"([^:|]+):=(.*)"):
                self.do_deck(label=self.group(1), keys=self.group(2))
            elif self.match(r"([*]?)(\S[^:]*):"):
                self.do_book(label=self.group(2), star=bool(self.group(1)))
            elif self.match(r"\s+([^:]*):\s+(.*)"):
                self.do_etude(template=self.group(1), deckstr=self.group(2))
            elif self.match(f"\\s+{self.PART_RE}\\s*") and self.group("at"):
                self.do_ref()
            elif self.match(r"(?P<label>[^=]*)\s*=\s*{(?P<parts>[^}]*)}"):
                self.do_one_liner(serial=False)
            elif self.match(r"(?P<label>[^=]*)\s*=\s*\[(?P<parts>[^]]*)\]"):
                self.do_one_liner(serial=True)
            elif self.line != "":
                raise ConfigError(f"Bad line: {self.line!r}")
        self.line_num = 0  # For any subsequent error messages

    def check_references(self) -> None:
        """Make sure all cross-references are kosher."""
        known = self.books.keys() | self.labeldecks.keys()
        if unknown := self.deps.keys() - known:
            errs = (f"[line {self.whences[unk]}] {unk!r}" for unk in unknown)
            raise ConfigError(f"Bad reference(s): {', '.join(errs)}")

        try:
            graphlib.TopologicalSorter(self.deps).prepare()
        except graphlib.CycleError as exc:
            msg = f"Cyclical config: {' -> '.join(exc.args[1])}"
            raise ConfigError(msg) from exc

    def do_book(self, label: str, *, star: bool, serial: bool = False) -> None:
        """Found a book line."""
        if (label := Label(label)) in self.books:
            raise ConfigError(f"Duplicate book: {label!r}")

        self.books[label] = self.curr = Book(label, serial=serial)
        if star:
            self.starred.append(label)

    def do_deck(self, label: str, keys: str) -> None:
        """Found a deck line, e.g., "easy-major := C|F|G"."""
        if label in self.labeldecks:
            raise ConfigError(f"Duplicate deck: {label!r}")

        cards = [key.strip() for key in keys.split("|")]
        self.labeldecks[Label(label)] = Deck(label=label, cards=cards)

    def do_etude(self, template: str, deckstr: str) -> None:
        """Found an etude line, e.g., "{}-maj: {major}" or "-min: minor}."""
        if self.curr is None:
            raise ConfigError("Bookless etude")

        if self.match(r"""(["'])(.*)(\1)""", template):
            template = self.group(2)
        num_placeholders = len(re.findall(r"{}", template)) or 1

        if self.match(r"({[^}]*}\s*)+", deckstr):
            parts = [part[1:-1] for part in re.findall(r"{[^{}]+}", deckstr)]
        else:
            parts = [deckstr]

        if (n_1 := len(parts)) != (n_2 := num_placeholders):
            raise ConfigError(f"Placeholder mismatch ({n_1} vs {n_2})")

        decks = []
        for part in parts:
            if (label := Label(part)) in self.labeldecks:
                decks.append(self.labeldecks[label])
                self.add_dep(self.curr.label, label)
            elif self.match(Deck.RANGES_RE, ranges := part.strip()):
                decks.append(RangeDeck(template, ranges))
            else:
                keys = [key.strip() for key in part.split("|")]
                decks.append(Deck(cards=keys))
                for key in keys:
                    if (target := key.removeprefix("@")) != key:
                        self.add_dep(self.curr.label, Label(target))
        self.curr.toc.append(Etude(template=template, decks=decks))

    def do_ref(self) -> None:
        """Add book reference line after `self.match(self.PART_RE)`."""
        if self.curr is None:
            raise ConfigError("Bookless reference")

        if nstr := self.group("count"):
            count = int(nstr)
        elif self.group("at"):
            count = 1
        else:
            count = None

        target = Label(self.group("label"))
        self.curr.toc.append(BookRef(target, count))
        self.add_dep(source=self.curr.label, target=target)

    def add_dep(self, source: Label, target: Label) -> None:
        """Remember a dependency."""
        self.deps[target].add(source)
        self.whences.setdefault(target, self.line_num)

    def do_one_liner(self, *, serial: bool) -> None:
        """Parse one-liner in `self.group("label" | "parts")`."""
        if not (parts := self.group("parts").split()):
            raise ConfigError("Empty one-liner")

        label = self.group("label")
        if star := label.startswith("*"):
            label = label[1:]
        self.do_book(label=label, serial=serial, star=star)
        for part in parts:
            if not self.match(self.PART_RE, line=part):
                raise ConfigError(f"Bad {part!r}")
            self.do_ref()
        self.curr = None


class Reporter:
    """In charge of the "history" CSV file."""

    path: Path
    by_layout: dict[Layout | None, dict[str, str]]
    now: str
    then: str

    def __init__(self, report_file: Path) -> None:
        """Initialize, read old report if possible."""
        self.now = str(today := NOW.date())
        self.then = str(today - datetime.timedelta(days=7))
        self.path = report_file

        try:
            default = {"label": "N/A", "layout": "N/A"}
            with self.path.open(encoding="utf-8", newline="") as csvfo:
                rows = [default | row for row in csv.DictReader(csvfo)]
            log.debug("Read %s (N = %s)", self.path, len(rows))
            self.by_layout = {Layout(row["layout"]): row for row in rows}
        except (FileNotFoundError, ValueError, KeyError, csv.Error) as exc:
            self.by_layout = {}
            log.debug("Cannot read %s: %s", report_file, exc)

    def save_report(self, decks: Decks) -> None:
        """Write report CSV to disk."""
        to_save = [self.deck_row(deck) for deck in decks.values()]
        for layout in self.by_layout.keys() - decks.keys():
            row = self.by_layout[layout]
            if (used := row.get("used")) and used >= self.then:
                row["gone"] = row.get("gone") or self.now
                to_save.append(row)
        if not to_save:
            log.debug("Nothing to write to %s", self.path)
            return

        to_save.sort(key=lambda row: row["label"].lower())
        colset = set.union(*[set(row) for row in to_save])
        cols = ["label", "layout", *sorted(colset - {"label", "layout"})]

        log.debug("Save %s (%d x %d)", self.path, len(to_save), len(cols))
        with self.path.open("w", encoding="utf-8", newline="") as csvfo:
            writer = csv.DictWriter(csvfo, fieldnames=cols)
            writer.writeheader()
            for row in to_save:
                writer.writerow(row)

    def deck_row(self, deck: Deck) -> StringDict:
        """Get or make the row for a deck."""
        rows = self.by_layout
        row = rows.pop(deck.layout, None) or rows.pop(deck.old_layout, {})
        self.update(row, deck)
        return row

    def update(self, row: StringDict, deck: Deck) -> None:
        """Update row in report to reflect deck use in this session."""
        row.update(label=deck.label, layout=deck.layout, blurb=deck.blurb)
        row.pop("gone", None)
        if deck.counts["drawn"]:
            row["used"] = self.now
        for event, count in deck.counts.items():
            if not (was := row.get(event, "N/A")).isnumeric():
                was = 0
            row[event] = int(was) + count


if __name__ == "__main__":
    PracticeMakesPerfect().main()
