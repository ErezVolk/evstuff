#!/usr/bin/env python3
"""Practice Makes Perfect"""
import argparse
import io
from pathlib import Path
import random
import re

from collections.abc import Container
from collections.abc import Iterable
from collections.abc import Sequence
from typing import NamedTuple
from typing import NoReturn
from typing import TextIO
from typing import TypeAlias
from typing import TypeVar


class Etude(NamedTuple):
    """A concrete etude, e.g., 'minor pentatonic'"""
    name: str
    keys: str | list[str]


Tome: TypeAlias = "Book | Agenda"
Playable: TypeAlias = "Etude | Book"
TableOfContents: TypeAlias = list[Playable]
PitchClass: TypeAlias = tuple[str] | tuple[str, str]


class Book(NamedTuple):
    """A collections of etudes or pointers to other books"""
    toc: TableOfContents


class Agendum(NamedTuple):
    """A step in a agenda"""
    book_name: str
    num_etudes: int | None


class Agenda(NamedTuple):
    """Like a practice plan for the day
    "do 3 of this book, then all of this book, etc."
    """
    items: list[Agendum]


DEFAULT_CONFIG = """
note:  # Just pick a note
  : ANY

scale:  # Play a scale
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

mode:  # Play a mode
  ' ionian': ionian
  ' dorian': dorian
  ' phrygian': phrygian
  ' lydian': lydian
  ' mixolydian': mixolydian
  ' aeolian': aeolian
  ' locrian': locrian

arp:  # Play an arpeggio
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  ' major pentatonic': major
  ' minor pentatonic': minor
"""


class Configuration(NamedTuple):
    """The information from the config file"""
    tomes: dict[str, Tome]
    starred: list[str]


class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace
    config: Configuration

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(
            description="Practice Makes Perfect"
        )
        parser.add_argument(
            "tomes",
            metavar="TOME",
            type=str,
            nargs="*",
        )

        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--num-tracks",
            type=int,
        )
        group.add_argument(
            "-N",
            "--one-of-each",
            action="store_true",
        )

        parser.add_argument(
            "-i",
            "--max-etudes",
            type=int,
        )
        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
        )
        parser.add_argument(
            "-v",
            "--verbose",
            action="store_true",
        )
        parser.add_argument(
            "-c",
            "--config",
            type=Path,
            default=Path.home() / ".pmprc",
        )
        self.args = parser.parse_args()
        self.parser = parser

    T = TypeVar("T")

    _LETTERS = "CDEFGAB"
    _MODES = (
        "ionian",
        "dorian",
        "phrygian",
        "lydian",
        "mixolydian",
        "aeolian",
        "locrian",
    )

    PITCH_CLASSES: list[PitchClass] = [
        ("C",),
        ("C♯", "D♭"),
        ("D",),
        ("D♯", "E♭"),
        ("E",),
        ("F",),
        ("F♯", "G♭"),
        ("G",),
        ("G♯", "A♭"),
        ("A",),
        ("A♯", "B♭"),
        ("B",),
    ]

    SCALE_FIX: dict[str, dict[str, str]] = {
        "NONE": {},
        "ANY": {},
        "major": {
            "G♯": "A♭",
            "D♯": "E♭",
            "A♯": "B♭",
        },
        "minor": {
            "G♭": "F♯",
            "D♭": "C♯",
            "A♭": "G♯",
        }
    }

    all_tomes: dict[str, Tome]
    playables: list[Playable]
    report_book: bool = False
    book_name: str

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()

        if self.args.tomes == ["default-config"]:
            print(DEFAULT_CONFIG)
            return

        self.add_modes()
        self.configure()

        self.all_tomes = self.config.tomes
        self.report_book = self.args.verbose

        self.book_name = self.choose_tome()
        tome = self.all_tomes[self.book_name]
        if isinstance(tome, Book):
            self.run_book(tome, self.args.num_tracks, self.args.one_of_each)
        else:
            self.run_agenda(tome)

    def run_agenda(self, agenda: Agenda, spaced=True) -> None:
        """Run an agenda: A sequence of books"""
        for agendum in agenda.items:
            name = agendum.book_name
            tome = self.all_tomes[name]
            if isinstance(tome, Book):
                self.book_name = name
                self.run_book(
                    tome,
                    num_tracks=agendum.num_etudes,
                    one_of_each=agendum.num_etudes is None
                )
            elif isinstance(tome, Agenda):
                self.run_agenda(tome, spaced=False)
            if spaced:
                print("")

    def run_book(self, book: Book, num_tracks: int | None, one_of_each: bool):
        """Run a "simple" book"""
        self.playables = book.toc
        if self.args.max_etudes:
            num_playables = min(self.args.max_etudes, len(self.playables))
            self.playables = random.sample(self.playables, num_playables)

        if one_of_each:
            num_tracks = len(self.playables)
        elif not num_tracks:
            num_tracks = len(self.PITCH_CLASSES)

        if self.report_book:
            print(f"[{self.book_name} × {num_tracks}]")

        etude_seq: list[Etude] = []
        for playable in self.choose(self.playables, num_tracks):
            while isinstance(playable, Book):
                playable = random.choice(playable.toc)
            etude_seq.append(playable)

        pitch_class_seq = self.choose(self.PITCH_CLASSES, num_tracks)
        track_seq = self.make_tracks(etude_seq, pitch_class_seq)

        print(self.get_sep(track_seq).join(track_seq))

    def choose_tome(self) -> str:
        """Pick out a tome"""
        if self.args.tomes:
            pool = self.args.tomes
            if (unknown := set(pool) - set(self.all_tomes)):
                self.fail(f"Unknown book(s): {' '.join(unknown)}")
        else:
            pool = self.config.starred
            if len(pool) > 1:
                self.report_book = True
        return random.choice(pool)

    def make_tracks(
        self,
        etude_seq: list[Etude],
        pitch_class_seq: list[PitchClass]
    ) -> list[str]:
        """Attach chosen pitch classes to chosen etudes"""
        track_seq = []
        for etude, pitch_class in zip(etude_seq, pitch_class_seq):
            if isinstance(etude.keys, list):
                key = random.choice(etude.keys)
            elif etude.keys == "NONE":
                key = ""
            else:
                scale: str = etude.keys
                note = random.choice(pitch_class)
                key = self.SCALE_FIX[scale].get(note, note)
            track_seq.append(f"{key}{etude.name}")
        return track_seq

    def get_sep(self, tracks: list[str]) -> str:
        """Return space or newline separator"""
        if self.args.multiline:
            return "\n"
        if any(" " in track for track in tracks):
            return "\n"
        if sum(len(track) for track in tracks) + len(tracks) >= 80:
            return "\n"
        return " "

    def add_modes(self) -> None:
        """Add the Greek modes and their hypotheticals to our known scales"""
        model = self.SCALE_FIX["major"]
        mapping: dict[str, str]

        for offset, mode in enumerate(self._MODES):
            mapping = {
                note: self._LETTERS[(idx + offset) % len(self._LETTERS)]
                for idx, note in enumerate(self._LETTERS)
            }

            def modify(note: str) -> str:
                try:
                    return mapping[note[0]] + note[1:]
                except KeyError:
                    return note

            self.SCALE_FIX[mode] = {
                modify(key): modify(value)
                for key, value in model.items()
            }

    @classmethod
    def choose(cls, options: Iterable[T], num_choices: int) -> list[T]:
        """Choose so we have as many "full" repetitions and a random tail"""
        opts = list(options)
        nopts = len(opts)

        if num_choices <= nopts:
            return random.sample(opts, max(num_choices, 1))

        ntail = num_choices % nopts
        n_full_rounds = (num_choices - ntail) // nopts

        choices = (opts * n_full_rounds) + random.sample(opts, ntail)
        return choices

    def configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self.parse_config(fobj)
        except (FileNotFoundError, ValueError):
            self.config = self.parse_config(io.StringIO(DEFAULT_CONFIG))

    def parse_config(self, stream: TextIO) -> Configuration:
        """Read configuration file"""
        try:
            return ConfigParser(self.SCALE_FIX).parse(stream)
        except BadConfig as err:
            self.fail(str(err))
            raise err  # Won't happen, just to appease pyright

    def fail(self, message: str) -> NoReturn:
        """Handy wrapper around ArgumentParser's `.fail()` method"""
        self.parser.error(message)


class BadConfig(ValueError):
    """Problem with config file"""


class ConfigParser:
    """Read configuration file"""
    class Folder(NamedTuple):
        """A book that just an amalgamation of other books"""
        line_num: int
        allsies: set[str]  # Books swallowed in their entirety
        onesies: set[str]  # Books from which a single etude is taken

    books: dict[str, Book] = {}
    tomes: dict[str, Tome] = {}
    folders: dict[str, Folder] = {}
    starred: list[str] = []
    curr: Book | None = None
    line_num: int
    line: str

    def __init__(self, known_scales: Container[str]):
        self.known_scales = known_scales

    def match(self, expr: str) -> re.Match | None:
        """Handy wrapper around `re.fullmatch` for the current line"""
        return re.fullmatch(expr, self.line)

    def parse(self, stream: TextIO) -> "Configuration":
        """Read configuration file"""
        for self.line_num, line in enumerate(stream, 1):
            self.line = re.sub(r"\s*(#.*)?$", "", line)

            if (mobj := self.match(r"([*]?)(\S[^:]*):")):
                self.enter_book(name=mobj.group(2).strip(), star=mobj.group(1))
            elif (mobj := self.match(r"\s+([^:]*):\s+(.*)")):
                self.add_etude(
                    name=mobj.group(1).strip(),
                    scale=mobj.group(2).strip(),
                )
            elif (mobj := self.match(r"(?P<name>[^=]*)\s*=\s*{(?P<parts>[^}]*)}")):
                self.add_folder(
                    name=mobj.group("name").strip(),
                    playables=[part.strip() for part in mobj.group("parts").split()],
                )
            elif (mobj := self.match(r"([*]?)([^=]*)\s*=\s*\[([^]]*)\]")):
                self.add_agenda(
                    star=mobj.group(1),
                    name=mobj.group(2).strip(),
                    parts=[part.strip() for part in mobj.group(3).split()],
                )
            elif not self.match(r""):
                raise BadConfig(f"Bad line {self.line_num}: {repr(self.line)}")

        self.check_no_loops()
        self.convert_folders()

        return Configuration(
            tomes=self.tomes,
            starred=self.starred or list(self.tomes),
        )

    def enter_book(self, name: str, star=str) -> None:
        """Found a book line"""
        if name in self.tomes:
            raise BadConfig(f"Duplicate name: {repr(name)}")

        self.tomes[name] = self.books[name] = self.curr = Book([])
        if star == "*":
            self.starred.append(name)

    def add_etude(self, name: str, scale: str) -> None:
        """Found an etude line"""
        if self.curr is None:
            raise BadConfig(f"Bookless etude in line {self.line_num}")

        if name and name[0] in "'\"" and name[-1] == name[0]:
            name = name[1:-1]
        if scale in self.known_scales:
            self.curr.toc.append(Etude(name=name, keys=scale))
        else:
            self.curr.toc.append(Etude(
                name=name,
                keys=[key.strip() for key in scale.split("|")],
            ))

    def add_folder(self, name: str, playables: Sequence[str]) -> None:
        """Found a folder line"""
        if not playables:
            raise BadConfig(f"No playable in {name} (line {self.line_num})")

        allsies = {one for one in playables if not one.startswith("@")}
        onesies = {one[1:] for one in set(playables) - allsies}
        self.folders[name] = self.Folder(
            line_num=self.line_num,
            allsies=allsies,
            onesies=onesies,
        )

    PART_RE = r"(?P<at>(?P<num>[1-9]\d*)?@)?(?P<book>\S+)"

    def add_agenda(self, star: str, name: str, parts: Sequence[str]) -> None:
        """Found a agenda line"""
        if not parts:
            raise BadConfig(f"No book in agenda {name} (line {self.line_num})")

        if name in self.tomes:
            raise BadConfig(f"Duplicate name: {repr(name)}")

        items = []
        for part in parts:
            if not (mobj := re.fullmatch(self.PART_RE, part)):
                raise BadConfig(f"Bad {repr(part)} (line {self.line_num})")
            if (nstr := mobj.group("num")):
                num = int(nstr)
            elif mobj.group("at"):
                num = 1
            else:
                num = None
            items.append(Agendum(num_etudes=num, book_name=mobj.group("book")))
        self.tomes[name] = Agenda(items=items)

        if star == "*":
            self.starred.append(name)

    def check_no_loops(self) -> None:
        """Make sure no folder->folder links"""
        known = set(self.books)
        for name, folder in self.folders.items():
            unknown = (folder.allsies | folder.onesies) - known
            if unknown:
                unks = " ".join(unknown)
                raise BadConfig(
                    f"Unknown playable(s) on line {folder.line_num}: "
                    f"{unks} in folder {name}"
                )

    def convert_folders(self) -> None:
        """Convert the folders to books"""
        for name, folder in self.folders.items():
            items: TableOfContents
            items = [self.books[onesie] for onesie in folder.onesies]
            for allsie in folder.allsies:
                items.extend(self.books[allsie].toc)
            self.tomes[name] = self.books[name] = Book(items)


if __name__ == "__main__":
    PracticeMakesPerfect().main()
