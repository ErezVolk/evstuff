#!/usr/bin/env python3
"""Practice Makes Perfect

Assuming you have more scales, drills, licks and etudes to practice regularly
than you have time for each day, this utility will present them to you in
random order. Sort of like spaced repetition, only _it never ends_.


About the code:
There are two different types of object identifiers:
- `x.label` is the name used by other parts of the system (references, config).
- `x.layout` is used to identify saved states.

Sometimes (e.g., in "well-known" things like the major scale), the label and
the layout are equal and human-readable ("major", etc.). Other times, the
layout is a hash of the different options, and the label is the reference
name.

Most objects also have `x.blurb`, which is for display purposes only.
"""
import argparse
import collections
from collections.abc import Iterable
import csv
import dataclasses
import datetime
import graphlib
import hashlib
import io
import logging
from pathlib import Path
import plistlib
import random
import re
import typing as t


DEFAULT_CONFIG = """
note:  # Just pick a note
  : ANY

scale:  # Play a scale
  -major: major
  -natural minor: minor

arp:  # Play an arpeggio
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major

form:
  Blues in {}: C|F|G
  {}-major scale on the {} string: {major} {E|A|D|G}
"""


__TODO__ = """
- "ANY := C‖C#|Db‖D#|Eb‖...‖B" "major := C#|Db‖...‖B"
- Build modes, e.g., "altered := minor+7", then we can only predefine major
- A UI to mark what was done? With a metronome? And a drone?
"""


SEP = " ‖ "
Filename: t.TypeAlias = str | Path
Label: t.TypeAlias = str  # Purely cosmetic, for readability
Layout: t.TypeAlias = str  # Purely cosmetic, for readability
Entry: t.TypeAlias = "Etude | BookRef"
TableOfContents: t.TypeAlias = list[Entry]
Books: t.TypeAlias = dict[Label, "Book"]
Decks: t.TypeAlias = dict[Layout, "Deck"]
StringDict: t.TypeAlias = dict[str, t.Any]

log = logging.getLogger("pmp")
tracked: set[Layout] = set()


class BadConfig(ValueError):
    """Problem with config file"""


class SerializationError(ValueError):
    """Raised internally when a deck cannot be restored."""


class Deck:
    """A deck of strings"""

    cards: tuple[str, ...]
    queue: list[str] = []
    label: Label
    layout: Layout
    preblurb: str
    drawn: int = 0
    old_layout: Layout | None = None

    MIN_SERIALIZABLE = 3
    SERIALIZEES = ("blurb", "label", "layout", "cards", "queue")

    def __init__(self, cards: Iterable[str], label="", layout=""):
        if layout and label and label != layout:
            raise ValueError("Cannot specify both label and layout")
        self.cards = tuple(cards)
        if not self.cards:
            raise ValueError("Empty decks not supported")
        if layout:
            self.preblurb = self.layout = self.label = layout
        else:
            self.label = label or "|".join(self.cards)
            hashobj = hashlib.sha256("\0".join(sorted(self.cards)).encode())
            self.layout = f":{hashobj.hexdigest()[:8]}:"
            self.preblurb = f"{self.label} {self.layout}"

    def __len__(self) -> int:
        return len(self.cards)

    @property
    def blurb(self) -> str:
        """A description of the deck in its current state"""
        return f"{self.preblurb} ({len(self.queue)} of {len(self)})"

    def serialize(self) -> StringDict:
        """Serialize"""
        if not self.drawn:
            raise SerializationError("Never drawn")
        if len(self) < self.MIN_SERIALIZABLE:
            raise SerializationError("Too small")
        return {key: getattr(self, key) for key in self.SERIALIZEES}

    def adapt(self, saved: StringDict) -> None:
        """Try to deserialized a deck which has been modified"""
        that = set(self._get_list(saved, "cards"))
        this = set(self.cards)
        if len(that & this) < self.MIN_SERIALIZABLE:
            raise SerializationError("Not enough shared cards to adapt")
        added = this - that
        gone = that - this
        log.debug("Adapted %s +%s -%s", self.label, list(added), list(gone))
        if not (queued := set(self._get_list(saved, "queue")) & this):
            raise SerializationError("No shared cards in queue")
        self._set_queue(queued & added)
        self.old_layout = saved.get("layout")

    def deserialize(self, saved: t.Any) -> None:
        """Validate and restore a saved queue"""
        queue = self._get_list(saved, "queue")
        if not set(queue).issubset(self.cards):
            raise SerializationError("List contains unknown cards")
        if saved.get("layout") != self.layout:
            raise SerializationError("Hash mismatch")
        self._track("Deserializing")
        self._set_queue(queue)

    def _get_list(self, saved: t.Any, key: str) -> list[str]:
        """Validate a serialized object and get a list[str] member"""
        if len(self) < self.MIN_SERIALIZABLE:
            raise SerializationError("Too few items to load state")
        if not isinstance(saved, dict):
            raise SerializationError("Not a dict")
        if not isinstance(cards := saved.get(key), list):
            raise SerializationError("Not a list")
        if not cards:
            raise SerializationError("Empty list")
        if not all(isinstance(card, str) for card in cards):
            raise SerializationError("Not a list of strings")
        return cards

    def predraw(self, count: int) -> None:
        """Try and make sure the next `count` cards won't have dupes"""
        if count > len(self.queue):
            self._extend(set(self.cards) - set(self.queue))

    def draw(self) -> str:
        """Get the next card"""
        self.ping()
        if not self.queue:
            self._set_queue(self.cards)
        card = self.queue.pop()
        self._track("%d after drawing %r", len(self.queue), card)
        return card

    def ping(self) -> None:
        """Notify the deck it's being used"""
        self.drawn += 1

    def _set_queue(self, queue: Iterable[str]) -> None:
        """Set the queue"""
        self.queue = list(queue)
        random.shuffle(self.queue)
        self._track("Queue set to %s", self.queue)

    def _extend(self, addend: Iterable[str]) -> None:
        """Add cards to the end of the queue (remember we use queue.pop())"""
        lineup = list(addend)
        random.shuffle(lineup)
        self.queue = list(lineup + self.queue)
        self._track("Adding %s => %s", lineup, self.queue)

    def _track(self, fmt: str, *args) -> None:
        """Print special tracking info if we're in the list"""
        if self.layout in tracked:
            log.info(f"{repr(self.layout)}: {fmt}", *args)


class NoneDeck(Deck):
    """The NONE deck doesn't really have cards, so make the blurb nicer"""

    def __init__(self):
        super().__init__(cards=[""], layout="NONE")

    def __repr__(self):
        return "<NoneDeck>"

    @property
    def blurb(self) -> str:
        return "NONE"


@dataclasses.dataclass
class Etude:
    """A concrete etude, e.g., 'minor pentatonic'.

    A template string with one or more `Deck` variables.
    """

    template: str
    decks: list[Deck]
    label: Label = dataclasses.field(init=False)
    blurb: str = dataclasses.field(init=False)

    def __post_init__(self):
        blurbs = (deck.blurb for deck in self.decks)
        self.blurb = f"{self.template}={SEP.join(blurbs)}"

        meat = re.sub(r"\s*\[.*\]$", "", self.template)
        labels = (deck.label for deck in self.decks)
        self.label = f"{meat}={SEP.join(labels)}"


@dataclasses.dataclass
class Book:
    """A collection of etudes or pointers to other books"""

    label: Label
    toc: TableOfContents = dataclasses.field(default_factory=TableOfContents)
    sequential: bool = False
    deck: Deck = dataclasses.field(init=False)
    labels: list[Label] = dataclasses.field(init=False)

    def predraw(self, count: int):
        """Try and make sure the next `count` items won't have dupes"""
        self.deck.predraw(count)

    def draw(self) -> Entry:
        """Get the next random ToC entry"""
        return self.toc[self.labels.index(self.deck.draw())]

    @property
    def blurb(self) -> str:
        """A description of the book in its current state"""
        return f"{self.deck.blurb} {'[]' if self.sequential else '{}'}"

    def finalize(self) -> Deck:
        """(Re)create the deck"""
        self.labels = [entry.label for entry in self.toc]
        self.deck = Deck(cards=self.labels, label=self.label)
        return self.deck


@dataclasses.dataclass
class BookRef:
    """A reference to a book"""

    book_label: Label
    count: int | None
    book: Book = dataclasses.field(init=False)
    label: Label = dataclasses.field(init=False)
    blurb: str = dataclasses.field(init=False)

    def __post_init__(self):
        if self.count:
            self.label = f"{self.count}@{self.book_label}"
        else:
            self.label = f"={self.book_label}"
        self.blurb = self.label


@dataclasses.dataclass
class Config:
    """The information from the config file"""

    books: Books
    starred: list[Label]


class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(description="Practice Makes Perfect")
        parser.add_argument(
            "books",
            metavar="BOOK",
            type=str,
            nargs="*",
            help=(
                "Choose books from this list; specify 'default-config' to "
                "print out the default configuration file"
            ),
        )

        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--num-tracks",
            type=int,
            help="Number of tracks (etude × key) to generate",
        )
        group.add_argument(
            "-N",
            "--one-of-each",
            action="store_true",
            help="Make one track per etude in the chosen book",
        )

        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
            help="Always print tracks on separate lines",
        )
        parser.add_argument(
            "-d",
            "--debug",
            nargs="?",
            const="-",
            metavar="FILE",
            help="Print lots of debugging information",
        )
        parser.add_argument(
            "-D",
            "--track-decks",
            nargs="+",
            help="Print debugging info on specific deck",
        )
        parser.add_argument(
            "-H",
            "--home",
            type=Path,
            default=Path.home(),
            help="Look for configuration files here",
        )
        parser.add_argument("-c", "--config", type=Path, help="Config file")
        parser.add_argument("-s", "--state-file", type=Path, help="State file")
        parser.add_argument(
            "-r",
            "--report-file",
            type=Path,
            help="Report file",
        )
        parser.add_argument(
            "-S",
            "--saveless",
            action="store_true",
            help="Don't save state/report files",
        )
        self.args = args = parser.parse_args()
        args.config = args.config or args.home / ".pmprc"
        args.state_file = args.state_file or args.home / ".pmpstate.plist"
        args.report_file = args.report_file or args.home / ".pmpreport.csv"
        self.parser = parser

    GOOD_SCALE_KEYS = {  # Not the scales, but the keys for those scales
        "ANY": "C‖C♯|D♭‖D‖D♯|E♭‖E‖F‖F♯|G♭‖G‖G♯|A♭‖A‖A♯|B♭‖B",
        "major": "C ‖ C♯|D♭ ‖ D ‖ E♭ ‖ E ‖ F ‖ F♯|G♭ ‖ G ‖ A♭ ‖ A ‖ B♭ ‖ B|C♭",
        "minor": "C ‖ C♯ ‖ D ‖ D♯|E♭ ‖ E ‖ F ‖ F♯ ‖ G ‖ G♯|A♭ ‖ A ‖ A♯|B♭ ‖ B",
        "ionian": "C‖C♯|D♭‖D‖E♭‖E‖F‖F♯|G♭‖G‖A♭‖A‖B♭‖B|C♭",
        "dorian": "D‖D♯|E♭‖E‖F‖F♯‖G‖G♯|A♭‖A‖B♭‖B‖C‖C♯|D♭",
        "phrygian": "E‖E♯|F‖F♯‖G‖G♯‖A‖A♯|B♭‖B‖C‖C♯‖D‖D♯|E♭",
        "lydian": "F‖F♯|G♭‖G‖A♭‖A‖B♭‖B|C♭‖C‖D♭‖D‖E♭‖E|F♭",
        "mixolydian": "G‖G♯|A♭‖A‖B♭‖B‖C‖C♯|D♭‖D‖E♭‖E‖F‖F♯|G♭",
        "aeolian": "A‖A♯|B♭‖B‖C‖C♯‖D‖D♯|E♭‖E‖F‖F♯‖G‖G♯|A♭",
        "locrian": "B‖B♯|C‖C♯‖D‖D♯‖E‖E♯|F‖F♯‖G‖G♯‖A‖A♯|B♭",
    }

    books: Books
    decks: Decks
    config: Config
    state: dict
    reporter: "Reporter"

    STATE_VERSION = "v4"
    NOTE_RE = re.compile("[A-G](|♯|♯♯|♭|♭♭|𝄪|𝄫)", re.IGNORECASE)

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()
        self._configure_logging()

        if self.args.books == ["default-config"]:
            print(DEFAULT_CONFIG)
            return

        self._make_basic_decks()
        self._configure()
        self._finalize_books()
        self._start_reporter()
        self._load_state()
        self._make_all_decks()
        self._restore_state()

        now = datetime.datetime.now().isoformat(timespec="minutes", sep=" ")
        book = self._choose_book()
        count = None if self.args.one_of_each else self.args.num_tracks
        self._header(f"{now} {book.label}")
        self._run_book(book, count=count, top=True)
        if not self.args.saveless:
            self._save_state()
        log.debug("\n\n\n")

    def _header(self, text: str, level: int = 1) -> None:
        """Print a markdown-like header"""
        if level == 1:
            print(f"{text}\n{'=' * len(text)}")
        else:
            print(f"\n{text}\n{'-' * len(text)}")

    def _configure_logging(self) -> None:
        """Set logging format(s) and level"""
        if self.args.track_decks:
            tracked.update(self.args.track_decks)
        if self.args.debug is None:
            logging.basicConfig(format="INFO: %(message)s", level=logging.INFO)
            return

        if self.args.debug == "-":
            handler: logging.Handler = logging.StreamHandler()
        else:
            handler = logging.FileHandler(self.args.debug)
            handler.setLevel(logging.DEBUG)
        fmt = logging.Formatter("%(asctime)s [pmp:%(lineno)d] %(message)s")
        handler.setFormatter(fmt)
        log.addHandler(handler)
        log.setLevel(logging.DEBUG)

    def _run_book(self, book: Book, count: int | None, top=False) -> None:
        """Run any book"""
        if book.sequential:
            self._run_sequential(book, top=top)
        else:
            self._run_plain(book, count)

    def _run_sequential(self, book: Book, top=False) -> None:
        """Run a sequence of items"""
        for entry in book.toc:
            book.deck.ping()
            if top:
                self._header(entry.label, level=2)
            if isinstance(entry, Etude):
                print(self._make_track(entry))
            else:  # BookRef
                self._run_book(entry.book, entry.count)

    def _run_plain(self, book: Book, num_tracks: int | None) -> None:
        """Run a "simple" book, choosing etudes and assigining keys"""
        if num_tracks is None:
            num_tracks = len(book.deck)
        elif num_tracks <= 0:
            num_tracks = len(self.decks["ANY"])
        etudes = self._choose_etudes(book, num_tracks)
        tracks = self._make_tracks(etudes)
        print(self._get_sep(tracks).join(tracks))

    def _choose_etudes(self, book: Book, count: int) -> Iterable[Etude]:
        """Yields chosen etudes.

        Recursion is safe here, since we used `TopologicalSorter`
        to make sure the graph is cycle-free.
        """
        book.predraw(count)
        for _ in range(count):
            entry = book.draw()
            if isinstance(entry, Etude):
                yield entry
            else:  # BookRef
                yield from self._choose_etudes(entry.book, entry.count or 1)

    def _choose_book(self) -> Book:
        """Pick out a book"""
        if self.args.books:
            labels = self.args.books
            if unknown := set(labels).difference(self.books):
                self._fail(f"Unknown book(s): {' '.join(unknown)}")
        else:
            labels = self.config.starred
        return self.books[random.choice(labels)]

    def _make_tracks(self, etude_seq: Iterable[Etude]) -> list[str]:
        """Pick a key (or selection of keys) for each etude"""
        return [self._make_track(etude) for etude in etude_seq]

    def _make_track(self, etude: Etude) -> str:
        """Fill in the template for one etude"""
        keys = []
        for deck in etude.decks:
            key = deck.draw()
            if "|" in key:  # Can only come from our pitch classes
                key = random.choice(key.split("|"))
            keys.append(key)

        if "{}" not in etude.template:
            return f"{keys[0]}{etude.template}"

        parts = re.split(r"({})", etude.template)
        ikey = iter(keys)
        return "".join(next(ikey) if part == "{}" else part for part in parts)

    def _get_sep(self, tracks: list[str]) -> str:
        """Return space or newline separator"""
        if self.args.multiline:
            return "\n"
        if any(" " in track for track in tracks):
            return "\n"
        if sum(len(track) for track in tracks) + len(tracks) >= 80:
            return "\n"
        return " "

    def _make_basic_decks(self) -> None:
        """Start `self.decks` with the basic scales"""
        self.decks = {"NONE": NoneDeck()} | {
            label: Deck(layout=label, cards=self._prep_scale(label, cardstr))
            for label, cardstr in self.GOOD_SCALE_KEYS.items()
        }
        log.debug("Basic decks: %s", SEP.join(self.decks))

    def _prep_scale(self, label: str, cardstr: str) -> list[str]:
        """Split, strip, and sanity-check a known scale"""
        cards = [card.strip() for card in cardstr.split("‖")]
        notes = [note for card in cards for note in card.split("|")]
        if len(set(notes)) < len(notes):
            raise ValueError(f"{label}: Not unique: {' '.join(sorted(notes))}")
        if bad := [note for note in notes if not self.NOTE_RE.fullmatch(note)]:
            raise ValueError(f"{label}: Bad {sorted(bad)}")
        if missing := set("ABCDEFG").difference(notes):
            raise ValueError(f"{label}: Missing {' '.join(sorted(missing))}")
        return cards

    def _have(self, deck: Deck) -> Deck:
        """Add a deck to our records"""
        return self.decks.setdefault(deck.layout, deck)

    def _configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self._parse_config(self.args.config, fobj)
        except (FileNotFoundError, ValueError):
            self.config = self._parse_config("", io.StringIO(DEFAULT_CONFIG))

    def _load_state(self) -> None:
        """Read saved state info `self.state`"""
        try:
            with open(self.args.state_file, "rb") as fobj:
                self.state = plistlib.load(fobj)[self.STATE_VERSION]
        except Exception:  # Can be any number of things
            self.state = {}
        if not isinstance(self.state.get("deck"), dict):
            self.state["deck"] = {}

    def _save_state(self) -> None:
        """Save the queue state"""
        saveds = self.state["deck"]
        for layout in saveds.keys() - self.decks.keys():
            del saveds[layout]

        used = []
        for layout, deck in self.decks.items():
            try:
                saveds[layout] = deck.serialize()
                used.append(deck.blurb)
            except SerializationError as exc:
                log.debug("Not serializing %s: %s", deck.blurb, exc)
        if used:
            log.debug("Saving %d: %s", len(used), SEP.join(used))
        self.reporter.save_report(self.decks)
        self._make_debug()

        with open(self.args.state_file, "wb") as fobj:
            to_write = {self.STATE_VERSION: self.state}
            plistlib.dump(to_write, fobj, sort_keys=False)

    def _make_debug(self) -> None:
        """Make the debug part of the state"""
        debug = self.state["debug"]
        debug["n_decks"] = len(self.decks)
        debug["decks"] = {
            layout: deck.blurb
            for layout, deck in self.decks.items()
        }
        debug["n_books"] = len(self.books)
        debug["books"] = {
            book.blurb: [entry.blurb for entry in book.toc]
            for book in self.books.values()
        }

    def _make_all_decks(self) -> None:
        """Make sure every deck is created and registered"""
        log.debug("All books: %s", SEP.join(self.books))
        for book in self.books.values():
            for etude in book.toc:
                if isinstance(etude, Etude):
                    etude.decks = [self._have(deck) for deck in etude.decks]

    def _restore_state(self) -> None:
        """Restore states for any eligible deck"""
        by_layout: dict[Layout, t.Any] = self.state["deck"]
        by_label: dict[Label, StringDict] = {}
        for layout in by_layout.keys() - self.decks.keys():
            if isinstance(saved := by_layout[layout], dict):
                if isinstance(label := saved.get("label"), str):
                    by_label[label] = saved

        n_used = 0
        for layout, deck in self.decks.items():
            try:
                if saved := by_layout.get(layout):
                    deck.deserialize(saved)
                elif saved := by_label.get(deck.label):
                    deck.adapt(saved)
                if queued := SEP.join(deck.queue):
                    log.debug("Loaded %s -> %s", deck.blurb, queued)
                    n_used += 1
            except SerializationError as exc:
                log.debug("Not restoring %s: %s", deck.blurb, exc)
                by_layout.pop(layout, None)
        log.debug("Resuming %d of %d decks", n_used, len(self.decks))

    def _parse_config(self, filename: Filename, stream: t.TextIO) -> Config:
        """Read configuration file"""
        try:
            labeldecks = {deck.label: deck for deck in self.decks.values()}
            return ConfigParser(labeldecks).parse(filename, stream)
        except BadConfig as err:
            self._fail(str(err))

    def _finalize_books(self) -> None:
        """Check configured graph is legit and prepare all books for action"""
        self.books = self.config.books
        graph = collections.defaultdict(set)
        for label, book in self.books.items():
            for ref in book.toc:
                if isinstance(ref, BookRef):
                    graph[ref.book_label].add(label)
                    ref.book = self.books[ref.book_label]

        if missing := graph.keys() - self.books.keys():
            info = {label: " ".join(graph[label]) for label in missing}
            errs = (f"{label} (in {users})" for label, users in info.items())
            self._fail(f"Unknown reference(s): {' '.join(errs)}")

        try:
            order = list(graphlib.TopologicalSorter(graph).static_order())
        except graphlib.CycleError as exc:
            self._fail(f"Cyclical configuration: {' -> '.join(exc.args[1])}")

        # The hash of a book depends on the layouts of book refs in the toc
        order.extend(self.books.keys() - order)
        for label in reversed(order):
            book = self.books[label]
            book.deck = self._have(book.finalize())

    def _start_reporter(self) -> None:
        """Create reporter object"""
        self.reporter = Reporter(self.args.report_file)

    def _fail(self, message: str) -> t.NoReturn:
        """Handy wrapper around ArgumentParser's `.fail()` method"""
        self.parser.error(message)


class ConfigParser:
    """Read configuration file"""

    books: Books = {}
    starred: list[Label] = []
    curr: Book | None = None
    line_num: int
    line: str
    mobj: re.Match | None

    def __init__(self, labeldecks: dict[Label, Deck]):
        self.labeldecks = dict(labeldecks)

    def match(self, expr: str) -> bool:
        """Handy wrapper around `re.fullmatch` for the current line"""
        self.mobj = re.fullmatch(expr, self.line)
        return bool(self.mobj)

    def group(self, group: int | str) -> str:
        """Group from previous `self.match()`."""
        assert self.mobj is not None
        return self.mobj.group(group)

    PART_RE = r"(?P<at>(?P<count>[1-9]\d*)?@)?(?P<label>\S+)"

    def parse(self, filename: Filename, stream: t.TextIO) -> "Config":
        """Read configuration file"""
        try:
            return self.do_parse(stream)
        except BadConfig as exc:
            raise BadConfig(f"[{filename}:{self.line_num}] {exc}") from exc

    def do_parse(self, stream: t.TextIO) -> "Config":
        """The actual reading function"""
        for self.line_num, line in enumerate(stream, 1):
            self.line = re.sub(r"\s*(#.*)?$", "", line)

            if self.match(r"([^:|]+):=(.*)"):
                self.add_deck(label=self.group(1), keys=self.group(2))
            elif self.match(r"([*]?)(\S[^:]*):"):
                self.enter_book(label=self.group(2), star=self.group(1))
            elif self.match(r"\s+([^:]*):\s+(.*)"):
                self.add_etude(template=self.group(1), deckstr=self.group(2))
            elif self.match(f"\\s+{self.PART_RE}\\s*") and self.group("at"):
                self.add_ref()
            elif self.match(r"(?P<label>[^=]*)\s*=\s*{(?P<parts>[^}]*)}"):
                self.add_one_liner(sequential=False)
            elif self.match(r"(?P<label>[^=]*)\s*=\s*\[(?P<parts>[^]]*)\]"):
                self.add_one_liner(sequential=True)
            elif not self.match(r""):
                raise BadConfig(f"Bad line: {repr(self.line)}")

        starred = self.starred or list(self.books)
        return Config(books=self.books, starred=starred)

    def enter_book(self, label: Label, star: t.Any, sequential=False) -> None:
        """Found a book line"""
        if (label := label.strip()) in self.books:
            raise BadConfig(f"Duplicate book: {repr(label)}")

        self.books[label] = self.curr = Book(label, sequential=sequential)
        if star:
            self.starred.append(label)

    def add_deck(self, label: str, keys: str) -> None:
        """Found a deck line, e.g., "easy-major := C|F|G"."""
        if (label := label.strip()) in self.labeldecks:
            raise BadConfig(f"Duplicate deck: {repr(label)}")

        cards = [key.strip() for key in keys.split("|")]
        self.labeldecks[label] = Deck(label=label, cards=cards)

    def add_etude(self, template: str, deckstr: str) -> None:
        """Found an etude line, e.g., "{}-maj: {major}" or "-min: minor}."""
        if self.curr is None:
            raise BadConfig("Bookless etude")

        template = template.strip()
        if template and template[0] in "'\"" and template[-1] == template[0]:
            template = template[1:-1]
        num_placeholders = len(re.findall(r"{}", template)) or 1

        if re.fullmatch(r"\s*({[^}]*}\s*)+", deckstr):
            parts = [part[1:-1] for part in re.findall(r"{[^{}]+}", deckstr)]
        else:
            parts = [deckstr.strip()]

        if len(parts) != num_placeholders:
            raise BadConfig("Placeholder mismatch")

        decks = []
        for part in parts:
            try:
                decks.append(self.labeldecks[part])
            except KeyError:
                decks.append(Deck([key.strip() for key in part.split("|")]))
        self.curr.toc.append(Etude(template=template, decks=decks))

    def add_ref(self, mobj: re.Match | None = None) -> None:
        """Add book reference line"""
        if self.curr is None:
            raise BadConfig("Bookless reference")

        if (mobj := mobj or self.mobj) is None:
            raise BadConfig("Partless reference")

        if nstr := mobj.group("count"):
            count = int(nstr)
        elif mobj.group("at"):
            count = 1
        else:
            count = None

        self.curr.toc.append(BookRef(mobj.group("label"), count))

    def add_one_liner(self, sequential: bool) -> None:
        """A one-liner is in `self.group("label" | "parts")`"""
        parts = self.group("parts").split()
        if not parts:
            raise BadConfig("Empty one-liner")

        label = self.group("label").strip()
        if star := label.startswith("*"):
            label = label[1:]
        self.enter_book(label=label, sequential=sequential, star=star)
        for part in parts:
            if mobj := re.fullmatch(self.PART_RE, part):
                self.add_ref(mobj)
            else:
                raise BadConfig(f"Bad {repr(part)}")
        self.curr = None


class Reporter:
    """In charge of the "history" CSV file"""

    path: Path
    by_layout: dict[Layout | None, StringDict] = {}
    now: str
    then: str

    def __init__(self, report_file: Path):
        """Initialize, read old report if possible"""
        self.now = str(today := datetime.date.today())
        self.then = str(today - datetime.timedelta(days=7))
        self.path = report_file

        try:
            default = {"gone": self.now, "label": "N/A", "layout": "N/A"}
            with open(self.path, encoding="utf-8", newline="") as csvfo:
                rows = [default | row for row in csv.DictReader(csvfo)]
            log.debug("Read %s (N = %s)", self.path, len(rows))
            self.by_layout = {row["layout"]: row for row in rows}
        except (FileNotFoundError, ValueError, KeyError, csv.Error) as exc:
            log.debug("Cannot read %s: %s", report_file, exc)

    def save_report(self, decks: Decks) -> None:
        """Write report CSV to disk"""
        to_save = [self.deck_row(deck) for deck in decks.values()]

        # rows.sort_values("when").groupby("label").last()
        grouped = collections.defaultdict(list)
        for row in self.by_layout.values():
            grouped[row["label"]].append(row)
        to_save.extend(max(rows, key=self.when) for rows in grouped.values())
        to_save.sort(key=lambda row: row["label"])

        if not to_save:
            log.debug("Nothing to write to %s", self.path)
            return

        colset = set.union(*[set(row) for row in to_save])
        cols = ["label", "layout"] + sorted(colset - {"label", "layout"})

        log.debug("Save %s (%d x %d)", self.path, len(to_save), len(cols))
        with open(self.path, "w", encoding="utf-8", newline="") as csvfo:
            writer = csv.DictWriter(csvfo, fieldnames=cols)
            writer.writeheader()
            for row in to_save:
                writer.writerow(row)

    def deck_row(self, deck: Deck) -> StringDict:
        """Get or make the row for a deck"""
        rows = self.by_layout
        row = rows.pop(deck.layout, None) or rows.pop(deck.old_layout, {})
        self.update(row, deck)
        return row

    def update(self, row: StringDict, deck: Deck) -> None:
        """Update row in report to reflect deck use in this session"""
        row.update(label=deck.label, layout=deck.layout, blurb=deck.blurb)
        row.pop("gone", None)
        if deck.drawn:
            row["used"] = self.now
            try:
                row["drawn"] = int(row["drawn"]) + deck.drawn
            except (KeyError, ValueError):
                row["drawn"] = deck.drawn

    def when(self, row: StringDict) -> str:
        """Return sort of "usage date" for a row"""
        return row.get("used") or row.get("gone") or self.then


if __name__ == "__main__":
    PracticeMakesPerfect().main()
