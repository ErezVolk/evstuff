#!/usr/bin/env python3
"""Practice Makes Perfect"""
import argparse
from bisect import bisect
import contextlib
import dataclasses
import graphlib
import hashlib
import io
import logging
from pathlib import Path
import plistlib
import random
import re

from collections import defaultdict
from collections.abc import Iterable
from collections.abc import Sequence
from typing import NamedTuple
from typing import NoReturn
from typing import TextIO
from typing import TypeAlias
from typing import TypeVar

# TO DO:
# - Modes of minor scales
# - A UI to mark what was done?
# - "easy-major := C|F|G" etc.


T = TypeVar("T")
Playable: TypeAlias = "Etude | BookRef"
TableOfContents: TypeAlias = list[Playable]
PitchClass: TypeAlias = Sequence[str]


class LevelFormatter(logging.Formatter):
    """Adapted from https://stackoverflow.com/questions/14844970"""
    def __init__(self, formats: dict[int, str], **kwargs):
        super().__init__()

        if "fmt" in kwargs:
            raise ValueError("Use formats=, not fmt=")

        self.formats = sorted(
            (level, logging.Formatter(fmt, **kwargs))
            for level, fmt in formats.items()
        )

    def format(self, record: logging.LogRecord) -> str:
        idx = bisect(self.formats, (record.levelno,), hi=len(self.formats) - 1)
        _, formatter = self.formats[idx]
        return formatter.format(record)


class BadConfig(ValueError):
    """Problem with config file"""


class CannotRestore(ValueError):
    """Raised internally when a deck cannot be restored."""


class Deck:
    """A deck of strings"""
    cards: list[str]
    queue: list[str]
    used: bool = False
    guid: str

    DESCRIPTION_KEY = "description"
    MIN_SERIALIZABLE = 3

    def __init__(self, cards: Sequence[str], guid: str | None = None):
        self.cards = list(cards)
        if guid:
            self.guid = guid
        else:
            hashable = "\0".join(sorted(self.cards)).encode()
            hashed = hashlib.sha256(hashable).hexdigest()[:8]
            self.guid = f":{hashed}:"
        self.queue = []

    def ddesc(self) -> str:
        """Debug description"""
        return "|".join(self.cards)

    def __repr__(self) -> str:
        """Used only for display; use `.guid` when you need a stable hash"""
        parts = [self.guid]
        if self.queue:
            parts.append(f"{len(self.queue)} of {len(self)}")
        else:
            parts.append(f"fresh {len(self)}")
        return " ".join(parts)

    def __len__(self) -> int:
        return len(self.cards)

    def serializable(self) -> bool:
        """Should we serialize this deck in its current state"""
        if not self.used:  # Never drawn
            return False
        if not self.queue:  # On the verge of a fresh shuffle
            return False
        if len(self) < self.MIN_SERIALIZABLE:  # Too small
            return False
        return True

    def serialize(self) -> dict:
        """Serialize"""
        return {
            self.DESCRIPTION_KEY: repr(self),
            "guid": self.guid,
            "queue": self.queue,
        }

    def deserialize(self, saved: object):
        """Validate and restore a saved queue"""
        if len(self) < self.MIN_SERIALIZABLE:
            raise CannotRestore("Too few items to load state")
        if not isinstance(saved, dict):
            raise CannotRestore("Not a dict")
        if saved.get("guid") != self.guid:
            raise CannotRestore("GUID mismatch")
        queue = saved.get("queue")
        if not isinstance(queue, list):
            raise CannotRestore("Not a list")
        if not queue:
            raise CannotRestore("Empty list")
        if not all(isinstance(card, str) for card in queue):
            raise CannotRestore("Not a list of strings")
        if not set(queue).issubset(self.cards):
            raise CannotRestore("List contains invalid strings")
        self._set_queue(queue)

    def draw(self) -> str:
        """Get the next card"""
        if not self.queue:
            self._set_queue(self.cards)
        self.used = True
        return self.queue.pop()

    def peek(self, num: int) -> list[str]:
        """Draw `num` cards without affecting the queue."""
        if num < 1 or num > len(self):
            raise ValueError(f"Cannot draw {num} from a {len(self)}-card deck")

        if num <= len(self.queue):
            return random.sample(self.queue, num)

        return random.sample(self.cards, num)

    def _set_queue(self, queue: Sequence[str]) -> None:
        """Set the queue"""
        self.queue = list(queue)
        random.shuffle(self.queue)


@dataclasses.dataclass
class Etude:
    """A concrete etude, e.g., 'minor pentatonic'"""
    name: str
    elements: list[Deck]

    def ddesc(self) -> str:
        """Debug description"""
        return f"{self.name}={', '.join(repr(deck) for deck in self.elements)}"

    def gist(self) -> str:
        """A readable string unique enough for a shortlist"""
        return f"{self.name}={', '.join(deck.guid for deck in self.elements)}"


@dataclasses.dataclass
class Book:
    """A collection of etudes or pointers to other books"""
    toc: TableOfContents
    sequential: bool = False
    deck: Deck = dataclasses.field(init=False)
    gists: list[str] = dataclasses.field(init=False)
    shortlist: list[str] = dataclasses.field(init=False)

    def ddesc(self) -> str:
        """A debug description"""
        parens = "[]" if self.sequential else "{}"
        return f"{parens[0]}{len(self.deck)} of {len(self.toc)}{parens[1]}"

    def draw(self) -> Playable:
        """Get the next random playable"""
        while (gist := self.deck.draw()) not in self.shortlist:
            continue
        return self.toc[self.gists.index(gist)]

    def num_active_etudes(self) -> int:
        """Return the number of different etudes currently drawable"""
        return len(self.shortlist)

    @contextlib.contextmanager
    def limit_etudes(self, max_etudes: int | None):
        """Select a shortlist.

        Use as context manager:
        ```
        with book.limit_etudes(3):
            book.draw()
        ```
        """
        if max_etudes and 0 < max_etudes < len(self.gists):
            self.shortlist = self.deck.peek(max_etudes)
        else:
            self.shortlist = self.gists

        try:
            yield
        finally:
            self.shortlist = self.gists

    def append(self, playable: Playable):
        """Add an entry to the TOC"""
        self.toc.append(playable)

    def finalize(self, name: str) -> Deck:
        """(Re)create the deck"""
        self.gists = [entry.gist() for entry in self.toc]
        self.shortlist = self.gists
        self.deck = Deck(self.shortlist, guid=name)
        return self.deck


@dataclasses.dataclass
class BookRef:
    """A reference to a book"""
    name: str
    num_etudes: int | None = None
    book: Book = dataclasses.field(init=False)

    def ddesc(self) -> str:
        """Debug description"""
        return f"{self.gist()} ({self.name})"

    def gist(self) -> str:
        """A readable string unique enough for a shortlist.

        Note that we don't want the gist to change if the
        referenced book changes, to avoid a domino effect.
        """
        if self.num_etudes:
            return f"{self.num_etudes}@{self.name}"
        return f"={self.name}"


DEFAULT_CONFIG = """
note:  # Just pick a note
  : ANY

scale:  # Play a scale
  -major: major
  -major: major  # Duplicate an entry to give it more weight
  -natural minor: minor
  -harmonic minor: minor
  -melodic minor: minor

mode:  # Play a mode
  ' ionian': ionian
  ' dorian': dorian
  ' phrygian': phrygian
  ' lydian': lydian
  ' mixolydian': mixolydian
  ' aeolian': aeolian
  ' locrian': locrian

arp:  # Play an arpeggio
  M: major
  m: minor
  ⁷: major
  m⁷: minor
  M⁷: major
  ' major pentatonic': major
  ' minor pentatonic': minor
"""


class Configuration(NamedTuple):
    """The information from the config file"""
    books: dict[str, Book]
    starred: list[str]


# pylint: disable-next=too-many-instance-attributes
class PracticeMakesPerfect:
    """Practice Makes Perfect"""

    parser: argparse.ArgumentParser
    args: argparse.Namespace

    def parse_command_line(self) -> None:
        """Command-line"""
        parser = argparse.ArgumentParser(description=__doc__)
        parser.add_argument(
            "books",
            metavar="BOOK",
            type=str,
            nargs="*",
            help="Choose books from this list",
        )

        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "-n",
            "--num-tracks",
            type=int,
            help="Number of tracks (etude × key) to generate",
        )
        group.add_argument(
            "-N",
            "--one-of-each",
            action="store_true",
            help="Make one track per etude in the chosen book",
        )

        parser.add_argument(
            "-i",
            "--max-etudes",
            type=int,
            help="Use at most this number of etudes",
        )
        parser.add_argument(
            "-m",
            "--multiline",
            action="store_true",
            help="Always print tracks on separate lines",
        )
        parser.add_argument(
            "-d",
            "--debug",
            action="store_true",
            help="Print lots of debugging information",
        )
        parser.add_argument(
            "-c",
            "--config",
            type=Path,
            default=Path.home() / ".pmprc",
            help="Path for config file",
        )
        parser.add_argument(
            "-s",
            "--state-file",
            type=Path,
            default=Path.home() / ".pmpstate.plist",
            help="Path for state file",
        )
        parser.add_argument(
            "-S",
            "--saveless",
            action="store_true",
            help="Don't save state file",
        )
        self.args = parser.parse_args()
        self.parser = parser

    _LETTERS = "CDEFGAB"
    _MODES = (
        "ionian",
        "dorian",
        "phrygian",
        "lydian",
        "mixolydian",
        "aeolian",
        "locrian",
    )

    PITCH_CLASSES: list[PitchClass] = [
        ("C",),
        ("C♯", "D♭"),
        ("D",),
        ("D♯", "E♭"),
        ("E",),
        ("F",),
        ("F♯", "G♭"),
        ("G",),
        ("G♯", "A♭"),
        ("A",),
        ("A♯", "B♭"),
        ("B",),
    ]

    SCALE_FIX: dict[str, dict[str, str]] = {
        "ANY": {},
        "major": {
            "G♯": "A♭",
            "D♯": "E♭",
            "A♯": "B♭",
        },
        "minor": {
            "G♭": "F♯",
            "D♭": "C♯",
            "A♭": "G♯",
        }
    }

    books: dict[str, Book]
    decks: dict[str, Deck]
    config: Configuration
    log: logging.Logger
    state: dict

    STATE_VERSION = "v1"

    def main(self) -> None:
        """Practice Makes Perfect"""
        self.parse_command_line()
        self.configure_logging()

        if self.args.books == ["default-config"]:
            print(DEFAULT_CONFIG)
            return

        self.make_mode_decks()
        self.configure()
        self.load_state()
        self.make_all_decks()

        self.run_book(
            self.choose_book(),
            None if self.args.one_of_each else self.args.num_tracks,
            spaced=True,
        )
        if not self.args.saveless:
            self.save_state()

    def configure_logging(self):
        """Set logging format and level"""
        self.log = logging.getLogger("pmp")
        handler = logging.StreamHandler()
        handler.setFormatter(
            LevelFormatter({
                logging.INFO: "%(message)s",
                logging.DEBUG: "DEBUG [%(module)s:%(lineno)d] %(message)s",
            })
        )

        if self.args.debug:
            level = logging.DEBUG
        else:
            level = logging.INFO
        self.log.setLevel(level)
        self.log.addHandler(handler)

    def run_book(self, book: Book, num_tracks: int | None, spaced=False):
        """Run any book"""
        if book.sequential:
            self.run_sequential(book, spaced=spaced)
        else:
            self.run_plain(book, num_tracks)

    def run_sequential(self, book: Book, spaced: bool) -> None:
        """Run a sequence of items"""
        for entry in book.toc:
            if isinstance(entry, Etude):
                print(self.make_track(entry))
            else:
                self.run_book(entry.book, entry.num_etudes)
            if spaced:
                print("")

    def run_plain(self, book: Book, num_tracks: int | None):
        """Run a "simple" book, choosing etudes and assigining keys"""
        with book.limit_etudes(self.args.max_etudes):
            if num_tracks is None:
                num_tracks = book.num_active_etudes()
            elif num_tracks == 0:
                num_tracks = len(self.PITCH_CLASSES)

            etude_seq = self.choose_etudes(book, num_tracks)
        track_seq = self.make_tracks(etude_seq)

        print(self.get_sep(track_seq).join(track_seq))

    def choose_etudes(
        self,
        book: Book,
        count: int
    ) -> Iterable[Etude]:
        """Yields chosen etudes"""
        for _ in range(count):
            entry = book.draw()
            if isinstance(entry, Etude):
                yield entry
            else:  # Recall: no cycles
                yield from self.choose_etudes(
                    self.books[entry.name],
                    entry.num_etudes or 1
                )

    def choose_book(self) -> Book:
        """Pick out a book"""
        if self.args.books:
            names = self.args.books
            if (unknown := set(names) - set(self.books)):
                self.fail(f"Unknown book(s): {' '.join(unknown)}")
        else:
            names = self.config.starred
        name = random.choice(names)
        return self.books[name]

    def make_tracks(
        self,
        etude_seq: Iterable[Etude],
    ) -> list[str]:
        """Pick a key (or selection of keys) for each etude"""
        return [
            self.make_track(etude)
            for etude in etude_seq
        ]

    def make_track(self, etude: Etude) -> str:
        """Pick a key for one etude"""
        keys = []
        for deck in etude.elements:
            key = deck.draw()
            if "|" in key:  # Can only come from our pitch classes
                key = random.choice(key.split("|"))
            keys.append(key)

        if "{}" in etude.name:
            return "".join((
                keys.pop(0) if part == "{}" else part
                for part in re.split(r"({})", etude.name)
            ))

        return f"{keys[0]}{etude.name}"

    def get_sep(self, tracks: list[str]) -> str:
        """Return space or newline separator"""
        if self.args.multiline:
            return "\n"
        if any(" " in track for track in tracks):
            return "\n"
        if sum(len(track) for track in tracks) + len(tracks) >= 80:
            return "\n"
        return " "

    def make_mode_decks(self) -> None:
        """Start `self.decks` with the Greek modes and their hypotheticals"""
        model = self.SCALE_FIX["major"]
        mapping: dict[str, str]

        for offset, mode in enumerate(self._MODES):
            mapping = {
                note: self._LETTERS[(idx + offset) % len(self._LETTERS)]
                for idx, note in enumerate(self._LETTERS)
            }

            def modify(note: str) -> str:
                try:
                    return mapping[note[0]] + note[1:]
                except KeyError:
                    return note

            self.SCALE_FIX[mode] = {
                modify(key): modify(value)
                for key, value in model.items()
            }

        self.decks = {}
        for scale, fixes in self.SCALE_FIX.items():
            self.have_deck(Deck(
                [
                    "|".join((fixes.get(note, note) for note in pitch_class))
                    for pitch_class in self.PITCH_CLASSES
                ],
                guid=scale,
            ))
        self.have_deck(Deck(guid="NONE", cards=[""]))
        self.log.debug("Key decks: %s", list(self.decks.values()))

    def have_deck(self, deck: Deck) -> Deck:
        """Add a deck to our records"""
        return self.decks.setdefault(deck.guid, deck)

    def configure(self) -> None:
        """Fix configuration files, defaults, etc."""
        try:
            with open(self.args.config, "r", encoding="UTF-8") as fobj:
                self.config = self.parse_config(str(self.args.config), fobj)
        except (FileNotFoundError, ValueError):
            self.config = self.parse_config("", io.StringIO(DEFAULT_CONFIG))
        self.books = self.config.books
        self.finalize_books()

    def load_state(self) -> None:
        """Read saved state info `self.state`

        Sets `self.state`.
        """
        try:
            with open(self.args.state_file, "rb") as fobj:
                loaded = plistlib.load(fobj)
            self.state = loaded[self.STATE_VERSION]
        except (FileNotFoundError, plistlib.InvalidFileException, KeyError):
            self.state = {}
        self.state.setdefault("deck", {})

    def save_state(self) -> None:
        """Save the queue state"""
        saveds = self.state["deck"]
        for guid in list(saveds):
            if not (deck := self.decks.get(guid)):
                try:
                    description = saveds[guid][Deck.DESCRIPTION_KEY]
                    self.log.debug("%s is gone", description)
                except (KeyError, TypeError):
                    self.log.debug("%r is gone", guid)
            # elif not deck.queue:
            #     self.log.debug("%r is done", deck)
            else:
                continue
            del saveds[guid]

        used = []
        for key, deck in self.decks.items():
            if deck.serializable():
                saveds[key] = deck.serialize()
                used.append(repr(deck))
        if used:
            self.log.debug("Saving %d: %s", len(used), " ‖ ".join(used))

        # For the human reading that file
        self.state["debug"] = {
            "decks": {"n": len(self.decks)} | {
                guid: deck.ddesc()
                for guid, deck in self.decks.items()
            },
            "books": {"n": len(self.books)} | {
                f"{name} {book.ddesc()}": [entry.ddesc() for entry in book.toc]
                for name, book in self.books.items()
            }
        }

        with open(self.args.state_file, "wb") as fobj:
            plistlib.dump(
                {self.STATE_VERSION: self.state},
                fobj,
                sort_keys=False,
            )

    def make_all_decks(self) -> None:
        """Prepare randomizers"""
        # Make sure all etude and book decks are registered
        self.log.debug("All books: %s", list(self.books))
        for book in self.books.values():
            for etude in book.toc:
                if isinstance(etude, Etude):
                    etude.elements = [
                        self.have_deck(deck)
                        for deck in etude.elements
                    ]

        # Restore states for any eligible deck
        saveds = self.state["deck"]
        n_used = 0
        for guid in list(self.decks):
            if (saved := saveds.get(guid)) is None:
                continue
            deck = self.decks[guid]
            try:
                deck.deserialize(saved)
                self.log.debug("Loaded %s -> %s", deck, deck.queue)
                n_used += 1
            except CannotRestore as exc:
                self.log.debug("Forgetting saved state for %s: %s", guid, exc)
                del self.decks[guid]

        self.log.debug("Resuming %d of %d decks", n_used, len(self.decks))

    def parse_config(self, filename: str, stream: TextIO) -> Configuration:
        """Read configuration file"""
        try:
            named_decks = {deck.guid: deck for deck in self.decks.values()}
            return ConfigParser(named_decks).parse(filename, stream)
        except BadConfig as err:
            self.fail(str(err))
            raise err  # Won't happen, just to appease pyright

    def finalize_books(self) -> None:
        """Check configured graph is legit and prepare all books for action"""
        graph = defaultdict(set)
        for name, book in self.books.items():
            for ref in book.toc:
                if not isinstance(ref, BookRef):
                    continue
                graph[ref.name].add(name)
                ref.book = self.books[ref.name]

        if (missing := graph.keys() - self.books.keys()):
            error = ", ".join(
                f"{name} (used by {', '.join(graph[name])})"
                for name in missing
            )
            self.fail(f"Unknown reference(s): {error}")

        try:
            topo = graphlib.TopologicalSorter(graph)
            order = list(topo.static_order())
        except graphlib.CycleError as exc:
            self.fail(f"Cyclical configuration: {' -> '.join(exc.args[1])}")

        # The hash of a book depends on the guids of book refs in the toc
        order.extend(self.books.keys() - set(order))
        for name in reversed(order):
            book = self.books[name]
            book.deck = self.have_deck(book.finalize(name))

    def fail(self, message: str) -> NoReturn:
        """Handy wrapper around ArgumentParser's `.fail()` method"""
        self.parser.error(message)


class ConfigParser:
    """Read configuration file"""
    books: dict[str, Book] = {}
    starred: list[str] = []
    curr: Book | None = None
    line_num: int
    line: str
    mobj: re.Match | None

    def __init__(self, named_decks: dict[str, Deck]):
        self.named_decks = named_decks

    def match(self, expr: str) -> bool:
        """Handy wrapper around `re.fullmatch` for the current line"""
        self.mobj = re.fullmatch(expr, self.line)
        return bool(self.mobj)

    def group(self, group: int | str) -> str:
        """Group from previous `self.match()`."""
        assert self.mobj is not None
        return self.mobj.group(group)

    PART_RE = r"(?P<at>(?P<num>[1-9]\d*)?@)?(?P<book>\S+)"

    def parse(self, filename: str, stream: TextIO) -> "Configuration":
        """Read configuration file"""
        try:
            return self.do_parse(stream)
        except BadConfig as exc:
            raise BadConfig(f"[{filename}:{self.line_num}] {exc}") from exc

    def do_parse(self, stream: TextIO) -> "Configuration":
        """The actual reading function"""
        for self.line_num, line in enumerate(stream, 1):
            self.line = re.sub(r"\s*(#.*)?$", "", line)

            if self.match(r"([*]?)(\S[^:]*):"):
                self.enter_book(name=self.group(2).strip(), star=self.group(1))
            elif self.match(r"\s+([^:]*):\s+(.*)"):
                self.add_etude(
                    name=self.group(1).strip(),
                    description=self.group(2).strip(),
                )
            elif self.match(f"\\s+{self.PART_RE}\\s*") and self.group("at"):
                self.add_ref()
            elif self.match(r"(?P<name>[^=]*)\s*=\s*{(?P<parts>[^}]*)}"):
                self.add_one_liner(sequential=False)
            elif self.match(r"(?P<name>[^=]*)\s*=\s*\[(?P<parts>[^]]*)\]"):
                self.add_one_liner(sequential=True)
            elif not self.match(r""):
                raise BadConfig(f"Bad line: {repr(self.line)}")

        return Configuration(
            books=self.books,
            starred=self.starred or list(self.books),
        )

    def enter_book(self, name: str, star: str) -> None:
        """Found a book line"""
        if name in self.books:
            raise BadConfig(f"Duplicate name: {repr(name)}")

        self.books[name] = self.books[name] = self.curr = Book([])
        if star == "*":
            self.starred.append(name)

    def add_etude(self, name: str, description: str) -> None:
        """Found an etude line"""
        if self.curr is None:
            raise BadConfig("Bookless etude")

        if name and name[0] in "'\"" and name[-1] == name[0]:
            name = name[1:-1]

        if re.fullmatch(r"({[^}]*}\s*)+", description.strip()):
            parts = [
                substr[1:-1]
                for substr in re.findall(r"{[^{}]*}", description)
            ]
        else:
            parts = [description]

        num_placeholders = len(re.findall(r"{}", name)) or 1
        if len(parts) != num_placeholders:
            raise BadConfig("Placeholder mismatch")

        elements: list[Deck] = []
        for part in parts:
            try:
                elements.append(self.named_decks[part])
            except KeyError:
                elements.append(Deck([key.strip() for key in part.split("|")]))
        self.curr.append(Etude(name=name, elements=elements))

    def add_ref(self) -> None:
        """Add book reference line (in self.mobj)"""
        if self.curr is None:
            raise BadConfig("Bookless reference")
        assert self.mobj is not None
        self.add_ref_to(self.curr.toc, self.mobj)

    def add_one_liner(self, sequential: bool) -> None:
        """A one-liner is in `self.group("name" | "parts")`"""
        name = self.group("name").strip()
        if (starred := name.startswith("*")):
            name = name[1:]
        if name in self.books:
            raise BadConfig(f"Duplicate {repr(name)}")

        parts = self.group("parts").split()
        if not parts:
            raise BadConfig(f"Empty one-liner {name}")

        toc: TableOfContents = []
        for part in parts:
            if not (mobj := re.fullmatch(self.PART_RE, part)):
                raise BadConfig(f"Bad {repr(part)}")
            self.add_ref_to(toc, mobj)
        self.books[name] = Book(toc=toc, sequential=sequential)

        if starred:
            self.starred.append(name)

    def add_ref_to(self, toc: TableOfContents, mobj: re.Match):
        """Add book reference to a given TOC"""
        if (nstr := mobj.group("num")):
            num = int(nstr)
        elif mobj.group("at"):
            num = 1
        else:
            num = None
        toc.append(BookRef(num_etudes=num, name=mobj.group("book")))


if __name__ == "__main__":
    PracticeMakesPerfect().main()
