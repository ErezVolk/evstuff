#!/usr/bin/env python3
"""Shuffle chapters in a PDF file"""
from argparse import ArgumentParser
from argparse import Namespace
from pathlib import Path
import pickle

import numpy.random as npr
import pandas as pd
import fitz  # type: ignore; pip install pymupdf

# We only use bookmarks that point to a new page
TOP_OF_PAGE = fitz.Point(0, 0)


def parse_command_line() -> Namespace:
    """Command-line arguments"""
    parser = ArgumentParser(description="Shuffle chapters in a PDF file")
    parser.add_argument("input", type=Path, nargs="?", help="PDF file to shuffle")
    parser.add_argument(
        "output", type=Path, nargs="?", help="Shuffled PDF file to create"
    )
    parser.add_argument("-p", "--shuffle-pages", action="store_true")
    parser.add_argument("-e", "--keep-empty-pages", action="store_true")
    parser.add_argument("-f", "--first-chapter", type=int, default=1)
    parser.add_argument("-l", "--last-chapter", type=int, default=-1)
    parser.add_argument(
        "--min",
        type=int,
        default=1,
        metavar="NNN",
        help="Throw away chapters with less than NNN pages",
    )
    parser.add_argument(
        "--max",
        type=int,
        metavar="NNN",
        help="Throw away chapters with more than MAX pages",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-r", "--reverse", action="store_true", help="Reverse order")
    group.add_argument("-s", "--seed", type=int, help="Set random seed")
    group.add_argument(
        "-S",
        "--seed-file",
        type=Path,
        nargs="?",
        default=False,
        const=True,
        help="Load or generate and save random seed",
    )
    group.add_argument("--no-shuffle", action="store_true", help="No shuffling")
    return parser.parse_args()


def main():
    """Shuffle chapters in a PDF file"""
    args = parse_command_line()

    if args.input is None:
        pdfs = [
            pdf
            for pdf in Path.cwd().glob("*.pdf")
            if not pdf.stem.endswith("-shuffled")
        ]
        if len(pdfs) != 1:
            print("Please specify input file")
            return
        args.input, = pdfs
        input(f"Press Enter to shuffle '{args.input.name}'...")

    if args.output is None:
        args.output = args.input.with_stem(f"{args.input.stem}-shuffled")

    print(f"{args.input} -> {args.output}")

    indoc = fitz.Document(args.input)
    n_pages = indoc.page_count
    if n_pages < 2:
        print(f"Not enough pages ({n_pages}) in document")
        return

    if args.shuffle_pages:
        chaps = pd.DataFrame.from_records([
            {
                "first_1": n_page,
                "title": f"{args.input.name}:{n_page}",
                "n_fonts": len(page.get_fonts()),
            }
            for n_page, page in enumerate(indoc, 1)
        ])
        if not args.keep_empty_pages:
            chaps = chaps.query("n_fonts > 0")
    else:
        # In most PyMuPDF APIs, page numbers are 0-based, but in the toc they're 1-based
        toc = [
            {"first_1": entry[2], "title": entry[1]}
            for entry in indoc.get_toc(simple=False)
            if entry[3].get("to", TOP_OF_PAGE) == TOP_OF_PAGE
        ]
        if len(toc) < 1:
            print("No relevant bookmarks in document")
            return

        chaps = pd.DataFrame.from_records(toc, index="first_1")
        if 1 not in chaps.index:
            chaps.loc[1, "title"] = f"{args.input.name}:1"

        chaps.loc[n_pages + 1, "title"] = "END"
        chaps = chaps.sort_index().reset_index()

    if (n_chaps := len(chaps)) < 2:
        print(f"Not enough bookmarks in {args.input}")
        return

    first_idx = num_to_idx(args.first_chapter, n_chaps)
    last_idx = num_to_idx(args.last_chapter, n_chaps)

    if not 0 <= first_idx <= last_idx < n_chaps:
        print(f"Document has {n_chaps} chapters, doens't fit")
        return

    chaps = chaps.iloc[first_idx:last_idx].copy()

    chaps["next_1"] = chaps.first_1.shift(-1, fill_value=0)
    chaps["length"] = chaps.next_1 - chaps.first_1
    chaps["first_0"] = chaps.first_1 - 1
    chaps["last_0"] = chaps.next_1 - 2

    chaps = chaps.loc[chaps.length >= args.min]
    if args.max:
        chaps = chaps.loc[chaps.length <= args.max]

    if args.no_shuffle:
        pass  # Leave as-is
    elif args.reverse:
        chaps = chaps[::-1]
    else:
        rng = randomize(args)
        chaps = chaps.sample(frac=1, random_state=rng.bit_generator)

    outdoc = fitz.Document()
    outtoc = []

    for _, chap in chaps.iterrows():
        outtoc.append((1, chap.title, outdoc.page_count + 1))
        outdoc.insert_pdf(indoc, chap.first_0, chap.last_0, final=False)
    outdoc.set_toc(outtoc)

    if not args.keep_empty_pages:
        for pno in range(outdoc.page_count - 1, 0, -1):
            if not outdoc.get_page_fonts(pno):
                outdoc.delete_page(pno)

    if outdoc.page_count < indoc.page_count:
        print(f"Number of pages in {args.input}: {indoc.page_count}")
        print(f"Number of pages in {args.output}: {outdoc.page_count}")
    outdoc.ez_save(args.output)


def randomize(args: Namespace) -> npr.Generator | None:
    """Set random seed"""
    generator = npr.default_rng(seed=args.seed)

    if args.seed_file is True:
        args.seed_file = args.output.with_suffix(".seed")

    if args.seed_file:
        try:
            with open(args.seed_file, "rb") as fobj:
                loaded = pickle.load(fobj)
            if not isinstance(loaded, npr.Generator):
                print(f"Incompatible {args.seed_file}, regenerating")
                raise TypeError()
            print(f"Random state loaded from {args.seed_file}")
            generator = loaded
        except (FileNotFoundError, TypeError, pickle.UnpicklingError):
            print(f"Saving random state to {args.seed_file}")
            with open(args.seed_file, "wb") as fobj:
                pickle.dump(generator, fobj)
    return generator


def num_to_idx(num: int, n_chaps: int) -> int:
    """Convert, e.g., --first-chapter=1 to 0"""
    if num > 0:
        return num - 1
    if num < 0:
        return n_chaps + num
    return 0


if __name__ == "__main__":
    main()
