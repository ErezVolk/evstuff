#!/usr/bin/env python3
"""Shuffle chapters in a PDF file"""
from argparse import ArgumentParser
from argparse import Namespace
import itertools
from pathlib import Path
import pickle
import random

import fitz  # type: ignore; pip install pymupdf

# We only use bookmarks that point to a new page
TOP_OF_PAGE = fitz.Point(0, 0)


def parse_command_line() -> Namespace:
    """Command-line arguments"""
    parser = ArgumentParser(description="Shuffle chapters in a PDF file")
    parser.add_argument("input", type=Path, help="PDF file to shuffle")
    parser.add_argument(
        "output", type=Path, nargs="?", help="Shuffled PDF file to create"
    )
    parser.add_argument("-e", "--keep-empty-pages", action="store_true")
    parser.add_argument(
        "--min",
        type=int,
        metavar="NNN",
        help="Throw away chapters with less than NNN pages",
    )
    parser.add_argument(
        "--max",
        type=int,
        metavar="NNN",
        help="Throw away chapters with more than MAX pages",
    )
    group = parser.add_mutually_exclusive_group()
    group.add_argument("-s", "--seed", type=int)
    group.add_argument("-S", "--seed-file", type=Path, nargs="?", default=False, const=True)
    return parser.parse_args()


def main():
    """Shuffle chapters in a PDF file"""
    args = parse_command_line()

    args.input = args.input
    if args.output is None:
        args.output = args.input.with_stem(f"{args.input.stem}-shuffled")

    print(f"{args.input} -> {args.output}")

    randomize(args)

    indoc = fitz.Document(args.input)
    n_pages = indoc.page_count
    if n_pages < 2:
        print(f"Not enough pages ({n_pages}) in document")
        return

    bookmarks: dict[int, str] = {
        entry[2] - 1: entry[1]  # ToC entries are 1-based
        for entry in indoc.get_toc(simple=False)
        if entry[3].get("to") == TOP_OF_PAGE
    }
    bookmarks.setdefault(0, "(START)")
    if len(bookmarks) < 2:
        print(f"Not enough bookmarks in {args.input}")
        return

    bookmarks.setdefault(n_pages, "(END)")
    spans = list(pairwise(sorted(bookmarks)))
    if args.min:
        spans = [
            (span_from, span_to)
            for (span_from, span_to) in spans
            if span_to >= span_from + args.min
        ]
    if args.max:
        spans = [
            (span_from, span_to)
            for (span_from, span_to) in spans
            if span_to <= span_from + args.max
        ]
    random.shuffle(spans)

    outdoc = fitz.Document()
    outtoc = []

    for nspan, (span_from, span_to) in enumerate(spans, 1):
        outtoc.append((1, bookmarks[span_from], outdoc.page_count + 1))
        outdoc.insert_pdf(indoc, span_from, span_to - 1, final=nspan == len(spans))
    outdoc.set_toc(outtoc)

    if not args.keep_empty_pages:
        for pno in range(outdoc.page_count - 1, 0, -1):
            if not outdoc.get_page_fonts(pno):
                outdoc.delete_page(pno)

    if outdoc.page_count < indoc.page_count:
        print(f"Number of pages in {args.input}: {indoc.page_count}")
        print(f"Number of pages in {args.output}: {outdoc.page_count}")
    outdoc.ez_save(args.output)


def randomize(args: Namespace):
    """Set random seed"""
    if args.seed_file:
        if args.seed_file is True:
            seed_fn = args.output.with_suffix(".seed")
        else:
            seed_fn = args.seed_file
        try:
            with open(seed_fn, "rb") as fobj:
                random.setstate(pickle.load(fobj))
            print(f"Random state loaded from {seed_fn}")
        except (FileNotFoundError, TypeError, pickle.UnpicklingError):
            print(f"Saving random state to {seed_fn}")
            random.seed()
            with open(seed_fn, "wb") as fobj:
                pickle.dump(random.getstate(), fobj)
    elif args.seed is not None:
        random.seed(args.seed)


def pairwise(iterable):
    """Return successive overlapping pairs taken from the input iterable.

    Added in Python 3.10.
    """
    try:
        return itertools.pairwise(iterable)
    except AttributeError:
        # pairwise('ABCDEFG') --> AB BC CD DE EF FG
        a_iter, b_iter = itertools.tee(iterable)
        next(b_iter, None)
        return zip(a_iter, b_iter)


if __name__ == "__main__":
    main()
