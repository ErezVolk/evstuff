#!/usr/bin/env python3
"""Random musical keys for practice"""
import argparse
import itertools
import random
from collections.abc import Iterable
import typing

T = typing.TypeVar("T")

NOTES = (
    ("A"),
    ("A♯", "B♭"),
    ("B"),
    ("C"),
    ("C♯", "D♭"),
    ("D"),
    ("D♯", "E♭"),
    ("E"),
    ("F"),
    ("F♯", "G♭"),
    ("G"),
    ("G♯", "A♭"),
)

KEY_FIX = {
    "maj": {"A♯": "B♭", "D♯": "E♭", "C♯": "D♭", "G♯": "A♭"},
    "min": {"A♯": "B♭", "A♭": "G♯", "D♭": "C♯", "D♯": "E♭", "G♭": "F♯"},
}

DRILLS = (
    "octaves", "fifths", "fourths", "chairs"
)

EASY_CHORDS = {
    "maj": KEY_FIX["maj"],
    "min": KEY_FIX["min"],
    "⁷": KEY_FIX["maj"] | {"F♯": "G♭"},
    "m⁷": KEY_FIX["min"],
    "M⁷": KEY_FIX["maj"],
}

CHORDS = EASY_CHORDS | {
    "dim⁷": KEY_FIX["min"] | {"B♭": "A♯", "F": "E♯"},
    "⁶": KEY_FIX["maj"],
    "m7♭5": KEY_FIX["min"],
}

DEFAULT_COUNTS = {
    "easy-chords": 3,
    "chords": 4,
}
DEFAULT_COUNT = len(NOTES)


def main():
    """Random musical keys for practice"""
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "what",
        choices=["notes", "scales", "arps", "drills", "easy-chords", "chords"],
        default="drills",
        nargs="?",
    )
    parser.add_argument(
        "-n",
        "--count",
        type=int,
    )
    parser.add_argument(
        "-c",
        "--chords",
        type=str,
        nargs="+"
    )
    args = parser.parse_args()

    if args.count is None:
        args.count = DEFAULT_COUNTS.get(args.what, DEFAULT_COUNT)

    if "chords" in args.what:
        sep = "\n"
        if args.chords is not None:
            choices = args.chords
        elif args.what == "easy-chords":
            choices = EASY_CHORDS
        else:
            choices = CHORDS
        notes = random.choice(NOTES)
        start = random.choice(notes)
        things = [f"* start from {'/'.join(notes)}"] + [
            f" - {CHORDS[chord].get(start, start)}{chord}, etc."
            for chord in choose(choices, args.count)
        ]
    elif args.what == "notes":
        sep = " "
        things = [
            random.choice(names)
            for names in choose(NOTES, args.count)
        ]
    else:
        if args.what == "arps":
            fix = EASY_CHORDS
        else:
            fix = KEY_FIX

        if args.count <= len(NOTES):
            # We can have one of each root
            sep = " "
            roots = [
                random.choice(names)
                for names in choose(NOTES, args.count)
            ]
            scales = choose(fix, len(roots))
            things = [
                fix[scale].get(root, root) + scale
                for root, scale in zip(roots, scales)
            ]
        else:
            sep = "\n"
            all_rset_scales = list(itertools.product(NOTES, fix))
            things = [
                fix[scale].get(root, root) + scale
                for rset, scale in choose(all_rset_scales, args.count)
                for root in [random.choice(rset)]
            ]

        if args.what == "drills":
            drills = choose(DRILLS, len(things))
            things = [
                f"{thing} in {drill}"
                for thing, drill in zip(things, drills)
            ]
            sep = "\n"

    print(sep.join(things))


def choose(options: Iterable[T], n: int) -> list[T]:
    """Choose so we have as many "full" repetitions and a random tail"""
    opts = list(options)
    nopts = len(opts)

    if n <= nopts:
        return random.sample(opts, max(n, 1))

    ntail = n % nopts
    n_full_rounds = (n - ntail) // nopts

    choices = (opts * n_full_rounds) + random.sample(opts, ntail)

    random.shuffle(choices)
    return choices


if __name__ == "__main__":
    main()
