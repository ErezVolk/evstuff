#!/bin/sh
# vim: set sw=2 et:
# Update Git repo and pull if safe, without excessive traffic.

usage() {
  echo "git o [-l] [-p] [-q] [-h] [-m branch]"
  echo ""
  echo "options:"
  echo " -h           show this help message and exit"
  echo " -q           output nothing if local is identical to remote"
  echo " -m BRANCH    merge with BRANCH"
  echo " -l           perform no server communication"
  echo " -p           push if the local branch is ahead of the remote"
}


QUIET=""
LOCAL=""
PUSH=""
MERGE=""
while getopts ":lpqhm:" opt; do
  case ${opt} in
    l)
      LOCAL="y"
      ;;
    p)
      PUSH="y"
      ;;
    q)
      QUIET="y"
      ;;
    m)
      MERGE=${OPTARG}
      ;;
    h)
      usage
      exit 1
      ;;
    ?)
      echo "Invalid option: -${OPTARG}."
      usage
      exit 1
      ;;
  esac
done

outf=$(mktemp)
errf=$(mktemp)
trap "rm -f $outf $errf" EXIT

do_git()
{
  git "$@" >$outf 2>$errf
  code=$?
  cat $outf
  cat $errf | sed -e "s/^/$PREFIX/" >&2
  return $code
}

show_git()
{
  do_git "$@" | sed -e "s/^/$PREFIX/" >&2
}

set_title()
{
  printf "\033]0;$1\007"
}

ROOT=$(git rev-parse --show-toplevel) || exit  # Fails if not a Git repo
NAME=$(basename $ROOT)
PREFIX="[$NAME] "

bold=$(tput bold)
offbold=$(tput sgr0)

# echo "\033]0;git fetch $ROOT\007… $ROOT"
set_title "git fetch $ROOT"
[ -n "${LOCAL}" ] || show_git fetch --quiet --prune --all || exit   # Fails if no remote; this is the only server communication

REMOTE=$(do_git rev-parse @{u}) || exit  # Fails if not a remote-tracking branch
LOCAL=$(do_git rev-parse @)
BASE=$(do_git merge-base $LOCAL $REMOTE)

on_pushable()
{
  if [ -z "${PUSH}" ]; then
    echo "${bold}⇡${offbold} $ROOT"  # Need to push
  else
    echo "${bold}↥${offbold} $ROOT"  # Pushing
    show_git push
  fi
}

STATUS=$(do_git status --porcelain --untracked-files=no)
if [ -n "$STATUS" ]; then
    echo "${bold}!${offbold} $ROOT"  # Local uncommitted changes
elif [ $LOCAL = $REMOTE ]; then
    [ -n "${QUIET}" ] || echo "✔ $ROOT"  # Up to date
    if [ -n "${MERGE}" ]; then
      show_git merge -q --ff-only $MERGE
      NEWLOCAL=$(do_git rev-parse @)
      if [ "${NEWLOCAL}" != "${LOCAL}" ]; then
        on_pushable
      fi
    fi
elif [ $LOCAL = $BASE ]; then
    echo "${bold}⇣${offbold} $ROOT"  # What we can here for
    show_git merge --ff-only $REMOTE
    echo "${bold}↳${offbold} $ROOT"
elif [ $REMOTE = $BASE ]; then
  on_pushable
else
    echo "${bold}⇅${offbold} $ROOT"  # Diverged
fi
