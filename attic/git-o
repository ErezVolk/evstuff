#!/bin/sh
# Update Git repo and pull if safe, without excessive traffic.

QUIET=""
while getopts ":q" opt; do
  case ${opt} in
    q)
      QUIET="y"
      ;;
    ?)
      echo "Invalid option: -${OPTARG}."
      exit 1
      ;;
  esac
done

outf=$(mktemp)
errf=$(mktemp)
trap "rm -f $outf $errf" EXIT

do_git()
{
	git "$@" >$outf 2>$errf
	code=$?
	cat $outf
	cat $errf | sed -e "s/^/$PREFIX/" >&2
	return $code
}

show_git()
{
	do_git "$@" | sed -e "s/^/$PREFIX/" >&2
}

set_title()
{
	printf "\033]0;$1\007"
}

ROOT=$(git rev-parse --show-toplevel) || exit  # Fails if not a Git repo
NAME=$(basename $ROOT)
PREFIX="[$NAME] "

bold=$(tput bold)
offbold=$(tput sgr0)

# echo "\033]0;git fetch $ROOT\007… $ROOT"
set_title "git fetch $ROOT"
show_git fetch --quiet --prune --all || exit   # Fails if no remote; this is the only server communication

REMOTE=$(do_git rev-parse @{u}) || exit  # Fails if not a remote-tracking branch
LOCAL=$(do_git rev-parse @)
BASE=$(do_git merge-base $LOCAL $REMOTE)

STATUS=$(do_git status --porcelain --untracked-files=no)
if [ -n "$STATUS" ]; then
    echo "${bold}!${offbold} $ROOT"  # Local uncommitted changes
elif [ $LOCAL = $REMOTE ]; then
    [ -n "${QUIET}" ] || echo "✔ $ROOT"  # Up to date
elif [ $LOCAL = $BASE ]; then
    echo "${bold}⇣${offbold} $ROOT"  # What we can here for
    show_git merge --ff-only $REMOTE
    echo "${bold}↳${offbold} $ROOT"
elif [ $REMOTE = $BASE ]; then
    echo "${bold}⇡${offbold} $ROOT"  # Need to push
else
    echo "${bold}⇅${offbold} $ROOT"  # Diverged
fi
