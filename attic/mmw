#!/usr/bin/env python3
"""Mark My Words: Save copies of MS Word files on change."""
import argparse
import collections
import subprocess
from pathlib import Path


__TODO__ = """
- Add multiple versions (mwm-1-file.docx)
- Same file multiple times in a batch (--batch-marker)
- Maybe the -0 thing, if I can make it work
- Either per-file .mwm of global one (recursive)
- Roll my own using pyobjc-framework-FSEvents
"""


class MarkMyWord:
    """Save copies of MS Word files on change."""

    def parse_cli(self) -> None:
        """Parse command-line arguments."""
        parser = argparse.ArgumentParser(description=__doc__)
        parser.add_argument(
            "path",
            type=Path,
            nargs="?",
            help="directory in which to watch Word files",
        )
        parser.add_argument(
            "-b", "--backup",
            type=Path,
            help="backup directory",
        )
        parser.add_argument(
            "-l", "--latency",
            type=float,
            default=1.0,
        )
        self.args = parser.parse_args()

    args: argparse.Namespace

    def main(self) -> None:
        """Watch Word files and save them."""
        self.parse_cli()
        watchee = self.args.path
        cmd = [
            "fswatch",
            "-l", str(self.args.latency),
            "-i", r"[.]docx$",
            "-e", ".",
            str(watchee),
        ]
        proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            bufsize=1,
            text=True,
        )
        if proc.stdout is None:
            print("Cannot read output of fswatch")
            return

        counts: collections.Counter = collections.Counter()
        backup = (self.args.backup or Path(".mmw")).resolve()
        backup.mkdir(exist_ok=True, parents=True)
        print(f"Watching {watchee}...")
        try:
            for line in proc.stdout:
                source = Path(line.strip())
                if source.parent != watchee:
                    continue  # No recurse

                if source.is_relative_to(backup):
                    continue  # Just in case we do add recursion

                name = source.name
                if name.startswith("~$"):
                    continue  # Temporary Word files

                if not source.is_file():
                    print(f"*** GONE: {source}")
                    continue

                target = backup / f"mmw-{name}"
                if name not in counts:  # First time
                    print(source, "->", target)

                source.copy(target, preserve_metadata=True)
                counts[name] += 1
        except KeyboardInterrupt:
            print("Report:")
            for name, count in counts.most_common():
                print(f"{count}\t{name}")
            proc.terminate()


if __name__ == "__main__":
    MarkMyWord().main()
