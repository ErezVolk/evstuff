#!/usr/bin/env python3
"""Mark My Words: Save copies of MS Word files on change."""

import argparse  # noqa: I001
import collections
import contextlib
import filecmp
import os
import shutil
import subprocess
import tempfile

from pathlib import Path


__TODO__ = """
- Print status on keypress
- Maybe the -0 thing, if I can make it work
"""


class MarkMyWord:
    """Save copies of MS Word files on change."""

    def parse_cli(self) -> None:
        """Parse command-line arguments."""
        parser = argparse.ArgumentParser(description=__doc__)
        parser.add_argument(
            "path",
            type=Path,
            nargs="?",
            help="directory in which to watch Word files",
        )
        parser.add_argument(
            "-b", "--backup",
            type=Path,
            help="global backup directory (otherwise use per-directory .mmw/)",
        )
        parser.add_argument(
            "-R", "--no-recursion",
            action="store_true",
            help="do not watch files in subdirectories",
        )
        parser.add_argument(
            "-n", "--num-versions",
            type=int,
            default=5,
            help="number of previous versions of file to keep",
        )
        parser.add_argument(
            "-l", "--latency",
            type=float,
            default=3.0,
            help="check events every LATENCY seconds",
        )
        group = parser.add_mutually_exclusive_group()
        group.add_argument(
            "--iterm",
            action="store_true",
            help=(
                "set iTerm2 tab color and title "
                "(default if MMW_ITERM is set)"
            ),
        )
        group.add_argument(
            "--no-iterm",
            action="store_true",
            help=(
                "do NOT set iTerm2 tab color and title "
                "(even if MMW_ITERM is set)"
            ),
        )
        parser.add_argument(
            "--fswatch",
            help="fswatch executable",
        )
        parser.add_argument(
            "-v", "--verbose",
            action="store_true",
            help="print more information",
        )
        self.args = parser.parse_args()
        self.parser = parser

    parser: argparse.ArgumentParser
    args: argparse.Namespace
    batch: collections.Counter
    counts: collections.Counter
    iterm: bool
    tmp: Path | None = None
    watchee: Path

    def main(self) -> None:
        """Watch Word files and save them."""
        self.parse_cli()
        self.choose_locations()
        proc = self.launch_fswatch()
        if proc.stdout is None:
            print("Cannot read output of fswatch")
            return

        self.announce()
        try:
            self.counts = collections.Counter()
            self.batch = collections.Counter()
            for line in proc.stdout:
                event = line.strip()
                if event == "NoOp":
                    self.ship_batch()
                    continue

                source = Path(line.strip())
                if self.args.no_recursion:
                    if source.parent != self.watchee:
                        continue  # No recurse

                if self.is_in_backup(source):
                    continue  # Just in case we do add recursion

                if source.stem.startswith("~$"):
                    continue  # Temporary Word files

                self.batch[source] += 1
        except KeyboardInterrupt:
            self.report()
            proc.terminate()

    def announce(self) -> None:
        """Print start message, optionally set terminal stuff."""
        print(f"Watching {self.watchee}...")
        if self.iterm:
            print("\033]6;1;bg;green;brightness;63\a")
            print(f"\033]0;MMW:{self.watchee.name}/\a")

    def report(self) -> None:
        """Print end message, optionally unset terminal stuff."""
        print("\nReport:")
        for key, count in self.counts.most_common():
            print(f"{count}\t{key}")
        if self.iterm:
            print("\033]6;1;bg;*;default\a")

    def choose_locations(self) -> None:
        """Choose where to watch and where to make temp files."""
        self.watchee = self.args.path or Path.cwd()
        tempdir = Path(tempfile.gettempdir())
        if self.device(self.watchee) == self.device(tempdir):
            self.tmp = tempdir
        if self.args.no_iterm:
            self.iterm = False
        elif self.args.iterm or os.getenv("MMW_ITERM"):
            self.iterm = True
        else:
            self.iterm = False

    def launch_fswatch(self) -> subprocess.Popen:
        """Run the actual utility."""
        fswatch = self.args.fswatch or shutil.which("fswatch")
        if not fswatch:
            self.parser.error("fswatch not found (try brew install fswatch).")

        cmd = [
            fswatch,
            "-l", str(self.args.latency),
            "-i", r"[.]docx$",
            "-e", ".",
            "--batch-marker",
            str(self.watchee),
        ]
        return subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            bufsize=1,
            text=True,
        )

    @classmethod
    def device(cls, path: Path) -> int:
        """Get device ID for a path."""
        return path.stat().st_dev

    def is_in_backup(self, path: Path) -> bool:
        """Check if changed file is a backup itself."""
        if path.parent.name == ".mmw":
            return True
        if not self.args.backup:
            return False
        return path.is_relative_to(self.args.backup)

    def ship_batch(self) -> None:
        """Handle files in the batch."""
        for source, bcount in self.batch.items():
            self.ship_one(source, bcount)
        self.batch = collections.Counter()

    def ship_one(self, source: Path, bcount: int) -> None:
        """Handle one file from the batch."""
        if not source.is_file():
            print(f"*** GONE: {source}")
            return

        name = source.name
        key = name if self.args.no_recursion else str(source)
        target = self.get_backup_dir(source) / f"mmw-{name}"

        if not self.do_copy(source, target):
            return

        rsource = source.relative_to(self.watchee)
        if self.args.backup:
            rtarget = target.relative_to(self.args.backup)
        else:
            rtarget = target.relative_to(self.watchee)

        if key not in self.counts:
            print(f"{rsource} -> {rtarget}")
        elif self.args.verbose:
            count = self.counts[key]
            print(f"{rsource} -> {rtarget} ({count}) [{bcount}]")

        self.counts[key] += 1

    def do_copy(self, source: Path, target: Path) -> bool:
        """Copy a file, but not too much.

        Return True iff file was indeed copied.
        """
        try:
            if not target.is_file():
                source.copy(target, preserve_metadata=True)
                return True

            tdir = self.tmp or target.parent
            with tempfile.NamedTemporaryFile(dir=tdir) as tfo:
                ttarget = Path(tfo.name)
                source.copy(ttarget, preserve_metadata=True)
                if filecmp.cmp(ttarget, target, shallow=False):
                    return False
                self.shift_history(ttarget, target)
                return True
        except (FileNotFoundError, OSError) as exc:
            print(f"*** ERROR: {source}: {exc}")
            return False

    def shift_history(self, temp_target: Path, target: Path) -> None:
        """Move temporary target to target, and shift history."""
        for idx in range(self.args.num_versions - 1, 0, -1):
            with contextlib.suppress(FileNotFoundError):
                self.nth(target, idx).move(self.nth(target, idx + 1))
        temp_target.move(target)

    def nth(self, target: Path, idx: int) -> Path:
        """Return name of idx-th (1-based) version of target."""
        if idx == 1:
            return target
        return target.with_stem(f"{target.stem}.{idx}")

    def get_backup_dir(self, path: Path) -> Path:
        """Create backup directory for a file."""
        backup = self._get_backup_dir(path)
        backup.mkdir(exist_ok=True, parents=True)
        return backup

    def _get_backup_dir(self, path: Path) -> Path:
        """Return backup directory for a file."""
        return self.args.backup or path.parent / ".mmw"


if __name__ == "__main__":
    MarkMyWord().main()
