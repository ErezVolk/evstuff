#!/usr/bin/env python3
"""Mark My Words: Save copies of MS Word files on change."""

import argparse  # noqa: I001
import collections
import subprocess

from pathlib import Path


__TODO__ = """
- Add multiple versions (mwm-1-file.docx)
  - Hash them (.mwm/.hashes or something)
- Maybe the -0 thing, if I can make it work
  - Or do my own wrapper around libfswatch
"""


class MarkMyWord:
    """Save copies of MS Word files on change."""

    def parse_cli(self) -> None:
        """Parse command-line arguments."""
        parser = argparse.ArgumentParser(description=__doc__)
        parser.add_argument(
            "path",
            type=Path,
            nargs="?",
            help="directory in which to watch Word files",
        )
        parser.add_argument(
            "-b", "--backup",
            type=Path,
            help="global backup directory (otherwise use per-directory .mwm/)",
        )
        parser.add_argument(
            "-l", "--latency",
            type=float,
            default=1.0,
        )
        parser.add_argument(
            "-r", "--recursive",
            action="store_true",
            help="global backup directory",
        )
        parser.add_argument(
            "-v", "--verbose",
            action="store_true",
        )
        self.args = parser.parse_args()

    args: argparse.Namespace
    batch: set[Path]
    counts: collections.Counter

    def main(self) -> None:
        """Watch Word files and save them."""
        self.parse_cli()
        watchee = self.args.path or Path.cwd()
        cmd = [
            "fswatch",
            "-l", str(self.args.latency),
            "-i", r"[.]docx$",
            "-e", ".",
            "--batch-marker",
            str(watchee),
        ]
        proc = subprocess.Popen(
            cmd,
            stdout=subprocess.PIPE,
            bufsize=1,
            text=True,
        )
        if proc.stdout is None:
            print("Cannot read output of fswatch")
            return

        print(f"Watching {watchee}...")
        try:
            self.counts = collections.Counter()
            self.batch = set()
            for line in proc.stdout:
                event = line.strip()
                if event == "NoOp":
                    self.ship_batch()
                    continue

                source = Path(line.strip())
                if not self.args.recursive:
                    if source.parent != watchee:
                        continue  # No recurse

                if self.is_in_backup(source):
                    continue  # Just in case we do add recursion

                if source.stem.startswith("~$"):
                    continue  # Temporary Word files

                self.batch.add(source)
        except KeyboardInterrupt:
            print("\nReport:")
            for key, count in self.counts.most_common():
                print(f"{count}\t{key}")
            proc.terminate()

    def is_in_backup(self, path: Path) -> bool:
        """Check if changed file is a backup itself."""
        if path.parent.name == ".mwm":
            return True
        if not self.args.backup:
            return False
        return path.is_relative_to(self.args.backup)

    def ship_batch(self) -> None:
        """Handle files in the batch."""
        for source in self.batch:
            if not source.is_file():
                print(f"*** GONE: {source}")
                continue

            name = source.name
            target = self.get_backup_dir(source) / f"mmw-{name}"
            key = name if self.args.recursive else str(source)
            if key not in self.counts:
                print(source, "->", target)
            elif self.args.verbose:
                print(f"{source} -> {target} ({self.counts[key]})")

            source.copy(target, preserve_metadata=True)
            self.counts[key] += 1
        self.batch = set()

    def get_backup_dir(self, path: Path) -> Path:
        """Return backup directory for a file."""
        backup = self._get_backup_dir(path)
        backup.mkdir(exist_ok=True, parents=True)
        return backup

    def _get_backup_dir(self, path: Path) -> Path:
        """Return backup directory for a file."""
        return self.args.backup or path.parent / ".mwm"


if __name__ == "__main__":
    MarkMyWord().main()
