#!/usr/bin/env python3
"""A utility to convert .docx to InDesign's Tagged Text."""
import argparse
import collections
import configparser
import itertools
import logging
import os
import re
import shutil
import sys
import zipfile

import lxml.etree
import attr

# TODO:
# - For BVM: Something usable with notes
# - For typesetters: some kind of "template" file (alignment, offsets, emphasis, no biggie)
# - For post edit/proof: Manual formatting things, TBD

# - Manual format: autogenerate styles
# - Manual format: collapse with existing styles
# - A flag to only create/update the ini file
# - Maybe add front matter (best done in Id?)
# - some contextlib magic instead of all those finally clauses
# - Something usable for those balloons (footnote+hl? endnote? convert to note in jsx?)
# - Autocreate character styles from manual combos
#   bold: w:b (w:bCs?); italic: w:i (w:iCs?); undeline w:u
#   font: <w:rFonts w:ascii="Courier New" w:hAnsi="Courier New" w:cs="Courier New">
#   override style: <w:i w:val="0">
# - (f)odt import
# - idml import
# - Automatic header group
# - More complex BiDi
# - Endnotes
# - Editing marks
# - Linked styles?
# - Derivation rules?
# - Latent styles?


class StopMarkerFound(Exception):
    """We raise this to stop the presses."""
    pass


class ParseDict(argparse.Action):
    """Helper class to convert KEY=VALUE pairs to a dict."""
    def __call__(self, parser, namespace, values, option_string):
        setattr(namespace, self.dest, dict(val.split('=', 1) for val in values))


@attr.s
class Style(object):
    """A character/paragraph style, normally found in the input file."""
    realm = attr.ib()
    msw_name = attr.ib()
    name = attr.ib(default=None)
    internal_name = attr.ib(default=None)
    parent_msw_name = attr.ib(default=None)
    followed_by_msw_name = attr.ib(default=None)
    used = attr.ib(default=None)
    color = attr.ib(default=None)
    tint = attr.ib(default=None)
    superscript = attr.ib(default=None)
    variable = attr.ib(default=None)

    parent = attr.ib(default=None)
    followed_by = attr.ib(default=None)

    def __str__(self):
        return '<%s %r>' % (self.realm, self.name)


class DocxToIdtt(object):
    """Read a docx file. Write an InDesign Tagged Text file. What's not to like?"""
    W = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    NS = {'w': W}

    MAPPING_ENCODING = 'UTF-8'
    MAPPING_CONFIG_SECTION = 'General'
    SPECIAL_GROUP = '(autogenerated)'
    DEFAULT_BASE = SPECIAL_GROUP + '/(Basic Style)'
    COMMENT_MARK_STYLE = SPECIAL_GROUP + '/(Comment Mark)'
    FOOTNOTE_REF_STYLE = SPECIAL_GROUP + '/(Footnote Reference in Text)'

    def run(self):
        """Main entry point."""
        self.parse_command_line()
        self.configure_logging()
        self.read_mapping()
        self.load_docx()
        self.write_idtt()
        self.report_style_counts()
        self.write_mapping()
        self.write_rerunner()

    def parse_command_line(self):
        """Find out what we're supposed to do."""
        self.parser = argparse.ArgumentParser(description='Word to Indesign Tagged Text')
        self.parser.add_argument('input', help='Input .docx file')
        self.parser.add_argument('output', nargs='?',
                                 help='InDesign Tagged Text file')
        self.parser.add_argument('-m', '--mapping', metavar='INI_FILE',
                                 required=False,
                                 help='Style mapping file')
        self.parser.add_argument('-s', '--stop-at', metavar='TEXT',
                                 required=False,
                                 help='Stop importing when TEXT is found')
        self.parser.add_argument('-c', '--base-character-style', metavar='NAME',
                                 default=self.DEFAULT_BASE,
                                 help='Base all character styles on this.')
        self.parser.add_argument('-p', '--base-paragraph-style', metavar='NAME',
                                 default=self.DEFAULT_BASE,
                                 help='Base all paragraph styles on this.')
        self.parser.add_argument('-v', '--style-to-variable', metavar='STYLE=VARIABLE', nargs='+',
                                 action=ParseDict,
                                 help='Map paragraph styles to document variables.')
        self.parser.add_argument('-f', '--fresh-start', action='store_true',
                                 help='Do not read any existing settings.')
        self.parser.add_argument('-d', '--debug', action='store_true',
                                 help='Print interesting debug information.')
        self.parser.add_argument('--no-rerunner', action='store_true',
                                 help='Do not (over)write the rerruner script.')
        self.args = self.parser.parse_args()

        if self.args.output:
            self.output_fn = self.args.output
        else:
            basename, dummy_ext = os.path.splitext(self.args.input)
            self.output_fn = basename + '.idtt.txt'

        if self.args.mapping:
            self.mapping_fn = self.args.mapping
        else:
            self.mapping_fn = self.output_fn + '.ini'

        self.rerunner_fn = self.output_fn + '.rerun'
        self.stop_marker = self.args.stop_at

    def configure_logging(self):
        """Set logging level and format."""
        logging.basicConfig(
            format='%(asctime)s %(message)s',
            level=logging.DEBUG if self.args.debug else logging.INFO
        )

    def read_mapping(self):
        """Read any user overrides to the basic Word->InDesign mapping."""
        self.mapping = configparser.ConfigParser()
        self.mapping_dirty = False
        self.mapped = set()
        if os.path.isfile(self.mapping_fn) and not self.args.fresh_start:
            logging.info('Reading %r', self.mapping_fn)
            self.mapping.read(self.mapping_fn, encoding=self.MAPPING_ENCODING)

        if self.stop_marker:
            self.update_mapping_section(self.MAPPING_CONFIG_SECTION, {'stop_marker': self.stop_marker})
        else:
            self.stop_marker = self.mapping_section(self.MAPPING_CONFIG_SECTION).get('stop_marker')

    def write_mapping(self):
        """When done, write the mapping file for the next time."""
        if self.mapping_dirty and os.path.isfile(self.mapping_fn):
            logging.debug('Backing up %r', self.mapping_fn)
            shutil.copy(self.mapping_fn, self.mapping_fn + '.bak')
        logging.info('Writing %r', self.mapping_fn)
        with open(self.mapping_fn, 'w', encoding=self.MAPPING_ENCODING) as fo:
            self.mapping.write(fo)

    def write_rerunner(self):
        """Write a script to regenerate the output."""
        if self.args.no_rerunner:
            return

        logging.info('Writing %r', self.rerunner_fn)
        with open(self.rerunner_fn, 'w', encoding=self.MAPPING_ENCODING) as fo:
            fo.write(
                '#!/bin/bash\n'
                '# AUTOGENERATED FILE, DO NOT EDIT.\n'
                '\n'
            )
            cli = [
                repr(sys.executable),
                repr(os.path.abspath(sys.argv[0])),
                repr(os.path.abspath(self.args.input)),
            ]
            if self.args.output:
                cli.append(repr(os.path.abspath(self.output_fn)))
            if self.args.mapping:
                cli.extend(['--mapping', repr(os.path.abspath(self.mapping_fn))])
            if self.stop_marker:
                cli.extend(['--stop-at', repr(self.stop_marker)])
            if self.args.base_character_style != self.DEFAULT_BASE:
                cli.extend(['--base-character-style', repr(self.args.base_character_style)])
            if self.args.base_paragraph_style != self.DEFAULT_BASE:
                cli.extend(['--base-paragraph-style', repr(self.args.base_paragraph_style)])
            if self.args.style_to_variable:
                cli.append('--style-to-variable')
                cli.extend(
                    repr('%s=%s' % (k, v))
                    for k, v in self.args.style_to_variable.items()
                )
            if self.args.debug:
                cli.append('--debug')
            cli.append('--no-rerunner')
            cli.extend(['2>&1', '|tee', os.path.abspath(self.rerunner_fn + '.output')])
            fo.write(' '.join(cli))
            fo.write('\n')
        os.chmod(self.rerunner_fn, 0o755)

    def load_docx(self):
        """Unzip and parse a .docx file."""
        logging.info('Reading %r', self.args.input)
        with zipfile.ZipFile(self.args.input) as self.docx:
            self.scan_styles(self.load_xml('word/styles.xml'))
            self.document = self.scan_for_styles(self.load_xml('word/document.xml'))
            self.footnotes = self.scan_for_styles(self.load_xml('word/footnotes.xml'))
            self.comments = self.scan_for_styles(self.load_xml('word/comments.xml'))

    def load_xml(self, path):
        """Parse an XML file inside the zipped doc, return root node."""
        try:
            with self.docx.open(path) as fo:
                return lxml.etree.parse(fo).getroot()
        except KeyError:
            return None

    def scan_styles(self, styles):
        """Create a Style object for everything in the document."""
        self.styles = {}
        self.add_special_styles()
        for s in self.xpath(styles, "//w:style[@w:type][w:name[@w:val]]"):
            self.found_style(
                realm=s.get(self.wtag('type')),
                internal_name=self.wval(s, 'w:name'),
                msw_name=s.get(self.wtag('styleId')),
                parent_msw_name=self.wval(s, 'w:basedOn'),
                followed_by_msw_name=self.wval(s, 'w:next'),
            )

        for style in self.styles.values():
            if style.parent_msw_name:
                style.parent = self.styles[self.style_key(
                    realm=style.realm, msw_name=style.parent_msw_name
                )]
            if style.followed_by_msw_name:
                style.followed_by = self.styles[self.style_key(
                    realm=style.realm, msw_name=style.followed_by_msw_name
                )]

    def scan_for_styles(self, node):
        """Mark which styles are actually used."""
        if node is not None:
            self.scan_for_realm_styles(node, 'w:pStyle', 'paragraph')
            self.scan_for_realm_styles(node, 'w:rStyle', 'character')
        return node

    def scan_for_realm_styles(self, node, tag, realm):
        """Find all styles of a specific type and mark them as being used."""
        for sn in self.xpath(node, '//%s' % tag):
            msw_name = sn.get(self.wtag('val'))
            self.styles[self.style_key(realm=realm, msw_name=msw_name)].used = True

    def add_special_styles(self):
        """Add any internal styles (i.e., not imported from the doc)."""
        self.base_names = {
            'character': self.args.base_character_style,
            'paragraph': self.args.base_paragraph_style,
        }
        self.base_styles = {
            realm: self.found_style(
                realm=realm,
                internal_name=name,
                msw_name=name,
            )
            for realm, name in self.base_names.items()
        }
        self.comment_mark_style = self.found_style(
            realm='character',
            internal_name=self.COMMENT_MARK_STYLE,
            msw_name=self.COMMENT_MARK_STYLE,
            color='Cyan',
            tint=100,
        )
        self.footnote_ref_style = self.found_style(
            realm='character',
            internal_name=self.FOOTNOTE_REF_STYLE,
            msw_name=self.FOOTNOTE_REF_STYLE,
            superscript=True,
        )

    def found_style(self, realm, internal_name, msw_name, **kwargs):
        if realm not in self.base_names:
            logging.debug('What about %s:%r [%r]?', realm, msw_name, internal_name)
            return

        try:
            section = self.mapping[self.section_name(realm=realm, internal_name=internal_name)]
        except KeyError:
            section = {}

        if msw_name != self.base_names.get(realm):
            kwargs.setdefault('parent_msw_name', self.base_names.get(realm))

        return self.add_style(
            realm=realm,
            name=section.get('name') or internal_name,
            internal_name=internal_name,
            msw_name=msw_name,
            **kwargs
        )

    def add_style(self, **kwargs):
        if self.args.style_to_variable and kwargs['realm'] == 'paragraph':
            kwargs.setdefault('variable', self.args.style_to_variable.get(kwargs['internal_name']))

        style = Style(**kwargs)
        self.styles[self.style_key(style)] = style
        return style

    def style_key(self, style=None, realm=None, msw_name=None):
        if style:
            realm = style.realm
            msw_name = style.msw_name
        return '%s:%s' % (realm.capitalize(), msw_name)

    def section_name(self, realm=None, internal_name=None, style=None):
        if style:
            realm = style.realm
            internal_name = style.internal_name
        return '%s:%s' % (realm.capitalize(), internal_name)

    def xpath(self, node, expr):
        return node.xpath(expr, namespaces=self.NS)

    def wval(self, node, prop):
        for pn in self.xpath(node, prop):
            return pn.get(self.wtag('val'))
        return None

    def wtag(self, tag):
        return '{%s}%s' % (self.W, tag)

    def write_idtt(self):
        logging.info('Writing %r', self.output_fn)
        self.current_character_style = None
        with InDesignTaggedTextOutput(self.output_fn, self.args.debug) as self.idtt:
            self.convert_document()

    def convert_document(self):
        try:
            self.stop_marker_found = False
            for p in self.xpath(self.document, '//w:body/w:p'):
                self.convert_paragraph(p)
            if self.stop_marker:
                logging.info('Note: Stop marker was never found')
                logging.debug('In other words, no %r', self.stop_marker)
        except StopMarkerFound as marker:
            logging.info(marker)

    def convert_paragraph(self, p):
        if self.stop_marker:
            self.check_for_stop_paragraph(p)
        style = self.wvstyle(p, 'w:pPr/w:pStyle', 'paragraph')
        with self.Paragraph(self, style):
            for r in self.xpath(p, 'w:r'):
                self.convert_range(r)
            if style.variable:
                self.define_variable_from_node(style.variable, p)

    def check_for_stop_paragraph(self, p):
        text = ''
        for node in self.xpath(p, 'w:r/w:t'):
            text += node.text
            if text.startswith(self.stop_marker):
                raise StopMarkerFound('Stop marker found at the beginning of a paragraph')
            if len(text) >= len(self.stop_marker):
                return

    def define_variable_from_node(self, variable, node):
        text = ''.join(t.text for t in self.xpath(node, 'w:r/w:t'))
        self.idtt.define_text_variable(variable, text)

    class Paragraph(object):
        def __init__(self, parent, style):
            self.parent = parent
            self.idtt = self.parent.idtt
            self.style = style

        def __enter__(self):
            self.idtt.enter_paragraph(self.style)
            return self

        def __exit__(self, *exception):
            self.idtt.leave_paragraph()
            self.parent.current_character_style = None

    def convert_range(self, r):
        self.switch_character_style(self.wvstyle(r, 'w:rPr/w:rStyle', 'character'))
        self.convert_range_text(r)
        for fnr in self.xpath(r, 'w:footnoteReference'):
            self.convert_footnote_reference(fnr)
        for fnr in self.xpath(r, 'w:commentReference'):
            self.convert_comment_reference(fnr)

    def convert_range_text(self, r):
        for t in self.xpath(r, 'w:tab'):
            self.idtt.write_text('\t')
        for t in self.xpath(r, 'w:t'):
            self.write_text(t)

    def switch_character_style(self, style):
        prev = self.current_character_style
        if style is not prev:
            self.idtt.set_character_style(style)
            self.current_character_style = style
        return prev

    def write_text(self, node):
        """Add some plain text."""
        try:
            text = node.text
            if not self.stop_marker:
                return
            offset = text.find(self.stop_marker)
            if offset < 0:
                return
            text = text[:offset]
            raise StopMarkerFound('Stop marker found')
        finally:
            self.idtt.write_text(text)

    def convert_footnote_reference(self, fnr):
        fnid = fnr.get(self.wtag('id'))
        with self.Footnote(self):
            for fn in self.xpath(self.footnotes, 'w:footnote[@w:id="%s"]' % fnid):
                self.convert_footnote(fn)

    class Footnote(object):
        def __init__(self, parent):
            self.parent = parent
            self.idtt = parent.idtt
            self.cstyle = parent.current_character_style
            self.rstyle = parent.footnote_ref_style

        def __enter__(self):
            self.parent.update_mapping(self.rstyle)
            self.idtt.set_character_style(self.rstyle)
            self.idtt.enter_footnote()

            self.parent.idtt = WhitespaceStripper(self.idtt)
            return self

        def __exit__(self, *exception):
            self.idtt.leave_footnote()
            self.idtt.set_character_style(self.cstyle)
            self.parent.idtt = self.idtt

    def convert_footnote(self, fn):
        with self.NestedStyle(self):
            for p in self.xpath(fn, 'w:p'):
                self.convert_paragraph(p)

    def convert_comment_reference(self, cmr):
        cmid = cmr.get(self.wtag('id'))
        for cm in self.xpath(self.comments, 'w:comment[@w:id="%s"]' % cmid):
            self.convert_comment(cm)

    def convert_comment(self, cm):
        outer = self.switch_character_style(self.comment_mark_style)
        for r in self.xpath(cm, 'w:p/w:r'):
            self.convert_range_text(r)
        self.switch_character_style(outer)

    def add_comment_marker(self, marker):
        cstyle = self.switch_character_style(self.comment_mark_style)
        self.idtt.write_text(marker)
        self.switch_character_style(cstyle)

    class NestedStyle(object):
        def __init__(self, parent):
            self.parent = parent

        def __enter__(self):
            self.parent_character_style = self.parent.current_character_style
            self.parent.current_character_style = None
            return self

        def __exit__(self, *exception):
            self.parent.current_character_style = self.parent_character_style

    def report_style_counts(self):
        realms = {s.realm for s in self.styles.values()}
        for realm in realms:
            logging.info('Number of %s styles used: %u',
                         realm.capitalize(),
                         sum(1 for s in self.styles.values() if s.realm == realm and s.used))

    def wvstyle(self, node, expr, realm):
        msw_name = self.wval(node, expr)
        if not msw_name:
            return None

        style = self.styles[self.style_key(realm=realm, msw_name=msw_name)]
        self.update_mapping(style)
        return style

    def update_mapping(self, style):
        section_name = self.section_name(style.realm, style.internal_name)
        if section_name in self.mapped:
            return

        if style.parent and style.parent.used:
            self.update_mapping(style.parent)
        elif style.parent_msw_name:
            logging.warn('%r inherits missing %r', section_name, style.parent_msw_name)

        self.update_mapping_section(section_name, {
            'name': style.name,
            'variable': style.variable or '',
            'msw_name (readonly)': style.msw_name,
            'parent_msw_name (readonly)': style.parent_msw_name or '',
            'next_msw_name (readonly)': style.followed_by_msw_name or '',
        })
        self.mapped.add(section_name)

        if style.followed_by and style.followed_by.used:
            self.update_mapping(style.followed_by)
        elif style.followed_by_msw_name:
            logging.warn('[%s] leads to missing %r', section_name, style.followed_by_msw_name)

    def mapping_section(self, section_name):
        return self.mapping.setdefault(section_name, {})

    def update_mapping_section(self, section_name, kvs):
        section = self.mapping_section(section_name)
        for key, value in kvs.items():
            if section.get(key) != value:
                section[key] = value
                self.mapping_dirty = True


class IOutput(object):
    """Interface for things that write InDesign Tagged Text."""

    def define_style(self, style):
        """Add a style definition."""
        raise NotImplementedError()

    def define_text_variable(self, name, value):
        """Add a text variable."""
        raise NotImplementedError()

    def enter_paragraph(self, style=None):
        """Start a paragraph with a specified style."""
        raise NotImplementedError()

    def leave_paragraph(self):
        """Finalize paragraph."""
        raise NotImplementedError()

    def set_character_style(self, style=None):
        """Start a span using a specific character style."""
        raise NotImplementedError()

    def enter_footnote(self):
        """Add a footnote reference and enter the footnote."""
        raise NotImplementedError()

    def leave_footnote(self):
        """Close footnote, go ack to main text."""
        raise NotImplementedError()

    def write_text(self, text):
        """Add some plain text."""
        raise NotImplementedError()


class WhitespaceStripper(IOutput):
    """A proxy IOutput which strips all initial and final whitespace.

    Good foor footnotes.
    """
    def __init__(self, writer):
        self.writer = writer
        self.begun = False
        self.pending = ''

    def define_style(self, style):
        """Add a style definition."""
        return self.writer.define_style(style)

    def define_text_variable(self, name, value):
        """Add a text variable."""
        return self.writer.define_text_variable(name, value)

    def enter_paragraph(self, style=None):
        """Start a paragraph with a specified style."""
        return self.writer.enter_paragraph(style)

    def leave_paragraph(self):
        """Finalize paragraph."""
        return self.writer.leave_paragraph()

    def set_character_style(self, style=None):
        """Start a span using a specific character style."""
        return self.writer.set_character_style(style)

    def enter_footnote(self):
        """Add a footnote reference and enter the footnote."""
        return self.writer.enter_footnote()

    def leave_footnote(self):
        """Close footnote, go ack to main text."""
        return self.writer.leave_footnote()

    def write_text(self, text):
        """Add some plain text."""
        if not self.begun:
            # Trim initial whitespace
            text = re.sub(r'^\s+', r'', text)
            self.begun = bool(text)

        if self.begun:
            # Defer any possibly final whitespace
            parts = re.split(r'(\s+$)', self.pending + text)
            text = parts[0]
            self.pending = parts[1] if len(parts) > 1 else ''

        return self.writer.write_text(text)


class InDesignTaggedTextOutput(IOutput):
    def __init__(self, filename, debug=False):
        self._filename = filename
        self._styles = []
        self._headers_written = False
        self._shades = collections.defaultdict(itertools.count)
        self._debug = debug

    def __enter__(self):
        self._fo = open(self._filename, 'w', encoding='UTF-16LE')
        ufo_fn = self._filename + '.utf8'
        if self._debug:
            self._ufo = open(ufo_fn, 'w', encoding='UTF-8')
        elif os.path.isfile(ufo_fn):
            os.unlink(ufo_fn)
        return self

    def __exit__(self, *exception):
        self._fo.close()
        if self._debug:
            self._ufo.close()

    def _writeln(self, line=''):
        self._write(line)
        self._write('\n')

    def define_style(self, style):
        """Add a style definition."""
        if style in self._styles:
            return

        if style.parent and style.parent.used:
            self.define_style(style.parent)

        self._styles.append(style)

        if style.followed_by and style.followed_by.used:
            self.define_style(style.followed_by)
        if self._headers_written:
            self._write_style_definition(style)

    def _write_headers(self):
        if self._headers_written:
            return
        self._writeln('<UNICODE-MAC>')
        self._write(r'<Version:13.1>')
        self._write(r'<FeatureSet:Indesign-R2L>')
        self._write(r'<ColorTable:=')
        self._write(r'<Black:COLOR:CMYK:Process:0,0,0,1>')
        self._write(r'<Cyan:COLOR:CMYK:Process:1,0,0,0>')
        self._write(r'<Magenta:COLOR:CMYK:Process:0,1,0,0>')
        self._write(r'<Yellow:COLOR:CMYK:Process:0,0,1,0>')
        self._write(r'>')
        self._writeln()
        for style in self._styles:
            self._write_style_definition(style)
            self._writeln()
        self._headers_written = True

    def _write_style_definition(self, style):
        logging.debug('InDesign: %s', style)
        if style.tint is None:
            fullness = 50.0 + 50.0 / (1.05 ** next(self._shades[style.realm]))

        if style.realm == 'paragraph':
            id_realm = 'Para'
            color = r'<pShadingColor:%s><pShadingOn:1>' % (style.color or 'Yellow')
            shade = r'<pShadingTint:%s>' % (style.tint or int(100 - fullness))
        elif style.realm == 'character':
            id_realm = 'Char'
            color = r'<cColor:%s>' % (style.color or 'Magenta')
            shade = r'<cColorTint:%s>' % (style.tint or int(fullness))

        self._write('<Define')
        self._write(id_realm)
        self._write('Style:')
        self._write(self._idname(style))
        self._write(color)
        self._write(shade)

        if style.superscript:
            self._write('<cPosition:Superscript>')

        if style.parent and style.parent.used:
            self._write('<BasedOn:')
            self._write(self._idname(style.parent))
            self._write('>')
        if style.followed_by and style.followed_by.used:
            self._write('<Nextstyle:')
            self._write(self._idname(style.followed_by))
            self._write('>')
        self._write('>')

    def define_text_variable(self, name, value):
        self._write('<DefineTextVariable:')
        self._write_escaped(name)
        self._write('=<TextVarType:CustomText>')
        self._write('<tvString:')
        self._write_escaped(value)
        self._write('>')
        self._write('>')

    def enter_paragraph(self, style=None):
        """Start a paragraph with a specified style."""
        self._write_headers()
        self._set_style('Para', style)

    def _set_style(self, realm, style):
        if style:
            self.define_style(style)
        self._write('<')
        self._write(realm)
        self._write('Style:')
        if style:
            self._write(self._idname(style))
        self._write('>')

    def _idname(self, style):
        return re.sub(r'\s*/\s*', r'\:', style.name)

    def leave_paragraph(self):
        """Finalize paragraph."""
        self._writeln()

    def set_character_style(self, style=None):
        """Start a span using a specific character style."""
        self._set_style('Char', style)

    def enter_footnote(self):
        """Add a footnote reference and enter the footnote."""
        self._write('<FootnoteStart:>')

    def leave_footnote(self):
        """Close footnote, go ack to main text."""
        self._write('<FootnoteEnd:>')

    def write_text(self, text):
        """Add some plain text."""
        self._write_escaped(text)

    def _write_escaped(self, text):
        return self._write(self._escape(text))

    def _escape(self, text):
        return re.sub(r'([<>])', r'\\\1', text)

    def _write(self, string):
        if string:
            self._fo.write(string)
            if self._debug:
                self._ufo.write(string)


if __name__ == '__main__':
    DocxToIdtt().run()
