#!/usr/bin/env python3
"""A utility to convert .docx to InDesign's Tagged Text."""
import argparse
import collections
import configparser
import contextlib
import itertools
import logging
import os
import re
import shutil
import sys
import zipfile

import lxml.etree
import attr

# TODO:
# - For post edit/proof: Manual formatting consolidation, TBD

# - Para: global base -> body base, heading base
# - Derivation rules: after same, after different, first since...
# - Digraph kerning (probably better in InDesign?)
# - Really need a test suite of some sort.
# - Manual format: autogenerate styles
# - Manual format: collapse with existing styles
# - A flag to only create/update the ini file
# - Maybe add front matter (best done in Id? either that or the template thingy (ooh, jinja2!))
# - Something usable for those balloons (footnote+hl? endnote? convert to note in jsx?)
# - Autocreate character styles from manual combos
#   bold: w:b (w:bCs?); italic: w:i (w:iCs?); undeline w:u
#   font: <w:rFonts w:ascii="Courier New" w:hAnsi="Courier New" w:cs="Courier New">
#   override style: <w:i w:val="0">
# - (f)odt import
# - idml import
# - Automatic header group
# - More complex BiDi
# - Endnotes
# - Editing marks
# - Linked styles?
# - Derivation rules?
# - Latent styles?


class StopMarkerFound(Exception):
    """We raise this to stop the presses."""
    pass


class BadReferenceInRule(Exception):
    """We raise this for bad ruels."""
    pass


class ParseDict(argparse.Action):
    """Helper class to convert KEY=VALUE pairs to a dict."""
    def __call__(self, parser, namespace, values, option_string):
        setattr(namespace, self.dest, dict(val.split('=', 1) for val in values))


# We use attr Metadata to mark some fields as "internal" (not written to the
# ini file) or "readonly" (not read from the ini file)
ATTR_KEY = 'special'
ATTR_READONLY = {ATTR_KEY: 'readonly'}
ATTR_NO_INI = {ATTR_KEY: 'internal'}


@attr.s(slots=True)
class Style(object):
    """A character/paragraph style, normally found in the input file."""
    realm = attr.ib(metadata=ATTR_NO_INI)
    msw_name = attr.ib(metadata=ATTR_READONLY)  # Used for xrefs in docx; localized
    internal_name = attr.ib(metadata=ATTR_NO_INI)  # Used in the section names
    name = attr.ib()  # What the user (and InDesign) see
    parent_msw_name = attr.ib(default=None, metadata=ATTR_READONLY)
    next_msw_name = attr.ib(default=None, metadata=ATTR_READONLY)
    idtt = attr.ib(default='')
    variable = attr.ib(default=None)

    used = attr.ib(default=None, metadata=ATTR_NO_INI)

    parent_style = attr.ib(default=None, metadata=ATTR_NO_INI)
    next_style = attr.ib(default=None, metadata=ATTR_NO_INI)

    def __str__(self):
        return '<%s %r>' % (self.realm, self.name)


@attr.s(slots=True)
class Rule(object):
    """A derivation rule for Styles."""
    mnemonic = attr.ib(metadata=ATTR_NO_INI)
    description = attr.ib(metadata=ATTR_NO_INI)
    turn_this = attr.ib(default=None)
    into_this = attr.ib(default=None)
    when_following = attr.ib(default=None)

    turn_this_style = attr.ib(default=None, metadata=ATTR_NO_INI)
    into_this_style = attr.ib(default=None, metadata=ATTR_NO_INI)
    when_following_styles = attr.ib(default=None, metadata=ATTR_NO_INI)

    valid = attr.ib(default=True, metadata=ATTR_NO_INI)
    applied = attr.ib(default=0, metadata=ATTR_NO_INI)

    def __str__(self):
        return '%s %r' % (self.mnemonic, self.description)


@attr.s
class State(object):
    curr_char_style = attr.ib(default=None)
    prev_para_style = attr.ib(default=None)
    curr_para_text = attr.ib(default='')
    prev_para_text = attr.ib(default=None)


class DocxToIdtt(object):
    """Read a docx file. Write an InDesign Tagged Text file. What's not to like?"""
    W = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    NS = {'w': W}

    SETTING_FILE_ENCODING = 'UTF-8'
    CONFIG_SECTION_NAME = 'General'
    SPECIAL_GROUP = '(autogenerated)'
    DEFAULT_BASE = SPECIAL_GROUP + '/(Basic Style)'
    FOOTNOTE_REF_STYLE = SPECIAL_GROUP + '/(Footnote Reference in Text)'
    COMMENT_REF_STYLE = SPECIAL_GROUP + '/(Comment Reference)'
    IGNORED_STYLES = {
        'character': ['annotation reference'],
    }
    SPECIAL_STYLE = {
        'character': {
            COMMENT_REF_STYLE: {
                'idtt': '<pShadingColor:Cyain><pShadingOn:1><pShadingTint:100>',
            }
        },
        'paragraph': {
            'annotation text': {
                'name': SPECIAL_GROUP + '/(Comment Text)',
                'idtt': '<cSize:6><cColor:Cyan><cColorTint:100>',
            }
        },
    }

    def run(self):
        """Main entry point."""
        self.parse_command_line()
        self.configure_logging()
        self.read_settings()
        self.load_docx()
        self.write_idtt()
        self.report_statistics()
        self.write_settings()
        self.write_rerunner()

    def parse_command_line(self):
        """Find out what we're supposed to do."""
        self.parser = argparse.ArgumentParser(description='Word to Indesign Tagged Text')
        self.parser.add_argument('input', help='Input .docx file')
        self.parser.add_argument('output', nargs='?',
                                 help='InDesign Tagged Text file')
        self.parser.add_argument('-s', '--stop-at', metavar='TEXT',
                                 required=False,
                                 help='Stop importing when TEXT is found')
        self.parser.add_argument('-c', '--base-character-style', metavar='NAME',
                                 default=self.DEFAULT_BASE,
                                 help='Base all character styles on this.')
        self.parser.add_argument('-p', '--base-paragraph-style', metavar='NAME',
                                 default=self.DEFAULT_BASE,
                                 help='Base all paragraph styles on this.')
        self.parser.add_argument('-v', '--style-to-variable', metavar='STYLE=VARIABLE', nargs='+',
                                 action=ParseDict,
                                 help='Map paragraph styles to document variables.')
        self.parser.add_argument('-f', '--fresh-start', action='store_true',
                                 help='Do not read any existing settings.')
        self.parser.add_argument('-d', '--debug', action='store_true',
                                 help='Print interesting debug information.')
        self.parser.add_argument('--no-rerunner', action='store_true',
                                 help='Do not (over)write the rerruner script.')
        self.args = self.parser.parse_args()

        if self.args.output:
            self.output_fn = self.args.output
        else:
            basename, dummy_ext = os.path.splitext(self.args.input)
            self.output_fn = basename + '.idtt.txt'

        self.settings_fn = self.output_fn + '.ini'
        self.rerunner_fn = self.output_fn + '.rerun'
        self.stop_marker = self.args.stop_at

    def configure_logging(self):
        """Set logging level and format."""
        logging.basicConfig(
            format='%(asctime)s %(message)s',
            level=logging.DEBUG if self.args.debug else logging.INFO
        )

    def read_settings(self):
        """Read and parse the ini file."""
        self.settings = configparser.ConfigParser()
        self.settings_touched = False
        self.style_sections_used = set()
        if os.path.isfile(self.settings_fn) and not self.args.fresh_start:
            logging.info('Reading %r', self.settings_fn)
            self.settings.read(self.settings_fn, encoding=self.SETTING_FILE_ENCODING)

        self.load_rules()
        self.config = self.ensure_setting_section(self.CONFIG_SECTION_NAME)
        if self.stop_marker:
            self.config['stop_marker'] = self.stop_marker
        else:
            self.stop_marker = self.config.get('stop_marker')

    def load_rules(self):
        """Convert Rule sections into Rule objects."""
        self.rules = []
        for section_name in self.settings.sections():
            if not section_name.lower().startswith('rule:'):
                continue
            section = self.settings[section_name]
            self.rules.append(Rule(
                mnemonic='R%s' % (len(self.rules) + 1),
                description=section_name[5:],
                **{
                    name: section[ini_name]
                    for name, ini_name in self.ini_fields(Rule)
                    if ini_name in section
                }
            ))
            logging.debug(self.rules[-1])

    def write_settings(self):
        """When done, write the settings file for the next time."""
        if self.settings_touched and os.path.isfile(self.settings_fn):
            logging.debug('Backing up %r', self.settings_fn)
            shutil.copy(self.settings_fn, self.settings_fn + '.bak')

        logging.info('Writing %r', self.settings_fn)
        with open(self.settings_fn, 'w', encoding=self.SETTING_FILE_ENCODING) as fo:
            self.settings.write(fo)

    def write_rerunner(self):
        """Write a script to regenerate the output."""
        if self.args.no_rerunner:
            return

        logging.info('Writing %r', self.rerunner_fn)
        with open(self.rerunner_fn, 'w', encoding=self.SETTING_FILE_ENCODING) as fo:
            fo.write(
                '#!/bin/bash\n'
                '# AUTOGENERATED FILE, DO NOT EDIT.\n'
                '\n'
            )
            cli = [
                repr(sys.executable),
                repr(os.path.abspath(sys.argv[0])),
                repr(os.path.abspath(self.args.input)),
            ]
            if self.args.output:
                cli.append(repr(os.path.abspath(self.output_fn)))
            if self.stop_marker:
                cli.extend(['--stop-at', repr(self.stop_marker)])
            if self.args.base_character_style != self.DEFAULT_BASE:
                cli.extend(['--base-character-style', repr(self.args.base_character_style)])
            if self.args.base_paragraph_style != self.DEFAULT_BASE:
                cli.extend(['--base-paragraph-style', repr(self.args.base_paragraph_style)])
            if self.args.style_to_variable:
                cli.append('--style-to-variable')
                cli.extend(
                    repr('%s=%s' % (k, v))
                    for k, v in self.args.style_to_variable.items()
                )
            if self.args.debug:
                cli.append('--debug')
            cli.extend(['2>&1', '|tee', os.path.abspath(self.rerunner_fn + '.output')])
            fo.write(' '.join(cli))
            fo.write('\n')
        os.chmod(self.rerunner_fn, 0o755)

    def load_docx(self):
        """Unzip and parse a .docx file."""
        logging.info('Reading %r', self.args.input)
        with zipfile.ZipFile(self.args.input) as self.docx:
            self.scan_style_definitions(self.load_xml('word/styles.xml'))
            self.document = self.scan_style_mentions(self.load_xml('word/document.xml'))
            self.footnotes = self.scan_style_mentions(self.load_xml('word/footnotes.xml'))
            self.comments = self.scan_style_mentions(self.load_xml('word/comments.xml'))
        self.link_styles()
        self.link_rules()

    def load_xml(self, path):
        """Parse an XML file inside the zipped doc, return root node."""
        try:
            with self.docx.open(path) as fo:
                return lxml.etree.parse(fo).getroot()
        except KeyError:
            return None

    def scan_style_definitions(self, styles):
        """Create a Style object for everything in the document."""
        self.styles = {}
        self.create_special_styles()
        for s in self.xpath(styles, "//w:style[@w:type][w:name[@w:val]]"):
            self.found_style_definition(
                realm=s.get(self.wtag('type')),
                internal_name=self.wval(s, 'w:name'),
                msw_name=s.get(self.wtag('styleId')),
                parent_msw_name=self.wval(s, 'w:basedOn'),
                next_msw_name=self.wval(s, 'w:next'),
            )

    def create_special_styles(self):
        """Add any internal styles (i.e., not imported from the doc)."""
        self.base_names = {
            'character': self.args.base_character_style,
            'paragraph': self.args.base_paragraph_style,
        }
        self.base_styles = {
            realm: self.found_style_definition(
                realm=realm,
                internal_name=name,
                msw_name=name,
                used=True,
            )
            for realm, name in self.base_names.items()
        }
        self.footnote_ref_style = self.found_style_definition(
            realm='character',
            internal_name=self.FOOTNOTE_REF_STYLE,
            msw_name=self.FOOTNOTE_REF_STYLE,
            idtt='<cColor:Magenta><cColorTint:100><cPosition:Superscript>'
        )
        self.comment_ref_style = self.found_style_definition(
            realm='character',
            internal_name=self.COMMENT_REF_STYLE,
            msw_name=self.COMMENT_REF_STYLE,
            parent_msw_name=self.FOOTNOTE_REF_STYLE,
            idtt='<cColor:Cyan><cColorTint:100>'
        )

    def scan_style_mentions(self, node):
        """Mark which styles are actually used."""
        if node is None:
            return None
        self.scan_realm_style_mentions(node, 'paragraph', 'w:pStyle')
        self.scan_realm_style_mentions(node, 'character', 'w:rStyle')
        return node

    def scan_realm_style_mentions(self, node, realm, tag):
        """Find all styles of a specific realm and mark them as being used."""
        for sn in self.xpath(node, '//%s' % tag):
            msw_name = sn.get(self.wtag('val'))
            style_key = self.style_key(realm=realm, msw_name=msw_name)
            if style_key not in self.styles:
                logging.debug('Used but not defined? %r', style_key)
            elif not self.styles[style_key].used:
                logging.debug('Style used: %r', style_key)
                self.styles[style_key].used = True

    def link_styles(self):
        """A sort of alchemy-relationship thing."""
        for style in self.styles.values():
            style.parent_style = self.style_or_none(style.realm, style.parent_msw_name)
            style.next_style = self.style_or_none(style.realm, style.next_msw_name)

    def style_or_none(self, realm, msw_name):
        if not msw_name:
            return None
        return self.styles[self.style_key(realm=realm, msw_name=msw_name)]

    def link_rules(self):
        """A sort of alchemy-relationship thing."""
        for rule in self.rules:
            try:
                rule.turn_this_style = self.find_style_by_ini_ref(
                    rule.turn_this,
                    required=True
                )
                rule.into_this_style = self.find_style_by_ini_ref(
                    rule.into_this,
                    required=True,
                    inherit_from=rule.turn_this_style,
                )
                rule.when_following_styles = [
                    self.find_style_by_ini_ref(ini_ref)
                    for ini_ref in
                    re.findall(r'\[.*?\]', rule.when_following)
                ]
            except BadReferenceInRule:
                logging.warn('Ignoring rule with bad references: %s', rule)
                rule.valid = False

    def find_style_by_ini_ref(self, ini_ref, required=False, inherit_from=None):
        """Returns a style, given type of string we use for ini file section names."""
        if not ini_ref:
            if required:
                logging.debug('MISSING REQUIRED SOMETHING')
                raise BadReferenceInRule()
            return None
        m = re.match(
            r'^\[(?P<realm>\w+):(?P<internal_name>.+)\]$',
            ini_ref,
            re.IGNORECASE
        )
        if not m:
            logging.debug('Malformed %r', ini_ref)
            raise BadReferenceInRule()
        try:
            realm = m.group('realm').lower()
            internal_name = m.group('internal_name')
            return next(
                style for style in self.styles.values()
                if style.realm.lower() == realm and style.internal_name == internal_name
            )
        except StopIteration:
            if not inherit_from:
                logging.debug('ERROR: Unknown %r', ini_ref)
                raise BadReferenceInRule()
        return self.add_style(
            realm=realm,
            msw_name=ini_ref,
            internal_name=internal_name,
            parent_msw_name=inherit_from.msw_name,
            parent_style=inherit_from,
        )

    def found_style_definition(self, realm, internal_name, msw_name, **kwargs):
        if realm not in self.base_names:
            logging.debug('What about %s:%r [%r]?', realm, msw_name, internal_name)
            return

        if msw_name != self.base_names.get(realm):
            kwargs.setdefault('parent_msw_name', self.base_names.get(realm))

        # Allow any special overrides (color, name, etc.)
        kwargs.update(self.SPECIAL_STYLE.get(realm, {}).get(internal_name, {}))

        section = self.get_setting_section(realm=realm, internal_name=internal_name)
        if not kwargs.get('name'):
            kwargs['name'] = internal_name
        kwargs.update({
            name: section[ini_name]
            for name, ini_name in self.ini_fields(writeable=True)
            if ini_name in section
        })

        return self.add_style(
            realm=realm,
            msw_name=msw_name,
            internal_name=internal_name,
            **kwargs
        )

    def add_style(self, **kwargs):
        """Create a new Style object and add to our map."""
        if self.args.style_to_variable:
            if kwargs['realm'] == 'paragraph':
                kwargs.setdefault('variable', self.args.style_to_variable.get(kwargs['internal_name']))

        kwargs.setdefault('name', kwargs['internal_name'])

        style = Style(**kwargs)
        self.styles[self.style_key(style=style)] = style
        return style

    def style_key(self, style=None, realm=None, msw_name=None):
        """The string which we use for `self.styles`.

        Note that this is based on the msw_name, because
        that's the key docx files use for cross-reference.
        """
        if style:
            realm = style.realm
            msw_name = style.msw_name
        return '%s:%s' % (realm, msw_name)

    def section_name(self, realm=None, internal_name=None, style=None):
        """The name of the ini section for a given style.

        This uses `internal_name`, rather than `msw_name` or `name`,
        because `msw_name` can get ugly ("a2") and `name` should be
        modifyable.
        """
        if style:
            realm = style.realm
            internal_name = style.internal_name
        return '%s:%s' % (realm.capitalize(), internal_name)

    def xpath(self, node, expr):
        return node.xpath(expr, namespaces=self.NS)

    def wval(self, node, prop):
        for pn in self.xpath(node, prop):
            return pn.get(self.wtag('val'))
        return None

    def wtag(self, tag):
        return '{%s}%s' % (self.W, tag)

    def write_idtt(self):
        logging.info('Writing %r', self.output_fn)
        self.set_state(State())
        with InDesignTaggedTextOutput(self.output_fn, self.args.debug) as self.writer:
            self.convert_document()

    def convert_document(self):
        try:
            self.stop_marker_found = False
            for p in self.xpath(self.document, '//w:body/w:p'):
                self.convert_paragraph(p)
            if self.stop_marker:
                logging.info('Note: Stop marker was never found')
                logging.debug('In other words, no %r', self.stop_marker)
        except StopMarkerFound as marker:
            logging.info(marker)

    def convert_paragraph(self, p):
        if self.stop_marker:
            self.check_for_stop_paragraph(p)
        style = self.apply_rules_to(self.wvstyle(p, 'w:pPr/w:pStyle', 'paragraph'))
        with self.Paragraph(self, style):
            for r in self.xpath(p, 'w:r'):
                self.convert_range(r)
            if style.variable:
                self.define_variable_from_node(style.variable, p)

    def apply_rules_to(self, style):
        for rule in self.rules:
            if not rule.valid:
                continue
            if rule.turn_this_style == style:
                if self.state.prev_para_style in rule.when_following_styles:
                    rule.applied += 1
                    return rule.into_this_style
        return style

    def check_for_stop_paragraph(self, p):
        text = ''
        for node in self.xpath(p, 'w:r/w:t'):
            text += node.text
            if text.startswith(self.stop_marker):
                raise StopMarkerFound('Stop marker found at the beginning of a paragraph')
            if len(text) >= len(self.stop_marker):
                return

    def define_variable_from_node(self, variable, node):
        text = ''.join(t.text for t in self.xpath(node, 'w:r/w:t'))
        self.writer.define_text_variable(variable, text)

    def set_state(self, state):
        prev = getattr(self, 'state', None)
        self.state = state
        return prev

    class Paragraph(contextlib.AbstractContextManager):
        def __init__(self, outer, style):
            super().__init__()
            self.outer = outer
            self.writer = self.outer.writer
            self.style = style
            self.writer.enter_paragraph(self.style)

        def __exit__(self, *args):
            self.writer.leave_paragraph()
            self.outer.set_state(State(
                prev_para_style=self.style,
                prev_para_text=self.outer.state.curr_para_text,
            ))

    def convert_range(self, r):
        self.switch_character_style(self.wvstyle(r, 'w:rPr/w:rStyle', 'character'))
        self.convert_range_text(r)
        for fnr in self.xpath(r, 'w:footnoteReference'):
            self.convert_footnote_reference(fnr)
        for fnr in self.xpath(r, 'w:commentReference'):
            self.convert_comment_reference(fnr)

    def convert_range_text(self, r):
        for t in self.xpath(r, 'w:tab'):
            self.writer.write_text('\t')
        for t in self.xpath(r, 'w:t'):
            self.write_text(t)

    def switch_character_style(self, style):
        prev = self.state.curr_char_style
        if style is not prev:
            self.writer.set_character_style(style)
            self.state.curr_char_style = style
        return prev

    def write_text(self, node):
        """Add some plain text."""
        with contextlib.ExitStack() as stack:
            stack.callback(lambda: self.do_write_text(text))
            text = node.text
            if not self.stop_marker:
                return
            offset = text.find(self.stop_marker)
            if offset < 0:
                return
            text = text[:offset]
            raise StopMarkerFound('Stop marker found')

    def do_write_text(self, text):
        self.writer.write_text(text)
        self.state.curr_para_text += text

    def convert_footnote_reference(self, fnr):
        fnid = fnr.get(self.wtag('id'))
        with self.Footnote(self):
            for fn in self.xpath(self.footnotes, 'w:footnote[@w:id="%s"]' % fnid):
                self.convert_footnote(fn)

    def convert_comment_reference(self, cmr):
        """Tagged Text doesn't support notes, so we convert them to footnotes."""
        cmid = cmr.get(self.wtag('id'))
        with self.Footnote(self, ref_style=self.comment_ref_style):
            for cm in self.xpath(self.comments, 'w:comment[@w:id="%s"]' % cmid):
                self.convert_footnote(cm)

    def convert_footnote(self, fn):
        with self.NestedStyle(self):
            for p in self.xpath(fn, 'w:p'):
                self.convert_paragraph(p)

    class Footnote(contextlib.AbstractContextManager):
        def __init__(self, outer, ref_style=None):
            super().__init__()
            self.outer = outer
            self.writer = outer.writer
            self.outer_character_style = outer.state.curr_char_style
            ref_style = ref_style or outer.footnote_ref_style

            self.outer.style_encountered(ref_style)
            self.writer.set_character_style(ref_style)
            self.writer.enter_footnote()
            self.outer.writer = WhitespaceStripper(self.writer)

        def __exit__(self, *args):
            self.writer.leave_footnote()
            self.writer.set_character_style(self.outer_character_style)
            self.outer.writer = self.writer

    class NestedStyle(contextlib.AbstractContextManager):
        def __init__(self, outer):
            super().__init__()
            self.outer = outer
            self.outer_state = self.outer.set_state(State())

        def __exit__(self, *args):
            self.outer.set_state(self.outer_state)

    def report_statistics(self):
        realms = {s.realm for s in self.styles.values()}
        for realm in realms:
            logging.info('Number of %s styles used: %u',
                         realm.capitalize(),
                         sum(1 for s in self.styles.values() if s.realm == realm and s.used))
        for rule in self.rules:
            if rule.applied:
                logging.info('%s application(s) of %s', rule.applied, rule)

    def wvstyle(self, node, expr, realm):
        msw_name = self.wval(node, expr)
        if not msw_name:
            return None

        style = self.styles[self.style_key(realm=realm, msw_name=msw_name)]
        if realm in self.IGNORED_STYLES:
            if style.internal_name in self.IGNORED_STYLES[realm]:
                return None

        self.style_encountered(style)
        return style

    def style_encountered(self, style):
        section_name = self.section_name(style.realm, style.internal_name)
        if section_name in self.style_sections_used:
            return

        if style.parent_style:
            if not style.parent_style.used:
                logging.debug('[%s] leads to missing %r', section_name, style.parent_msw_name)
                style.parent_style = self.base_styles[style.realm]
                style.parent_msw_name = style.parent_style.msw_name
            self.style_encountered(style.parent_style)

        self.update_setting_section(section_name, style)
        self.style_sections_used.add(section_name)

        if style.next_style and style.next_style.used:
            self.style_encountered(style.next_style)
        elif style.next_msw_name:
            logging.debug('[%s] leads to missing %r', section_name, style.next_msw_name)

    def get_setting_section(self, section_name=None, realm=None, internal_name=None, style=None):
        """Return a section from the ini file.

        If no such section exists, return a new dict, but don't add it
        to the configuration.
        """
        if not section_name:
            section_name = self.section_name(realm=realm, internal_name=internal_name, style=style)

        if self.settings.has_section(section_name):
            return self.settings[section_name]
        return {}

    def ensure_setting_section(self, section_name=None, realm=None, internal_name=None, style=None):
        """Return a section from the ini file, adding one if needed."""
        if not section_name:
            section_name = self.section_name(realm=realm, internal_name=internal_name, style=style)
        if not self.settings.has_section(section_name):
            self.settings[section_name] = {}
        return self.settings[section_name]

    def update_setting_section(self, section_name, style):
        """Update key:value pairs in an ini section.

        Sets `self.settings_touched` if anything was changed.
        """
        section = self.ensure_setting_section(section_name)
        for name, ini_name in self.ini_fields():
            value = getattr(style, name)
            self.settings_touched |= section.get(ini_name) != value
            if value:
                section[ini_name] = str(value or '')
            else:
                section.pop(ini_name, None)

    def ini_fields(self, klass=Style, writeable=False):
        """Yields a pair (name, ini_name) for all attributes."""
        for field in attr.fields(klass):
            special = field.metadata.get(ATTR_KEY)
            if special == 'internal':
                continue
            ini_name = name = field.name
            if special == 'readonly':
                if writeable:
                    continue
                ini_name += ' (readonly)'
            yield (name, ini_name)


class IOutput(object):
    """Interface for things that write InDesign Tagged Text."""

    def define_style(self, style):
        """Add a style definition."""
        raise NotImplementedError()

    def define_text_variable(self, name, value):
        """Add a text variable."""
        raise NotImplementedError()

    def enter_paragraph(self, style=None):
        """Start a paragraph with a specified style."""
        raise NotImplementedError()

    def leave_paragraph(self):
        """Finalize paragraph."""
        raise NotImplementedError()

    def set_character_style(self, style=None):
        """Start a span using a specific character style."""
        raise NotImplementedError()

    def enter_footnote(self):
        """Add a footnote reference and enter the footnote."""
        raise NotImplementedError()

    def leave_footnote(self):
        """Close footnote, go ack to main text."""
        raise NotImplementedError()

    def write_text(self, text):
        """Add some plain text."""
        raise NotImplementedError()


class WhitespaceStripper(IOutput):
    """A proxy IOutput which strips all initial and final whitespace.

    Good foor footnotes.
    """
    def __init__(self, writer):
        self.writer = writer
        self.begun = False
        self.pending = ''

    def define_style(self, style):
        """Add a style definition."""
        return self.writer.define_style(style)

    def define_text_variable(self, name, value):
        """Add a text variable."""
        return self.writer.define_text_variable(name, value)

    def enter_paragraph(self, style=None):
        """Start a paragraph with a specified style."""
        return self.writer.enter_paragraph(style)

    def leave_paragraph(self):
        """Finalize paragraph."""
        return self.writer.leave_paragraph()

    def set_character_style(self, style=None):
        """Start a span using a specific character style."""
        return self.writer.set_character_style(style)

    def enter_footnote(self):
        """Add a footnote reference and enter the footnote."""
        return self.writer.enter_footnote()

    def leave_footnote(self):
        """Close footnote, go ack to main text."""
        return self.writer.leave_footnote()

    def write_text(self, text):
        """Add some plain text."""
        if not self.begun:
            # Trim initial whitespace
            text = re.sub(r'^\s+', r'', text)
            self.begun = bool(text)

        if self.begun:
            # Defer any possibly final whitespace
            parts = re.split(r'(\s+$)', self.pending + text)
            text = parts[0]
            self.pending = parts[1] if len(parts) > 1 else ''

        return self.writer.write_text(text)


class InDesignTaggedTextOutput(contextlib.ExitStack, IOutput):
    def __init__(self, filename, debug=False):
        super().__init__()
        self._filename = filename
        self._styles = []
        self._headers_written = False
        self._shades = collections.defaultdict(itertools.count)
        self._debug = debug

        self._fo = self.enter_context(open(self._filename, 'w', encoding='UTF-16LE'))
        ufo_fn = self._filename + '.utf8'
        if self._debug:
            self._ufo = self.enter_context(open(ufo_fn, 'w', encoding='UTF-8'))
        elif os.path.isfile(ufo_fn):
            os.unlink(ufo_fn)

    def _writeln(self, line=''):
        self._write(line)
        self._write('\n')

    def define_style(self, style):
        """Add a style definition."""
        if style in self._styles:
            return

        if style.parent_style and style.parent_style.used:
            self.define_style(style.parent_style)

        self._styles.append(style)

        if style.next_style and style.next_style.used:
            self.define_style(style.next_style)
        if self._headers_written:
            self._write_style_definition(style)

    def _write_headers(self):
        if self._headers_written:
            return
        self._writeln('<UNICODE-MAC>')
        self._write(r'<Version:13.1>')
        self._write(r'<FeatureSet:Indesign-R2L>')
        self._write(r'<ColorTable:=')
        self._write(r'<Black:COLOR:CMYK:Process:0,0,0,1>')
        self._write(r'<Cyan:COLOR:CMYK:Process:1,0,0,0>')
        self._write(r'<Magenta:COLOR:CMYK:Process:0,1,0,0>')
        self._write(r'<Yellow:COLOR:CMYK:Process:0,0,1,0>')
        self._write(r'>')
        self._writeln()
        for style in self._styles:
            self._write_style_definition(style)
            self._writeln()
        self._headers_written = True

    def _write_style_definition(self, style):
        logging.debug('InDesign: %s', style)
        id_realm = style.realm[:4].capitalize()
        if style.idtt:
            idtt = [style.idtt]
        else:
            fullness = 50.0 + 50.0 / (1.05 ** next(self._shades[style.realm]))

            if style.realm == 'paragraph':
                idtt = [
                    '<pShadingColor:Yellow>',
                    '<pShadingOn:1>',
                    '<pShadingTint:', str(int(100 - fullness)), '>'
                ]
            elif style.realm == 'character':
                idtt = [
                    '<cColor:Magenta>',
                    '<cColorTint:', str(int(fullness)), '>'
                ]

        self._write('<Define')
        self._write(id_realm)
        self._write('Style:')
        self._write(self._idname(style))
        for elem in idtt:
            self._write(elem)

        if style.parent_style and style.parent_style.used:
            self._write('<BasedOn:')
            self._write(self._idname(style.parent_style))
            self._write('>')
        if style.next_style and style.next_style.used:
            self._write('<Nextstyle:')
            self._write(self._idname(style.next_style))
            self._write('>')
        self._write('>')

    def define_text_variable(self, name, value):
        self._write('<DefineTextVariable:')
        self._write_escaped(name)
        self._write('=<TextVarType:CustomText>')
        self._write('<tvString:')
        self._write_escaped(value)
        self._write('>')
        self._write('>')

    def enter_paragraph(self, style=None):
        """Start a paragraph with a specified style."""
        self._write_headers()
        self._set_style('Para', style)

    def _set_style(self, realm, style):
        if style:
            self.define_style(style)
        self._write('<')
        self._write(realm)
        self._write('Style:')
        if style:
            self._write(self._idname(style))
        self._write('>')

    def _idname(self, style):
        return re.sub(r'\s*/\s*', r'\:', style.name)

    def leave_paragraph(self):
        """Finalize paragraph."""
        self._writeln()

    def set_character_style(self, style=None):
        """Start a span using a specific character style."""
        self._set_style('Char', style)

    def enter_footnote(self):
        """Add a footnote reference and enter the footnote."""
        self._write('<FootnoteStart:>')

    def leave_footnote(self):
        """Close footnote, go ack to main text."""
        self._write('<FootnoteEnd:>')

    def write_text(self, text):
        """Add some plain text."""
        self._write_escaped(text)

    def _write_escaped(self, text):
        return self._write(self._escape(text))

    def _escape(self, text):
        return re.sub(r'([<>])', r'\\\1', text)

    def _write(self, string):
        if string:
            self._fo.write(string)
            if self._debug:
                self._ufo.write(string)


if __name__ == '__main__':
    DocxToIdtt().run()
