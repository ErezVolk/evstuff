#!/usr/bin/env python3
import os
import sys
import argparse
import configparser
import zipfile
import collections
import itertools
import lxml.etree

from sqlalchemy.ext.declarative import declarative_base
import sqlalchemy as sa

Base = declarative_base()

# TODO: (f)odt import
# TODO: Automatic header group
# TODO ONE DAY: Comments
# TODO ONE DAY: Endnotes
# TODO ONE DAY: Editing marks
# TODO MAYBE: Derivation rules?


class Style(Base):
    __tablename__ = 'style'

    def __str__(self):
        desc = [self.realm, self.name]
        if self.internal_name and self.internal_name != self.name:
            desc.append('[%s]' % self.internal_name)
        if self.parent:
            desc.append('inherits %s' % self.parent.name)
        if self.followed_by:
            desc.append('followed by %s' % self.followed_by.name)
        return '<%s>' % ' '.join(desc)

    @property
    def absname(self):
        if self.group:
            return r'%s\:%s' % (self.group, self.name)
        return self.name

    realm = sa.Column('realm', sa.String, primary_key=True)
    msw_name = sa.Column('msw_name', sa.String, primary_key=True)
    name = sa.Column('name', sa.String)
    group = sa.Column('group', sa.String)
    legit = sa.Column('legit', sa.String)
    internal_name = sa.Column('internal_name', sa.String, nullable=False)
    parent_msw_name = sa.Column('parent', sa.String, sa.ForeignKey('style.msw_name'), nullable=True)
    followed_by_msw_name = sa.Column('followed_by', sa.String, sa.ForeignKey('style.msw_name'), nullable=True)

    parent = sa.orm.relationship(
        'Style',
        primaryjoin=(
            sa.orm.remote(msw_name) == sa.orm.foreign(parent_msw_name) and
            sa.orm.remote(realm) == sa.orm.foreign(realm)
        )
    )

    followed_by = sa.orm.relationship(
        'Style',
        primaryjoin=(
            sa.orm.remote(msw_name) == sa.orm.foreign(followed_by_msw_name) and
            sa.orm.remote(realm) == sa.orm.foreign(realm)
        )
    )


class StopMarkerFound(Exception):
    pass


class DocxToIdtt(object):
    W = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    NS = {'w': W}

    def run(self):
        self.parse_command_line()
        self.read_mapping()
        self.create_db()
        self.load_docx()
        self.write_idtt()
        self.write_mapping()
        self.write_rerunner()

    def parse_command_line(self):
        self.parser = argparse.ArgumentParser(description='DOCX to EVML')
        self.parser.add_argument('input', help='Input .docx file')
        self.parser.add_argument('--output', '-o', required=False,
                                 help='InDesign Tagged Text file')
        self.parser.add_argument('-m', '--mapping', metavar='INI_FILE',
                                 required=False,
                                 help='Style mapping file')
        self.parser.add_argument('-s', '--stop-at', metavar='TEXT',
                                 required=False,
                                 help='Stop importing when TEXT is found')
        self.parser.add_argument('-l', '--legitimist', action='store_true',
                                 help='No highlighting for legit styles.')
        self.args = self.parser.parse_args()

        if self.args.output:
            self.output_fn = self.args.output
        else:
            basename, dummy_ext = os.path.splitext(self.args.input)
            self.output_fn = basename + '.idtt.txt'

        if self.args.mapping:
            self.mapping_fn = self.args.mapping
        else:
            self.mapping_fn = self.output_fn + '.ini'

        self.rerunner_fn = self.output_fn + '.rerun'

    def read_mapping(self):
        self.mapping = configparser.ConfigParser()
        if os.path.isfile(self.mapping_fn):
            print('Reading %r' % self.mapping_fn)
            self.mapping.read(self.mapping_fn)

    def update_mapping(self, style):
        self.mapping[self.section_name(style.realm, style.internal_name)] = {
            'name': style.name,
            'group': style.group or '',
            'legit': style.legit or '',
            'msw_name (readonly)': style.msw_name,
            'parent_msw_name (readonly)': style.parent_msw_name or '',
            'next_msw_name (readonly)': style.followed_by_msw_name or '',
        }

    def write_mapping(self):
        print('Writing %r' % self.mapping_fn)
        with open(self.mapping_fn, 'w') as fo:
            self.mapping.write(fo)

    def write_rerunner(self):
        print('Writing %r' % self.rerunner_fn)
        with open(self.rerunner_fn, 'w') as fo:
            fo.write('#!/bin/bash\n')
            fo.write('# AUTOGENERATED FILE, DO NOT EDIT.\n')
            cli = [
                'exec',
                repr(sys.executable),
                repr(os.path.abspath(sys.argv[0])),
                repr(os.path.abspath(self.args.input)),
            ]
            if self.args.output:
                cli.extend(['--output', repr(os.path.abspath(self.output_fn))])
            if self.args.mapping:
                cli.extend(['--mapping', repr(os.path.abspath(self.mapping_fn))])
            if self.args.stop_at:
                cli.extend(['--stop-at', repr(self.args.stop_at)])
            if self.args.legitimist:
                cli.append('--legitimist')
            fo.write(' '.join(cli))
            fo.write('\n')
        os.chmod(self.rerunner_fn, 0o755)

    def create_db(self):
        engine = sa.create_engine('sqlite:///:memory:')
        self.session = sa.orm.scoped_session(sa.orm.sessionmaker())
        self.session.configure(bind=engine)
        Base.metadata.create_all(engine)

    def load_docx(self):
        print('Reading %r' % self.args.input)
        with zipfile.ZipFile(self.args.input) as self.docx:
            self.scan_styles(self.load_xml('word/styles.xml'))
            self.document = self.load_xml('word/document.xml')
            self.footnotes = self.load_xml('word/footnotes.xml')

    def load_xml(self, path):
        try:
            with self.docx.open(path) as fo:
                return lxml.etree.parse(fo).getroot()
        except KeyError:
            return None

    def scan_styles(self, styles):
        self.styles = {}
        for s in self.xpath(styles, "//w:style[@w:type][w:name[@w:val]]"):
            realm = s.get(self.wtag('type'))
            internal_name = self.wval(s, 'w:name')

            try:
                section = self.mapping[self.section_name(realm, internal_name)]
                if section.get('group') or (section.get('name') != internal_name):
                    section.setdefault('legit', 'auto')
            except KeyError:
                section = {}

            style = Style(
                realm=realm,
                name=section.get('name') or internal_name,
                group=section.get('group'),
                legit=section.get('legit'),
                internal_name=internal_name,
                msw_name=s.get(self.wtag('styleId')),
                parent_msw_name=self.wval(s, 'w:basedOn'),
                followed_by_msw_name=self.wval(s, 'w:next'),
            )
            self.styles[(style.realm, style.msw_name)] = style
            self.session.add(style)

    def section_name(self, realm, internal_name):
        return '%s:%s' % (realm.capitalize(), internal_name)

    def xpath(self, node, expr):
        return node.xpath(expr, namespaces=self.NS)

    def wval(self, node, prop, on_found=None):
        for pn in self.xpath(node, prop):
            found = pn.get(self.wtag('val'))
            if on_found:
                on_found(found)
            return found
        return None

    def wtag(self, tag):
        return '{%s}%s' % (self.W, tag)

    def write_idtt(self):
        print('Writing %r' % self.output_fn)
        self.current_character_style = None
        with InDesignTaggedTextOutput(self.output_fn, self.args.legitimist) as self.idtt:
            self.convert_document()

    def convert_document(self):
        try:
            self.stop_marker_found = False
            for p in self.xpath(self.document, '//w:body/w:p'):
                self.convert_paragraph(p)
        except StopMarkerFound:
            self.stop_marker_found = True

    def convert_paragraph(self, p):
        self.idtt.enter_paragraph(self.wvstyle(p, 'w:pPr/w:pStyle', 'paragraph'))
        try:
            for r in self.xpath(p, 'w:r'):
                self.convert_range(r)
        finally:
            self.idtt.leave_paragraph()

    def convert_range(self, r):
        style = self.wvstyle(r, 'w:rPr/w:rStyle', 'character')
        if style != self.current_character_style:
            self.idtt.set_character_style(style)
            self.current_character_style = style
        for t in self.xpath(r, 'w:tab'):
            self.idtt.write_text('\t')
        for t in self.xpath(r, 'w:t'):
            self.write_text(t)
        for fnr in self.xpath(r, 'w:footnoteReference'):
            self.convert_footnote_reference(fnr)

    def write_text(self, node):
        try:
            text = node.text
            if not self.args.stop_at:
                return
            offset = text.find(self.args.stop_at)
            if offset < 0:
                return
            text = text[:offset]
            raise StopMarkerFound()
        finally:
            self.idtt.write_text(text)

    def convert_footnote_reference(self, fnr):
        fnid = fnr.get(self.wtag('id'))
        self.idtt.enter_footnote()
        try:
            for fn in self.xpath(self.footnotes, 'w:footnote[@w:id="%s"]' % fnid):
                self.convert_footnote(fn)
        finally:
            self.idtt.leave_footnote()

    def convert_footnote(self, fn):
        body_character_style = self.current_character_style
        self.current_character_style = None

        for p in self.xpath(fn, 'w:p'):
            self.convert_paragraph(p)

        self.current_character_style = body_character_style

    def wvstyle(self, node, expr, realm, on_found=None):
        msw_name = self.wval(node, expr)
        if not msw_name:
            return None
        style = self.styles[(realm, msw_name)]
        self.update_mapping(style)
        if on_found:
            on_found(style)
        return style


class InDesignTaggedTextOutput(object):
    def __init__(self, filename, legitimist=False):
        self._filename = filename
        self._styles = []
        self._headers_written = False
        self._shades = collections.defaultdict(itertools.count)
        self._legitimist = legitimist

    def __enter__(self):
        self._fo = open(self._filename, 'w', encoding='UTF-16LE')
        self._ufo = open(self._filename + '.utf8', 'w', encoding='UTF-8')
        return self

    def __exit__(self, *exception):
        self._fo.close()
        self._ufo.close()

    def _write(self, string):
        if not string:
            return
        self._fo.write(string)
        self._ufo.write(string)

    def _writeln(self, line=''):
        self._write(line)
        self._write('\n')

    def define_style(self, style):
        if style in self._styles:
            return
        if style.parent:
            self.define_style(style.parent)
        if style.followed_by:
            self.define_style(style.followed_by)
        self._styles.append(style)
        if self._headers_written:
            self._write_style_definition(style)

    def _write_headers(self):
        if self._headers_written:
            return
        self._writeln('<UNICODE-MAC>')
        self._write(r'<Version:13.1>')
        self._write(r'<FeatureSet:Indesign-R2L>')
        self._write(r'<ColorTable:=')
        self._write(r'<Black:COLOR:CMYK:Process:0,0,0,1>')
        self._write(r'<Yellow:COLOR:CMYK:Process:0,0,1,0>')
        self._write(r'<Magenta:COLOR:CMYK:Process:0,1,0,0>')
        self._write(r'>')
        self._writeln()
        for style in self._styles:
            self._write_style_definition(style)
            self._writeln()
        self._headers_written = True

    def _write_style_definition(self, style):
        fullness = 50.0 + 50.0 / (1.05 ** next(self._shades[style.realm]))

        if style.realm == 'paragraph':
            id_realm = 'Para'
            color = r'<pShadingColor:Yellow><pShadingOn:1>'
            shade = r'<pShadingTint:%s>' % int(100 - fullness)
        elif style.realm == 'character':
            id_realm = 'Char'
            color = r'<cColor:Magenta>'
            shade = r'<cColorTint:%s>' % int(fullness)

        self._write('<Define')
        self._write(id_realm)
        self._write('Style:')
        self._write(style.absname)
        if not (self._legitimist and style.legit):
            self._write(color)
            self._write(shade)

        if style.parent:
            self._write('<BasedOn:')
            self._write(style.parent.absname)
            self._write('>')
        if style.followed_by:
            self._write('<Nextstyle:')
            self._write(style.followed_by.absname)
            self._write('>')
        self._write('>')

    def enter_paragraph(self, style=None):
        self._write_headers()
        self._set_style('Para', style)

    def _set_style(self, realm, style):
        if style:
            self.define_style(style)
        self._write('<')
        self._write(realm)
        self._write('Style:')
        if style:
            self._write(style.absname)
        self._write('>')

    def leave_paragraph(self):
        self._writeln()

    def set_character_style(self, style=None):
        self._set_style('Char', style)

    def enter_footnote(self):
        self._write('<cPosition:Superscript><FootnoteStart:>')

    def leave_footnote(self):
        self._write('<FootnoteEnd:><cPosition:>')

    def write_text(self, text):
        self._write(text)


if __name__ == '__main__':
    DocxToIdtt().run()
