#!/usr/bin/env python3
"""A utility to convert .docx to InDesign's Tagged Text."""
import os
import re
import sys
import argparse
import configparser
import zipfile
import collections
import itertools
import lxml.etree
import logging
import attr
logger = logging

# TODO: Something usable for those balloons
# TODO: Autocreate character styles from manual combos
#       bold: w:b (w:bCs?); italic: w:i (w:iCs?); undeline w:u
#       font: <w:rFonts w:ascii="Courier New" w:hAnsi="Courier New" w:cs="Courier New">
#       override style: <w:i w:val="0">
# TODO: (f)odt import
# TODO: idml import
# TODO: Automatic header group
# TODO: Real BiDi?
# TODO ONE DAY: Endnotes
# TODO ONE DAY: Editing marks
# TODO MAYBE: Linked styles?
# TODO MAYBE: Derivation rules?
# TODO MAYBE: Latent styles?
# TODO: Less files -- what can I put in the ini file/variables?


@attr.s
class Style(object):
    realm = attr.ib()
    msw_name = attr.ib()
    name = attr.ib(default=None)
    legit = attr.ib(default=None)
    internal_name = attr.ib(default=None)
    parent_msw_name = attr.ib(default=None)
    followed_by_msw_name = attr.ib(default=None)
    used = attr.ib(default=None)
    color = attr.ib(default=None)
    tint = attr.ib(default=None)

    parent = attr.ib(default=None)
    followed_by = attr.ib(default=None)

    def __str__(self):
        desc = [self.realm, repr(self.name)]
        if self.internal_name and self.internal_name != self.name:
            desc.extend(['[', self.internal_name, ']'])
        if self.parent:
            desc.extend(['inherits ', repr(self.parent.name)])
        if self.followed_by:
            desc.extend(['followed by ', repr(self.followed_by.name)])
        return '<%s>' % ' '.join(desc)


class StopMarkerFound(Exception):
    """We raise this to stop the presses."""
    pass


class DocxToIdtt(object):
    """Read a docx file. Write an InDesign Tagged Text file. What's not to like?"""
    W = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    NS = {'w': W}

    SPECIAL_GROUP = '(autogenerated)'
    DEFAULT_BASE = SPECIAL_GROUP + '/(Basic Style)'
    COMMENT_MARK_STYLE = SPECIAL_GROUP + '/(Comment Mark)'
    COMMENT_RANGE_START = '\u201C'
    COMMENT_RANGE_END = '\u201D'
    COMMENT_START = '\u2018'
    COMMENT_END = '\u2019'

    def run(self):
        """Main entry point."""
        self.parse_command_line()
        self.configure_logging()
        self.read_mapping()
        self.load_docx()
        self.write_idtt()
        self.report_style_counts()
        self.write_mapping()
        self.write_rerunner()

    def parse_command_line(self):
        """Find out what we're supposed to do."""
        self.parser = argparse.ArgumentParser(description='Word to Indesign Tagged Text')
        self.parser.add_argument('input', help='Input .docx file')
        self.parser.add_argument('output', nargs='?',
                                 help='InDesign Tagged Text file')
        self.parser.add_argument('-m', '--mapping', metavar='INI_FILE',
                                 required=False,
                                 help='Style mapping file')
        self.parser.add_argument('-s', '--stop-at', metavar='TEXT',
                                 required=False,
                                 help='Stop importing when TEXT is found')
        self.parser.add_argument('-l', '--legitimist', action='store_true',
                                 help='No highlighting for legit styles.')
        self.parser.add_argument('-c', '--base-character-style', metavar='NAME',
                                 default=self.DEFAULT_BASE,
                                 help='Base all character styles on this.')
        self.parser.add_argument('-p', '--base-paragraph-style', metavar='NAME',
                                 default=self.DEFAULT_BASE,
                                 help='Base all paragraph styles on this.')
        self.parser.add_argument('-f', '--fresh-start', action='store_true',
                                 help='Do not read any existing settings.')
        self.parser.add_argument('-d', '--debug', action='store_true',
                                 help='Print interesting debug information.')
        self.args = self.parser.parse_args()

        if self.args.output:
            self.output_fn = self.args.output
        else:
            basename, dummy_ext = os.path.splitext(self.args.input)
            self.output_fn = basename + '.idtt.txt'

        if self.args.mapping:
            self.mapping_fn = self.args.mapping
        else:
            self.mapping_fn = self.output_fn + '.ini'

        self.rerunner_fn = self.output_fn + '.rerun'

    def configure_logging(self):
        logging.basicConfig(
            format='%(asctime)s %(message)s',
            level=logging.DEBUG if self.args.debug else logging.INFO
        )

    def read_mapping(self):
        """Read any user overrides to the basic Word->InDesign mapping."""
        self.mapping = configparser.ConfigParser()
        if os.path.isfile(self.mapping_fn) and not self.args.fresh_start:
            logger.info('Reading %r', self.mapping_fn)
            self.mapping.read(self.mapping_fn)

    def write_mapping(self):
        """When done, write the mapping file for the next time."""
        logger.info('Writing %r', self.mapping_fn)
        with open(self.mapping_fn, 'w') as fo:
            self.mapping.write(fo)

    def write_rerunner(self):
        logger.info('Writing %r', self.rerunner_fn)
        with open(self.rerunner_fn, 'w') as fo:
            fo.write(
                '#!/bin/bash\n'
                '# AUTOGENERATED FILE, DO NOT EDIT.\n'
                '\n'
            )
            cli = [
                repr(sys.executable),
                repr(os.path.abspath(sys.argv[0])),
                repr(os.path.abspath(self.args.input)),
            ]
            if self.args.output:
                cli.append(repr(os.path.abspath(self.output_fn)))
            if self.args.mapping:
                cli.extend(['--mapping', repr(os.path.abspath(self.mapping_fn))])
            if self.args.stop_at:
                cli.extend(['--stop-at', repr(self.args.stop_at)])
            if self.args.base_character_style != self.DEFAULT_BASE:
                cli.extend(['--base-character-style', repr(self.args.base_character_style)])
            if self.args.base_paragraph_style != self.DEFAULT_BASE:
                cli.extend(['--base-paragraph-style', repr(self.args.base_paragraph_style)])
            if self.args.legitimist:
                cli.append('--legitimist')
            if self.args.debug:
                cli.append('--debug')
            cli.extend(['>', os.path.abspath(self.rerunner_fn + '.output'), '2>&1'])
            fo.write(' '.join(cli))
            fo.write('\n')
        os.chmod(self.rerunner_fn, 0o755)

    def load_docx(self):
        logger.info('Reading %r', self.args.input)
        with zipfile.ZipFile(self.args.input) as self.docx:
            self.scan_styles(self.load_xml('word/styles.xml'))
            self.document = self.scan_for_styles(self.load_xml('word/document.xml'))
            self.footnotes = self.scan_for_styles(self.load_xml('word/footnotes.xml'))
            self.comments = self.scan_for_styles(self.load_xml('word/comments.xml'))

    def load_xml(self, path):
        try:
            with self.docx.open(path) as fo:
                return lxml.etree.parse(fo).getroot()
        except KeyError:
            return None

    def scan_styles(self, styles):
        """Create a Style object for everything in the document."""
        self.styles = {}
        self.add_special_styles()
        for s in self.xpath(styles, "//w:style[@w:type][w:name[@w:val]]"):
            self.found_style(
                realm=s.get(self.wtag('type')),
                internal_name=self.wval(s, 'w:name'),
                msw_name=s.get(self.wtag('styleId')),
                parent_msw_name=self.wval(s, 'w:basedOn'),
                followed_by_msw_name=self.wval(s, 'w:next'),
            )

        for style in self.styles.values():
            if style.parent_msw_name:
                style.parent = self.styles[self.style_key(
                    realm=style.realm, msw_name=style.parent_msw_name
                )]
            if style.followed_by_msw_name:
                style.followed_by = self.styles[self.style_key(
                    realm=style.realm, msw_name=style.followed_by_msw_name
                )]

    def scan_for_styles(self, node):
        """Mark which styles are actually used."""
        if node:
            self.activate_real_styles(node, 'w:pStyle', 'paragraph')
            self.activate_real_styles(node, 'w:rStyle', 'character')
        return node

    def activate_real_styles(self, node, tag, realm):
        for sn in self.xpath(node, '//%s' % tag):
            msw_name = sn.get(self.wtag('val'))
            self.styles[self.style_key(realm=realm, msw_name=msw_name)].used = True

    def add_special_styles(self):
        self.base_names = {
            'character': self.args.base_character_style,
            'paragraph': self.args.base_paragraph_style,
        }
        self.base_styles = {
            realm: self.found_style(
                realm=realm,
                internal_name=name,
                msw_name=name,
            )
            for realm, name in self.base_names.items()
        }
        self.comment_mark_style = self.found_style(
            realm='character',
            internal_name=self.COMMENT_MARK_STYLE,
            msw_name=self.COMMENT_MARK_STYLE,
            color='Cyan',
            tint=100,
        )

    def found_style(self, realm, internal_name, msw_name, **kwargs):
        if realm not in self.base_names:
            logger.debug('What about %s:%r [%r]?', realm, msw_name, internal_name)
            return

        try:
            section = self.mapping[self.section_name(realm, internal_name)]
            if section.get('name') != internal_name:
                section.setdefault('legit', 'auto')
        except KeyError:
            section = {}

        if msw_name != self.base_names.get(realm):
            kwargs.setdefault('parent_msw_name', self.base_names.get(realm))

        return self.add_style(
            realm=realm,
            name=section.get('name') or internal_name,
            legit=section.get('legit'),
            internal_name=internal_name,
            msw_name=msw_name,
            **kwargs
        )

    def add_style(self, **kwargs):
        style = Style(**kwargs)
        self.styles[self.style_key(style)] = style
        return style

    def style_key(self, style=None, realm=None, msw_name=None):
        if style:
            realm = style.realm
            msw_name = style.msw_name
        return '%s:%s' % (realm.capitalize(), msw_name)

    def section_name(self, realm, internal_name):
        return '%s:%s' % (realm.capitalize(), internal_name)

    def xpath(self, node, expr):
        return node.xpath(expr, namespaces=self.NS)

    def wval(self, node, prop):
        for pn in self.xpath(node, prop):
            return pn.get(self.wtag('val'))
        return None

    def wtag(self, tag):
        return '{%s}%s' % (self.W, tag)

    def write_idtt(self):
        logger.info('Writing %r', self.output_fn)
        self.current_character_style = None
        with InDesignTaggedTextOutput(self.output_fn, self.args.legitimist, self.args.debug) as self.idtt:
            self.convert_document()

    def convert_document(self):
        try:
            self.stop_marker_found = False
            for p in self.xpath(self.document, '//w:body/w:p'):
                self.convert_paragraph(p)
        except StopMarkerFound:
            self.stop_marker_found = True

    def convert_paragraph(self, p):
        self.idtt.enter_paragraph(self.wvstyle(p, 'w:pPr/w:pStyle', 'paragraph'))
        try:
            for node in p.iterchildren():
                if node.tag == self.wtag('r'):
                    self.convert_range(node)
                # elif node.tag == self.wtag('commentRangeStart'):
                #     self.add_comment_marker(self.COMMENT_RANGE_START)
                # elif node.tag == self.wtag('commentRangeEnd'):
                #     self.add_comment_marker(self.COMMENT_RANGE_END)
        finally:
            self.idtt.leave_paragraph()

    def convert_range(self, r):
        self.switch_character_style(self.wvstyle(r, 'w:rPr/w:rStyle', 'character'))
        self.convert_range_text(r)
        for fnr in self.xpath(r, 'w:footnoteReference'):
            self.convert_footnote_reference(fnr)
        for fnr in self.xpath(r, 'w:commentReference'):
            self.convert_comment_reference(fnr)

    def convert_range_text(self, r):
        for t in self.xpath(r, 'w:tab'):
            self.idtt.write_text('\t')
        for t in self.xpath(r, 'w:t'):
            self.write_text(t)

    def switch_character_style(self, style):
        prev = self.current_character_style
        if style is not prev:
            self.idtt.set_character_style(style)
            self.current_character_style = style
        return prev

    def write_text(self, node):
        try:
            text = node.text
            if not self.args.stop_at:
                return
            offset = text.find(self.args.stop_at)
            if offset < 0:
                return
            text = text[:offset]
            logger.info('Stop marker found')
            raise StopMarkerFound()
        finally:
            self.idtt.write_text(text)

    def convert_footnote_reference(self, fnr):
        fnid = fnr.get(self.wtag('id'))
        self.idtt.enter_footnote()
        try:
            for fn in self.xpath(self.footnotes, 'w:footnote[@w:id="%s"]' % fnid):
                self.convert_footnote(fn)
        finally:
            self.idtt.leave_footnote()

    def convert_footnote(self, fn):
        with self.NestedStyle(self):
            for p in self.xpath(fn, 'w:p'):
                self.convert_paragraph(p)

    def convert_comment_reference(self, cmr):
        cmid = cmr.get(self.wtag('id'))
        for cm in self.xpath(self.comments, 'w:comment[@w:id="%s"]' % cmid):
            self.convert_comment(cm)

    def convert_comment(self, cm):
        outer = self.switch_character_style(self.comment_mark_style)
        for r in self.xpath(cm, 'w:p/w:r'):
            self.convert_range_text(r)
        self.switch_character_style(outer)

    def add_comment_marker(self, marker):
        cstyle = self.switch_character_style(self.comment_mark_style)
        self.idtt.write_text(marker)
        self.switch_character_style(cstyle)

    class NestedStyle(object):
        def __init__(self, parent):
            self.parent = parent

        def __enter__(self):
            self.parent_character_style = self.parent.current_character_style
            self.parent.current_character_style = None
            return self

        def __exit__(self, *exception):
            self.parent.current_character_style = self.parent_character_style

    def report_style_counts(self):
        realms = {s.realm for s in self.styles.values()}
        for realm in realms:
            logger.info('Number of %s styles used: %u',
                        realm.capitalize(),
                        sum(1 for s in self.styles.values() if s.realm == realm and s.used))

    def wvstyle(self, node, expr, realm):
        msw_name = self.wval(node, expr)
        if not msw_name:
            return None

        style = self.styles[self.style_key(realm=realm, msw_name=msw_name)]
        self.update_mapping(style)
        return style

    def update_mapping(self, style):
        section_name = self.section_name(style.realm, style.internal_name)
        if section_name in self.mapping:
            return

        if style.parent and style.parent.used:
            self.update_mapping(style.parent)
        elif style.parent_msw_name:
            logger.warn('[%s] inherits missing %r', section_name, style.parent_msw_name)

        self.mapping[section_name] = {
            'name': style.name,
            'legit': style.legit or '',
            'msw_name (readonly)': style.msw_name,
            'parent_msw_name (readonly)': style.parent_msw_name or '',
            'next_msw_name (readonly)': style.followed_by_msw_name or '',
        }
        if style.followed_by and style.followed_by.used:
            self.update_mapping(style.followed_by)
        elif style.followed_by_msw_name:
            logger.warn('[%s] leads to missing %r', section_name, style.followed_by_msw_name)


class InDesignTaggedTextOutput(object):
    def __init__(self, filename, legitimist=False, debug=False):
        self._filename = filename
        self._styles = []
        self._headers_written = False
        self._shades = collections.defaultdict(itertools.count)
        self._legitimist = legitimist
        self._debug = debug

    def __enter__(self):
        self._fo = open(self._filename, 'w', encoding='UTF-16LE')
        if self._debug:
            self._ufo = open(self._filename + '.utf8', 'w', encoding='UTF-8')
        return self

    def __exit__(self, *exception):
        self._fo.close()
        if self._debug:
            self._ufo.close()

    def _write(self, string):
        if not string:
            return
        self._fo.write(string)
        if self._debug:
            self._ufo.write(string)

    def _writeln(self, line=''):
        self._write(line)
        self._write('\n')

    def define_style(self, style):
        if style in self._styles:
            return

        if style.parent and style.parent.used:
            self.define_style(style.parent)

        self._styles.append(style)

        if style.followed_by and style.followed_by.used:
            self.define_style(style.followed_by)
        if self._headers_written:
            self._write_style_definition(style)

    def _write_headers(self):
        if self._headers_written:
            return
        self._writeln('<UNICODE-MAC>')
        self._write(r'<Version:13.1>')
        self._write(r'<FeatureSet:Indesign-R2L>')
        self._write(r'<ColorTable:=')
        self._write(r'<Black:COLOR:CMYK:Process:0,0,0,1>')
        self._write(r'<Cyan:COLOR:CMYK:Process:1,0,0,0>')
        self._write(r'<Magenta:COLOR:CMYK:Process:0,1,0,0>')
        self._write(r'<Yellow:COLOR:CMYK:Process:0,0,1,0>')
        self._write(r'>')
        self._writeln()
        for style in self._styles:
            self._write_style_definition(style)
            self._writeln()
        self._headers_written = True

    def _write_style_definition(self, style):
        logger.debug('InDesign: %s', style.name)
        if style.tint is None:
            fullness = 50.0 + 50.0 / (1.05 ** next(self._shades[style.realm]))

        if style.realm == 'paragraph':
            id_realm = 'Para'
            color = r'<pShadingColor:%s><pShadingOn:1>' % (style.color or 'Yellow')
            shade = r'<pShadingTint:%s>' % (style.tint or int(100 - fullness))
        elif style.realm == 'character':
            id_realm = 'Char'
            color = r'<cColor:%s>' % (style.color or 'Magenta')
            shade = r'<cColorTint:%s>' % (style.tint or int(fullness))

        self._write('<Define')
        self._write(id_realm)
        self._write('Style:')
        self._write(self.idname(style))
        if not (self._legitimist and style.legit):
            self._write(color)
            self._write(shade)

        if style.parent and style.parent.used:
            self._write('<BasedOn:')
            self._write(self.idname(style.parent))
            self._write('>')
        if style.followed_by and style.followed_by.used:
            self._write('<Nextstyle:')
            self._write(self.idname(style.followed_by))
            self._write('>')
        self._write('>')

    def enter_paragraph(self, style=None):
        self._write_headers()
        self._set_style('Para', style)

    def _set_style(self, realm, style):
        if style:
            self.define_style(style)
        self._write('<')
        self._write(realm)
        self._write('Style:')
        if style:
            self._write(self.idname(style))
        self._write('>')

    def idname(self, style):
        return re.sub(r'\s*/\s*', r'\:', style.name)

    def leave_paragraph(self):
        self._writeln()

    def set_character_style(self, style=None):
        self._set_style('Char', style)

    def enter_footnote(self):
        self._write('<cPosition:Superscript><FootnoteStart:>')

    def leave_footnote(self):
        self._write('<FootnoteEnd:><cPosition:>')

    def write_text(self, text):
        self._write(text)


if __name__ == '__main__':
    DocxToIdtt().run()
